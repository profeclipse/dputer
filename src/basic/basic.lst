
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -q -Wmacro-prefix --tab-size=4 -l /Users/davidhunt/Projects/dputer2/src/basic/basic.lbl -L /Users/davidhunt/Projects/dputer2/src/basic/basic.lst -I /Users/davidhunt/Projects/dputer2/src/basic/../kernel -o /Users/davidhunt/Projects/dputer2/src/basic/basic.bin /Users/davidhunt/Projects/dputer2/src/basic/min_mon.asm
; Sat Mar  4 22:05:42 2023

;Offset	;Hex			;Monitor		;Source

;******  Processing input file: /Users/davidhunt/Projects/dputer2/src/basic/min_mon.asm


;******  Processing file: /Users/davidhunt/Projects/dputer2/src/basic/../kernel/kernel.lbl

=$fffe									IRQVEC			= $fffe
=$ff80									CHROUT			= $ff80
=$e9									BRK_PC_VECTOR	= $e9
=$ff86									CHRCHK			= $ff86
=$d2									STRIN_VECTOR	= $d2
=$d8									YSAVE			= $d8
=3										FILEIO_CMD_READ	= 3
=$da									ASAVE2			= $da
=$ef									KBD_RPTR		= $ef
=2										TERMIO_CMD_HOME	= 2
=$e18f									KGETSCRH		= $e18f
=1										TERMIO_CMD_CLS	= 1
=56321									TERMIO_IDATA	= 56321
=56343									FILEIO_CDATA_HI2= 56343
=$e072									KREADTERM		= $e072
=2										FILEIO_CMD_CLOSE= 2
=$e265									DONMI			= $e265
=$ff									INPUT_BUFFER_LEN= $ff
=$f5									HEX_ADDR_BUFFER	= $f5
=$e11b									KCLS			= $e11b
=56320									TERMIO_IREADY	= 56320
=$e0f4									KWRITESTR		= $e0f4
=$d0									STROUT_VECTOR	= $d0
=$ed									MON_BP_ENABLE	= $ed
=1										FILEIO_MODE_READ= 1
=$e16f									KSETCURXY		= $e16f
=56338									FILEIO_CFD		= 56338
=56342									FILEIO_CDATA_LO2= 56342
=$f1									IRQ_SAVE_A		= $f1
=$e0a1									KGETSTR			= $e0a1
=56337									FILEIO_CCMD		= 56337
=$ec									MON_FROM_BRK	= $ec
=$f3									IRQ_SAVE_Y		= $f3
=$f2									IRQ_SAVE_X		= $f2
=2										FILEIO_STATUS_ERR= 2
=$e8									BRK_SAVE_SP		= $e8
=$ff83									CHRIN			= $ff83
=5										FILEIO_CMD_SEEK	= 5
=$e3									MON_OPCODE_VECTOR= $e3
=$de00									INPUT_BUFFER	= $de00
=$e1c5									KGETCURY		= $e1c5
=$e1aa									KGETCURX		= $e1aa
=$f8									MON_COLD_START	= $f8
=10										FILEIO_CMD_RESIZE= 10
=$dd00									KBD_BUFFER		= $dd00
=$f252									KMONINIT		= $f252
=56339									FILEIO_CMODE	= 56339
=$d4									T1_VECTOR		= $d4
=3										TERMIO_CMD_CURSOR_X= 3
=$fffc									RESVEC			= $fffc
=56324									TERMIO_CREADY	= 56324
=$e000									KERNELSTART		= $e000
=7										FILEIO_CMD_FILEPOS= 7
=$e1									MON_ADDR_VECTOR	= $e1
=$e202									DOIRQ			= $e202
=$ff8c									KWHEXBYT		= $ff8c
=$e0e2									KWRITETERM		= $e0e2
=56325									TERMIO_CCMD		= 56325
=$f4									IRQ_SAVE_SP		= $f4
=$dc00									TERMIO_BASE		= $dc00
=$e174									KGETSCRW		= $e174
=56322									TERMIO_OREADY	= 56322
=$eb									BRK_STATUS_REG	= $eb
=$d7									XSAVE			= $d7
=$e7									BRK_SAVE_Y		= $e7
=1										FILEIO_CMD_OPEN	= 1
=$ff89									KMON			= $ff89
=$e09b									KGETCHAR		= $e09b
=$ee									KBD_WPTR		= $ee
=$dd									WIMT_VECTOR		= $dd
=56326									TERMIO_CDATA	= 56326
=$dc10									FILEIO_BASE		= $dc10
=$f7									HEX_BYTE_BUFFER	= $f7
=4										TERMIO_CMD_CURSOR_Y= 4
=$ff8f									KPUTSTR			= $ff8f
=$db									XSAVE2			= $db
=$dc									YSAVE2			= $dc
=$e113									KWRITECRLF		= $e113
=9										FILEIO_CMD_FLUSH= 9
=7										TERMIO_CMD_GETCUR_X= 7
=8										TERMIO_CMD_GETCUR_Y= 8
=$e5									BRK_SAVE_A		= $e5
=$dc1a									FILEIO_FILENAME	= $dc1a
=56340									FILEIO_CDATA_LO	= 56340
=1										FILEIO_STATUS_EOF= 1
=56341									FILEIO_CDATA_HI	= 56341
=$e266									MONITOR			= $e266
=$df									MON_CMD_VECTOR	= $df
=$00									USER_ZP			= $00
=$e1e0									KTERMINIT		= $e1e0
=$e089									KUNREADTERM		= $e089
=3										FILEIO_MODE_RW	= 3
=8										FILEIO_CMD_FILESIZ= 8
=$e130									KHOME			= $e130
=56323									TERMIO_ODATA	= 56323
=$e15a									KSETCURY		= $e15a
=$e145									KSETCURX		= $e145
=0										FILEIO_STATUS_OK= 0
=$e000									KRESET			= $e000
=6										TERMIO_CMD_SCREEN_H= 6
=$f0									MON_OPCODE		= $f0
=56336									FILEIO_CREADY	= 56336
=$d9									PSAVE			= $d9
=$fffa									NMIVEC			= $fffa
=$e6									BRK_SAVE_X		= $e6
=$d6									ASAVE			= $d6
=56344									FILEIO_CSTATUS	= 56344
=$e08e									KCHECKTERM		= $e08e
=6										FILEIO_CMD_DELETE= 6
=4										FILEIO_CMD_WRITE= 4
=2										FILEIO_MODE_WRITE= 2
=5										TERMIO_CMD_SCREEN_W= 5

;******  Return to file: /Users/davidhunt/Projects/dputer2/src/basic/min_mon.asm

.b000	a9 2e			lda #$2e			lda #<LAB_getch
.b002	8d 05 02		sta $0205			sta VEC_IN
.b005	a9 b0			lda #$b0			lda #>LAB_getch
.b007	8d 06 02		sta $0206			sta VEC_IN+1
.b00a	a9 3c			lda #$3c			lda #<LAB_putch
.b00c	8d 07 02		sta $0207			sta VEC_OUT
.b00f	a9 b0			lda #$b0			lda #>LAB_putch
.b011	8d 08 02		sta $0208			sta VEC_OUT+1
.b014	a9 3f			lda #$3f			lda #<no_load
.b016	8d 09 02		sta $0209			sta VEC_LD
.b019	a9 b0			lda #$b0			lda #>no_load
.b01b	8d 0a 02		sta $020a			sta VEC_LD+1
.b01e	a9 3f			lda #$3f			lda #<no_save
.b020	8d 0b 02		sta $020b			sta VEC_SV
.b023	a9 b0			lda #$b0			lda #>no_save
.b025	8d 0c 02		sta $020c			sta VEC_SV+1
.b028	4c 5f b0		jmp $b05f			JMP	LAB_COLD		; do EhBASIC cold start
.b02b	4c 00 00		jmp $0000			JMP	LAB_WARM		; do EhBASIC warm start
.b02e									LAB_getch
.b02e	20 72 e0		jsr $e072			JSR KREADTERM
.b031	18				clc					CLC
.b032	f0 07			beq $b03b			BEQ getchdone
.b034	c9 7f			cmp #$7f			CMP #$7F
.b036	d0 02			bne $b03a			BNE notdelete
.b038	a9 08			lda #$08			LDA #$08
.b03a									notdelete
.b03a	38				sec					SEC
.b03b									getchdone
.b03b	60				rts					RTS
.b03c									LAB_putch
.b03c	20 e2 e0		jsr $e0e2			JSR KWRITETERM
.b03f									no_load
.b03f									no_save
.b03f	60				rts					RTS
.b040									LAB_mess
>b040	0d 0a 36 35 30 32 20 45				.text	$0D,$0A,"6502 EhBASIC [C]old/[W]arm ?",$00
>b048	68 42 41 53 49 43 20 5b 43 5d 6f 6c 64 2f 5b 57
>b058	5d 61 72 6d 20 3f 00

;******  Processing file: /Users/davidhunt/Projects/dputer2/src/basic/basic.asm

=$00									LAB_WARM 	= USER_ZP		; BASIC warm start entry point
=1										Wrmjpl 		= USER_ZP+1	; BASIC warm start vector jump low byte
=2										Wrmjph 		= USER_ZP+2	; BASIC warm start vector jump high byte
=3										Usrjmp		= USER_ZP+3		; USR function JMP address
=4										Usrjpl		= USER_ZP+4		; USR function JMP vector low byte
=5										Usrjph		= USER_ZP+5		; USR function JMP vector high byte
=6										Nullct		= USER_ZP+6		; nulls output after each line
=7										TPos		= USER_ZP+7		; BASIC terminal position byte
=8										TWidth		= USER_ZP+8		; BASIC terminal width byte
=9										Iclim		= USER_ZP+9		; input column limit
=10										Itempl		= USER_ZP+10	; temporary integer low byte
=11										Itemph		= USER_ZP+11	; temporary integer high byte
=10										nums_1		= USER_ZP+10	; number to bin/hex string convert MSB
=11										nums_2		= USER_ZP+11	; number to bin/hex string convert
=12										nums_3		= USER_ZP+12	; number to bin/hex string convert LSB
=13										Srchc		= USER_ZP+13	; search character
=13										Temp3		= Srchc			; temp byte used in number routines
=14										Scnquo		= USER_ZP+14	; scan-between-quotes flag
=14										Asrch		= Scnquo		; alt search character
=13										XOAw_l		= Srchc			; eXclusive OR, OR and AND word low byte
=14										XOAw_h		= Scnquo		; eXclusive OR, OR and AND word high byte
=15										Ibptr		= USER_ZP+15	; input buffer pointer
=15										Dimcnt		= Ibptr			; # of dimensions
=15										Tindx		= Ibptr			; token index
=16										Defdim		= USER_ZP+16	; default DIM flag
=17										Dtypef		= USER_ZP+17	; data type flag, $FF=string, $00=numeric
=18										Oquote		= USER_ZP+18	; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
=19										Gclctd		= USER_ZP+19	; garbage collected flag
=20										Sufnxf		= USER_ZP+20	; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
=21										Imode		= USER_ZP+21	; input mode flag, $00=INPUT, $80=READ
=22										Cflag		= USER_ZP+22	; comparison evaluation flag
=23										TabSiz		= USER_ZP+23	; TAB step size (was input flag)
=24										next_s		= USER_ZP+24	; next descriptor stack address
=25										last_sl		= USER_ZP+25	; last descriptor stack address low byte
=26										last_sh		= USER_ZP+26	; last descriptor stack address high byte (always $00)
=27										des_sk		= USER_ZP+27	; descriptor stack start address (temp strings)
=37										ut1_pl		= USER_ZP+37	; utility pointer 1 low byte
=38										ut1_ph		= USER_ZP+38	; utility pointer 1 high byte
=39										ut2_pl		= USER_ZP+39	; utility pointer 2 low byte
=40										ut2_ph		= USER_ZP+40	; utility pointer 2 high byte
=37										Temp_2		= ut1_pl		; temp byte for block move
=41										FACt_1		= USER_ZP+41	; FAC temp mantissa1
=42										FACt_2		= USER_ZP+42	; FAC temp mantissa2
=43										FACt_3		= USER_ZP+43	; FAC temp mantissa3
=42										dims_l		= FACt_2		; array dimension size low byte
=43										dims_h		= FACt_3		; array dimension size high byte
=44										TempB		= USER_ZP+44	; temp page 0 byte
=45										Smeml		= USER_ZP+45	; start of mem low byte		(Start-of-Basic)
=46										Smemh		= USER_ZP+46	; start of mem high byte	(Start-of-Basic)
=47										Svarl		= USER_ZP+47	; start of vars low byte	(Start-of-Variables)
=48										Svarh		= USER_ZP+48	; start of vars high byte	(Start-of-Variables)
=49										Sarryl		= USER_ZP+49	; var mem end low byte		(Start-of-Arrays)
=50										Sarryh		= USER_ZP+50	; var mem end high byte		(Start-of-Arrays)
=51										Earryl		= USER_ZP+51	; array mem end low byte	(End-of-Arrays)
=52										Earryh		= USER_ZP+52	; array mem end high byte	(End-of-Arrays)
=53										Sstorl		= USER_ZP+53	; string storage low byte	(String storage (moving down))
=54										Sstorh		= USER_ZP+54	; string storage high byte	(String storage (moving down))
=55										Sutill		= USER_ZP+55	; string utility ptr low byte
=56										Sutilh		= USER_ZP+56	; string utility ptr high byte
=57										Ememl		= USER_ZP+57	; end of mem low byte		(Limit-of-memory)
=58										Ememh		= USER_ZP+58	; end of mem high byte		(Limit-of-memory)
=59										Clinel		= USER_ZP+59	; current line low byte		(Basic line number)
=60										Clineh		= USER_ZP+60	; current line high byte	(Basic line number)
=61										Blinel		= USER_ZP+61	; break line low byte		(Previous Basic line number)
=62										Blineh		= USER_ZP+62	; break line high byte		(Previous Basic line number)
=63										Cpntrl		= USER_ZP+63	; continue pointer low byte
=64										Cpntrh		= USER_ZP+64	; continue pointer high byte
=65										Dlinel		= USER_ZP+65	; current DATA line low byte
=66										Dlineh		= USER_ZP+66	; current DATA line high byte
=67										Dptrl		= USER_ZP+67	; DATA pointer low byte
=68										Dptrh		= USER_ZP+68	; DATA pointer high byte
=69										Rdptrl		= USER_ZP+69	; read pointer low byte
=70										Rdptrh		= USER_ZP+70	; read pointer high byte
=71										Varnm1		= USER_ZP+71	; current var name 1st byte
=72										Varnm2		= USER_ZP+72	; current var name 2nd byte
=73										Cvaral		= USER_ZP+73	; current var address low byte
=74										Cvarah		= USER_ZP+74	; current var address high byte
=75										Frnxtl		= USER_ZP+75	; var pointer for FOR/NEXT low byte
=76										Frnxth		= USER_ZP+76	; var pointer for FOR/NEXT high byte
=75										Tidx1		= Frnxtl		; temp line index
=75										Lvarpl		= Frnxtl		; let var pointer low byte
=76										Lvarph		= Frnxth		; let var pointer high byte
=77										prstk		= USER_ZP+77	; precedence stacked flag
=79										comp_f		= USER_ZP+79	; compare function flag, bits 0,1 and 2 used
=80										func_l		= USER_ZP+80	; function pointer low byte
=81										func_h		= USER_ZP+81	; function pointer high byte
=80										garb_l		= func_l		; garbage collection working pointer low byte
=81										garb_h		= func_h		; garbage collection working pointer high byte
=82										des_2l		= USER_ZP+82	; string descriptor_2 pointer low byte
=83										des_2h		= USER_ZP+83	; string descriptor_2 pointer high byte
=84										g_step		= USER_ZP+84	; garbage collect step size
=85										Fnxjmp		= USER_ZP+85	; jump vector for functions
=86										Fnxjpl		= USER_ZP+86	; functions jump vector low byte
=87										Fnxjph		= USER_ZP+87	; functions jump vector high byte
=86										g_indx		= Fnxjpl		; garbage collect temp index
=88										FAC2_r		= USER_ZP+88	; FAC2 rounding byte
=89										Adatal		= USER_ZP+89	; array data pointer low byte
=90										Adatah		= USER_ZP+90	; array data pointer high  byte
=89										Nbendl		= Adatal		; new block end pointer low byte
=90										Nbendh		= Adatah		; new block end pointer high  byte
=91										Obendl		= USER_ZP+91	; old block end pointer low byte
=92										Obendh		= USER_ZP+92	; old block end pointer high  byte
=92										numexp		= USER_ZP+92	; string to float number exponent count
=93										expcnt		= USER_ZP+93	; string to float exponent count
=92										numbit		= numexp		; bit count for array element calculations
=94										numdpf		= USER_ZP+94	; string to float decimal point flag
=95										expneg		= USER_ZP+95	; string to float eval exponent -ve flag
=94										Astrtl		= numdpf		; array start pointer low byte
=95										Astrth		= expneg		; array start pointer high  byte
=94										Histrl		= numdpf		; highest string low byte
=95										Histrh		= expneg		; highest string high  byte
=94										Baslnl		= numdpf		; BASIC search line pointer low byte
=95										Baslnh		= expneg		; BASIC search line pointer high  byte
=94										Fvar_l		= numdpf		; find/found variable pointer low byte
=95										Fvar_h		= expneg		; find/found variable pointer high  byte
=94										Ostrtl		= numdpf		; old block start pointer low byte
=95										Ostrth		= expneg		; old block start pointer high  byte
=94										Vrschl		= numdpf		; variable search pointer low byte
=95										Vrschh		= expneg		; variable search pointer high  byte
=96										FAC1_e		= USER_ZP+96	; FAC1 exponent
=97										FAC1_1		= USER_ZP+97	; FAC1 mantissa1
=98										FAC1_2		= USER_ZP+98	; FAC1 mantissa2
=99										FAC1_3		= USER_ZP+99	; FAC1 mantissa3
=100									FAC1_s		= USER_ZP+100	; FAC1 sign (b7)
=96										str_ln		= FAC1_e		; string length
=97										str_pl		= FAC1_1		; string pointer low byte
=98										str_ph		= FAC1_2		; string pointer high byte
=98										des_pl		= FAC1_2		; string descriptor pointer low byte
=99										des_ph		= FAC1_3		; string descriptor pointer high byte
=99										mids_l		= FAC1_3		; MID$ string temp length byte
=101									negnum		= USER_ZP+101 	; string to float eval -ve flag
=101									numcon		= USER_ZP+101	; series evaluation constant count
=102									FAC1_o		= USER_ZP+102	; FAC1 overflow byte
=103									FAC2_e		= USER_ZP+103	; FAC2 exponent
=104									FAC2_1		= USER_ZP+104	; FAC2 mantissa1
=105									FAC2_2		= USER_ZP+105	; FAC2 mantissa2
=106									FAC2_3		= USER_ZP+106	; FAC2 mantissa3
=107									FAC2_s		= USER_ZP+107	; FAC2 sign (b7)
=108									FAC_sc		= USER_ZP+108	; FAC sign comparison, Acc#1 vs #2
=109									FAC1_r		= USER_ZP+109	; FAC1 rounding byte
=108									ssptr_l		= FAC_sc		; string start pointer low byte
=109									ssptr_h		= FAC1_r		; string start pointer high byte
=108									sdescr		= FAC_sc		; string descriptor pointer
=110									csidx		= USER_ZP+110	; line crunch save index
=110									Asptl		= csidx			; array size/pointer low byte
=111									Aspth		= USER_ZP+111	; array size/pointer high byte
=110									Btmpl		= Asptl			; BASIC pointer temp low byte
=111									Btmph		= Aspth			; BASIC pointer temp low byte
=110									Cptrl		= Asptl			; BASIC pointer temp low byte
=111									Cptrh		= Aspth			; BASIC pointer temp low byte
=110									Sendl		= Asptl			; BASIC pointer temp low byte
=111									Sendh		= Aspth			; BASIC pointer temp low byte
=112									LAB_IGBY	= USER_ZP+112	; get next BASIC byte subroutine
=118									LAB_GBYT	= USER_ZP+118	; get current BASIC byte subroutine
=119									Bpntrl		= USER_ZP+119	; BASIC execute (get byte) pointer low byte
=120									Bpntrh		= USER_ZP+120	; BASIC execute (get byte) pointer high byte
=140									Rbyte4		= USER_ZP+140	; extra PRNG byte
=141									Rbyte1		= USER_ZP+141	; most significant PRNG byte
=142									Rbyte2		= USER_ZP+142	; middle PRNG byte
=143									Rbyte3		= USER_ZP+143	; least significant PRNG byte
=144									NmiBase		= USER_ZP+144	; NMI handler enabled/setup/triggered flags
=147									IrqBase		= USER_ZP+147	; IRQ handler enabled/setup/triggered flags
=150									Decss		= USER_ZP+150	; number to decimal string start
=151									Decssp1		= USER_ZP+151	; number to decimal string start
=$80									TK_END		= $80			; END token
=129									TK_FOR		= TK_END+1		; FOR token
=130									TK_NEXT		= TK_FOR+1		; NEXT token
=131									TK_DATA		= TK_NEXT+1		; DATA token
=132									TK_INPUT	= TK_DATA+1		; INPUT token
=133									TK_DIM		= TK_INPUT+1	; DIM token
=134									TK_READ		= TK_DIM+1		; READ token
=135									TK_LET		= TK_READ+1		; LET token
=136									TK_DEC		= TK_LET+1		; DEC token
=137									TK_GOTO		= TK_DEC+1		; GOTO token
=138									TK_RUN		= TK_GOTO+1		; RUN token
=139									TK_IF		= TK_RUN+1		; IF token
=140									TK_RESTORE	= TK_IF+1		; RESTORE token
=141									TK_GOSUB	= TK_RESTORE+1	; GOSUB token
=142									TK_RETIRQ	= TK_GOSUB+1	; RETIRQ token
=143									TK_RETNMI	= TK_RETIRQ+1	; RETNMI token
=144									TK_RETURN	= TK_RETNMI+1	; RETURN token
=145									TK_REM		= TK_RETURN+1	; REM token
=146									TK_STOP		= TK_REM+1		; STOP token
=147									TK_ON		= TK_STOP+1		; ON token
=148									TK_NULL		= TK_ON+1		; NULL token
=149									TK_INC		= TK_NULL+1		; INC token
=150									TK_WAIT		= TK_INC+1		; WAIT token
=151									TK_LOAD		= TK_WAIT+1		; LOAD token
=152									TK_SAVE		= TK_LOAD+1		; SAVE token
=153									TK_DEF		= TK_SAVE+1		; DEF token
=154									TK_POKE		= TK_DEF+1		; POKE token
=155									TK_DOKE		= TK_POKE+1		; DOKE token
=156									TK_CALL		= TK_DOKE+1		; CALL token
=157									TK_DO		= TK_CALL+1		; DO token
=158									TK_LOOP		= TK_DO+1		; LOOP token
=159									TK_PRINT	= TK_LOOP+1		; PRINT token
=160									TK_CONT		= TK_PRINT+1	; CONT token
=161									TK_LIST		= TK_CONT+1		; LIST token
=162									TK_CLEAR	= TK_LIST+1		; CLEAR token
=163									TK_NEW		= TK_CLEAR+1	; NEW token
=164									TK_WIDTH	= TK_NEW+1		; WIDTH token
=165									TK_GET		= TK_WIDTH+1	; GET token
=166									TK_SWAP		= TK_GET+1		; SWAP token
=167									TK_BITSET	= TK_SWAP+1		; BITSET token
=168									TK_BITCLR	= TK_BITSET+1	; BITCLR token
=169									TK_IRQ		= TK_BITCLR+1	; IRQ token
=170									TK_NMI		= TK_IRQ+1		; NMI token
=171									TK_EXIT		= TK_NMI+1		; EXIT token
=172									TK_TAB		= TK_EXIT+1		; TAB token
=173									TK_ELSE		= TK_TAB+1		; ELSE token
=174									TK_TO		= TK_ELSE+1		; TO token
=175									TK_FN		= TK_TO+1		; FN token
=176									TK_SPC		= TK_FN+1		; SPC token
=177									TK_THEN		= TK_SPC+1		; THEN token
=178									TK_NOT		= TK_THEN+1		; NOT token
=179									TK_STEP		= TK_NOT+1		; STEP token
=180									TK_UNTIL	= TK_STEP+1		; UNTIL token
=181									TK_WHILE	= TK_UNTIL+1	; WHILE token
=182									TK_OFF		= TK_WHILE+1	; OFF token
=183									TK_PLUS		= TK_OFF+1		; + token
=184									TK_MINUS	= TK_PLUS+1		; - token
=185									TK_MUL		= TK_MINUS+1	; * token
=186									TK_DIV		= TK_MUL+1		; / token
=187									TK_POWER	= TK_DIV+1		; ^ token
=188									TK_AND		= TK_POWER+1	; AND token
=189									TK_EOR		= TK_AND+1		; EOR token
=190									TK_OR		= TK_EOR+1		; OR token
=191									TK_RSHIFT	= TK_OR+1		; RSHIFT token
=192									TK_LSHIFT	= TK_RSHIFT+1	; LSHIFT token
=193									TK_GT		= TK_LSHIFT+1	; > token
=194									TK_EQUAL	= TK_GT+1		; = token
=195									TK_LT		= TK_EQUAL+1	; < token
=196									TK_SGN		= TK_LT+1		; SGN token
=197									TK_INT		= TK_SGN+1		; INT token
=198									TK_ABS		= TK_INT+1		; ABS token
=199									TK_USR		= TK_ABS+1		; USR token
=200									TK_FRE		= TK_USR+1		; FRE token
=201									TK_POS		= TK_FRE+1		; POS token
=202									TK_SQR		= TK_POS+1		; SQR token
=203									TK_RND		= TK_SQR+1		; RND token
=204									TK_LOG		= TK_RND+1		; LOG token
=205									TK_EXP		= TK_LOG+1		; EXP token
=206									TK_COS		= TK_EXP+1		; COS token
=207									TK_SIN		= TK_COS+1		; SIN token
=208									TK_TAN		= TK_SIN+1		; TAN token
=209									TK_ATN		= TK_TAN+1		; ATN token
=210									TK_PEEK		= TK_ATN+1		; PEEK token
=211									TK_DEEK		= TK_PEEK+1		; DEEK token
=212									TK_SADD		= TK_DEEK+1		; SADD token
=213									TK_LEN		= TK_SADD+1		; LEN token
=214									TK_STRS		= TK_LEN+1		; STR$ token
=215									TK_VAL		= TK_STRS+1		; VAL token
=216									TK_ASC		= TK_VAL+1		; ASC token
=217									TK_UCASES	= TK_ASC+1		; UCASE$ token
=218									TK_LCASES	= TK_UCASES+1	; LCASE$ token
=219									TK_CHRS		= TK_LCASES+1	; CHR$ token
=220									TK_HEXS		= TK_CHRS+1		; HEX$ token
=221									TK_BINS		= TK_HEXS+1		; BIN$ token
=222									TK_BITTST	= TK_BINS+1		; BITTST token
=223									TK_MAX		= TK_BITTST+1	; MAX token
=224									TK_MIN		= TK_MAX+1		; MIN token
=225									TK_PI		= TK_MIN+1		; PI token
=226									TK_TWOPI	= TK_PI+1		; TWOPI token
=227									TK_VPTR		= TK_TWOPI+1	; VARPTR token
=228									TK_LEFTS	= TK_VPTR+1		; LEFT$ token
=229									TK_RIGHTS	= TK_LEFTS+1	; RIGHT$ token
=230									TK_MIDS		= TK_RIGHTS+1	; MID$ token
=0										PLUS_0		= USER_ZP+0	; X or Y plus 0
=1										PLUS_1		= USER_ZP+1	; X or Y plus 1
=2										PLUS_2		= USER_ZP+2	; X or Y plus 2
=3										PLUS_3		= USER_ZP+3	; X or Y plus 3
=$0100									LAB_STAK	= $0100	; stack bottom, no offset
=510									LAB_SKFE	= LAB_STAK+$FE
=511									LAB_SKFF	= LAB_STAK+$FF
=$0200									ccflag		= $0200	; BASIC CTRL-C flag, 00 = enabled, 01 = dis
=513									ccbyte		= ccflag+1	; BASIC CTRL-C byte
=514									ccnull		= ccbyte+1	; BASIC CTRL-C byte timeout
=515									VEC_CC		= ccnull+1	; ctrl c check vector
=517									VEC_IN		= VEC_CC+2	; input vector
=519									VEC_OUT		= VEC_IN+2	; output vector
=521									VEC_LD		= VEC_OUT+2	; load vector
=523									VEC_SV		= VEC_LD+2	; save vector
=545									Ibuffs		= VEC_SV+$16
=616									Ibuffe		= Ibuffs+$47; end of input buffer
=$0300									Ram_base	= $0300	; start of user RAM (set as needed, should be page aligned)
=$b000									Ram_top		= $B000	; end of user RAM+1 (set as needed, should be page aligned)
.b05f									LAB_COLD
.b05f	a0 04			ldy #$04			LDY	#PG2_TABE-PG2_TABS-1
.b061									LAB_2D13
.b061	b9 51 d1		lda $d151,y			LDA	PG2_TABS,Y		; get byte
.b064	99 00 02		sta $0200,y			STA	ccflag,Y		; store in page 2
.b067	88				dey					DEY				; decrement count
.b068	10 f7			bpl $b061			BPL	LAB_2D13		; loop if not done
.b06a	a2 ff			ldx #$ff			LDX	#$FF			; set byte
.b06c	86 3c			stx $3c				STX	Clineh		; set current line high byte (set immediate mode)
.b06e	9a				txs					TXS				; reset stack pointer
.b06f	a9 4c			lda #$4c			LDA	#$4C			; code for JMP
.b071	85 55			sta $55				STA	Fnxjmp		; save for jump vector for functions
.b073	a2 1c			ldx #$1c			LDX	#StrTab-LAB_2CEE	; set byte count
.b075									LAB_2D4E
.b075	bd 55 d1		lda $d155,x			LDA	LAB_2CEE-1,X	; get byte from table
.b078	95 6f			sta $6f,x			STA	LAB_IGBY-1,X	; save byte in page zero
.b07a	ca				dex					DEX				; decrement count
.b07b	d0 f8			bne $b075			BNE	LAB_2D4E		; loop if not all done
.b07d									LAB_GMEM
.b07d	a2 12			ldx #$12			LDX	#EndTab-StrTab-1	; set byte count-1
.b07f									TabLoop
.b07f	bd 72 d1		lda $d172,x			LDA	StrTab,X		; get byte from table
.b082	95 00			sta $00,x			STA	PLUS_0,X		; save byte in page zero
.b084	ca				dex					DEX				; decrement count
.b085	10 f8			bpl $b07f			BPL	TabLoop		; loop if not all done
.b087	a9 00			lda #$00			LDA	#$00			; clear A
.b089	85 90			sta $90				STA	NmiBase		; clear NMI handler enabled flag
.b08b	85 93			sta $93				STA	IrqBase		; clear IRQ handler enabled flag
.b08d	85 66			sta $66				STA	FAC1_o		; clear FAC1 overflow byte
.b08f	85 1a			sta $1a				STA	last_sh		; clear descriptor stack top item pointer high byte
.b091	a9 0e			lda #$0e			LDA	#$0E			; set default tab size
.b093	85 17			sta $17				STA	TabSiz		; save it
.b095	a9 03			lda #$03			LDA	#$03			; set garbage collect step size for descriptor stack
.b097	85 54			sta $54				STA	g_step		; save it
.b099	a2 1b			ldx #$1b			LDX	#des_sk		; descriptor stack start
.b09b	86 18			stx $18				STX	next_s		; set descriptor stack pointer
.b09d	a9 00			lda #$00			lda #<Ram_top
.b09f	85 0a			sta $0a				sta Itempl
.b0a1	a9 b0			lda #$b0			lda #>Ram_top
.b0a3	85 0b			sta $0b				sta Itemph
.b0a5	80 2b			bra $b0d2			bra LAB_2DB6
.b0a7	a0 00			ldy #$00			LDY	#$00			; else clear Y
.b0a9									LAB_2D93
.b0a9	e6 0a			inc $0a				INC	Itempl		; increment temporary integer low byte
.b0ab	d0 08			bne $b0b5			BNE	LAB_2D99		; branch if no overflow
.b0ad	e6 0b			inc $0b				INC	Itemph		; increment temporary integer high byte
.b0af	a5 0b			lda $0b				LDA	Itemph		; get high byte
.b0b1	c9 b0			cmp #$b0			CMP	#>Ram_top		; compare with top of RAM+1
.b0b3	f0 1d			beq $b0d2			BEQ	LAB_2DB6		; branch if match (end of user RAM)
.b0b5									LAB_2D99
.b0b5	a9 55			lda #$55			LDA	#$55			; set test byte
.b0b7	91 0a			sta ($0a),y			STA	(Itempl),Y		; save via temporary integer
.b0b9	d1 0a			cmp ($0a),y			CMP	(Itempl),Y		; compare via temporary integer
.b0bb	d0 15			bne $b0d2			BNE	LAB_2DB6		; branch if fail
.b0bd	0a				asl a				ASL				; shift test byte left (now $AA)
.b0be	91 0a			sta ($0a),y			STA	(Itempl),Y		; save via temporary integer
.b0c0	d1 0a			cmp ($0a),y			CMP	(Itempl),Y		; compare via temporary integer
.b0c2	f0 e5			beq $b0a9			BEQ	LAB_2D93		; if ok go do next byte
.b0c4	d0 0c			bne $b0d2			BNE	LAB_2DB6		; branch if fail
.b0c6									LAB_2DAA
.b0c6	20 00 ca		jsr $ca00			JSR	LAB_2887		; get FAC1 from string
.b0c9	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.b0cb	c9 98			cmp #$98			CMP	#$98			; compare with exponent = 2^24
.b0cd	b0 ae			bcs $b07d			BCS	LAB_GMEM		; if too large go try again
.b0cf	20 51 c5		jsr $c551			JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
.b0d2									LAB_2DB6
.b0d2	a5 0a			lda $0a				LDA	Itempl		; get temporary integer low byte
.b0d4	a4 0b			ldy $0b				LDY	Itemph		; get temporary integer high byte
.b0d6	c0 01			cpy #$01			CPY	#<Ram_base+1	; compare with start of RAM+$100 high byte
.b0d8	90 a3			bcc $b07d			BCC	LAB_GMEM		; if too small go try again
.b0da	85 39			sta $39				STA	Ememl			; set end of mem low byte
.b0dc	84 3a			sty $3a				STY	Ememh			; set end of mem high byte
.b0de	85 35			sta $35				STA	Sstorl		; set bottom of string space low byte
.b0e0	84 36			sty $36				STY	Sstorh		; set bottom of string space high byte
.b0e2	a0 00			ldy #$00			LDY	#<Ram_base		; set start addr low byte
.b0e4	a2 03			ldx #$03			LDX	#>Ram_base		; set start addr high byte
.b0e6	84 2d			sty $2d				STY	Smeml			; save start of mem low byte
.b0e8	86 2e			stx $2e				STX	Smemh			; save start of mem high byte
.b0ea	98				tya					TYA				; clear A
.b0eb	91 2d			sta ($2d),y			STA	(Smeml),Y		; clear first byte
.b0ed	e6 2d			inc $2d				INC	Smeml			; increment start of mem low byte
.b0ef									LAB_2E05
.b0ef	20 e0 b8		jsr $b8e0			JSR	LAB_CRLF		; print CR/LF
.b0f2	20 a3 b3		jsr $b3a3			JSR	LAB_1463		; do "NEW" and "CLEAR"
.b0f5	a5 39			lda $39				LDA	Ememl			; get end of mem low byte
.b0f7	38				sec					SEC				; set carry for subtract
.b0f8	e5 2d			sbc $2d				SBC	Smeml			; subtract start of mem low byte
.b0fa	aa				tax					TAX				; copy to X
.b0fb	a5 3a			lda $3a				LDA	Ememh			; get end of mem high byte
.b0fd	e5 2e			sbc $2e				SBC	Smemh			; subtract start of mem high byte
.b0ff	20 dc ca		jsr $cadc			JSR	LAB_295E		; print XA as unsigned integer (bytes free)
.b102	a9 93			lda #$93			LDA	#<LAB_SMSG		; point to sign-on message (low addr)
.b104	a0 d1			ldy #$d1			LDY	#>LAB_SMSG		; point to sign-on message (high addr)
.b106	20 1c b9		jsr $b91c			JSR	LAB_18C3		; print null terminated string from memory
.b109	a9 ad			lda #$ad			LDA	#<LAB_1274		; warm start vector low byte
.b10b	a0 b1			ldy #$b1			LDY	#>LAB_1274		; warm start vector high byte
.b10d	85 01			sta $01				STA	Wrmjpl		; save warm start vector low byte
.b10f	84 02			sty $02				STY	Wrmjph		; save warm start vector high byte
.b111	6c 01 00		jmp ($0001)			JMP	(Wrmjpl)		; go do warm start
.b114									LAB_11CF
.b114	20 5e b1		jsr $b15e			JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.b117	85 33			sta $33				STA	Earryl		; save new array mem end low byte
.b119	84 34			sty $34				STY	Earryh		; save new array mem end high byte
.b11b									LAB_11D6
.b11b	38				sec					SEC				; set carry for subtract
.b11c	a5 5b			lda $5b				LDA	Obendl		; get block end low byte
.b11e	e5 5e			sbc $5e				SBC	Ostrtl		; subtract block start low byte
.b120	a8				tay					TAY				; copy MOD(block length/$100) byte to Y
.b121	a5 5c			lda $5c				LDA	Obendh		; get block end high byte
.b123	e5 5f			sbc $5f				SBC	Ostrth		; subtract block start high byte
.b125	aa				tax					TAX				; copy block length high byte to X
.b126	e8				inx					INX				; +1 to allow for count=0 exit
.b127	98				tya					TYA				; copy block length low byte to A
.b128	f0 24			beq $b14e			BEQ	LAB_120A		; branch if length low byte=0
.b12a	38				sec					SEC				; set carry for add + 1, two's complement
.b12b	49 ff			eor #$ff			EOR	#$FF			; invert low byte for subtract
.b12d	65 5b			adc $5b				ADC	Obendl		; add block end low byte
.b12f	85 5b			sta $5b				STA	Obendl		; save corrected old block end low byte
.b131	b0 03			bcs $b136			BCS	LAB_11F3		; branch if no underflow
.b133	c6 5c			dec $5c				DEC	Obendh		; else decrement block end high byte
.b135	38				sec					SEC				; set carry for add + 1, two's complement
.b136									LAB_11F3
.b136	98				tya					TYA				; get MOD(block length/$100) byte
.b137	49 ff			eor #$ff			EOR	#$FF			; invert low byte for subtract
.b139	65 59			adc $59				ADC	Nbendl		; add destination end low byte
.b13b	85 59			sta $59				STA	Nbendl		; save modified new block end low byte
.b13d	b0 08			bcs $b147			BCS	LAB_1203		; branch if no underflow
.b13f	c6 5a			dec $5a				DEC	Nbendh		; else decrement block end high byte
.b141	90 04			bcc $b147			BCC	LAB_1203		; branch always
.b143									LAB_11FF
.b143	b1 5b			lda ($5b),y			LDA	(Obendl),Y		; get byte from source
.b145	91 59			sta ($59),y			STA	(Nbendl),Y		; copy byte to destination
.b147									LAB_1203
.b147	88				dey					DEY				; decrement index
.b148	d0 f9			bne $b143			BNE	LAB_11FF		; loop until Y=0
.b14a	b1 5b			lda ($5b),y			LDA	(Obendl),Y		; get byte from source
.b14c	91 59			sta ($59),y			STA	(Nbendl),Y		; save byte to destination
.b14e									LAB_120A
.b14e	c6 5c			dec $5c				DEC	Obendh		; decrement source pointer high byte
.b150	c6 5a			dec $5a				DEC	Nbendh		; decrement destination pointer high byte
.b152	ca				dex					DEX				; decrement block count
.b153	d0 f2			bne $b147			BNE	LAB_1203		; loop until count = $0
.b155	60				rts					RTS
.b156									LAB_1212
.b156	85 2c			sta $2c				STA	TempB			; save result in temp byte
.b158	ba				tsx					TSX				; copy stack
.b159	e4 2c			cpx $2c				CPX	TempB			; compare new "limit" with stack
.b15b	90 30			bcc $b18d			BCC	LAB_OMER		; if stack < limit do "Out of memory" error then warm start
.b15d	60				rts					RTS
.b15e									LAB_121F
.b15e	c4 36			cpy $36				CPY	Sstorh		; compare bottom of string mem high byte
.b160	90 2a			bcc $b18c			BCC	LAB_124B		; if less then exit (is ok)
.b162	d0 04			bne $b168			BNE	LAB_1229		; skip next test if greater (tested <)
.b164	c5 35			cmp $35				CMP	Sstorl		; compare with bottom of string mem low byte
.b166	90 24			bcc $b18c			BCC	LAB_124B		; if less then exit (is ok)
.b168									LAB_1229
.b168	48				pha					PHA				; push addr low byte
.b169	a2 08			ldx #$08			LDX	#$08			; set index to save Adatal to expneg inclusive
.b16b	98				tya					TYA				; copy addr high byte (to push on stack)
.b16c									LAB_122D
.b16c	48				pha					PHA				; push byte
.b16d	b5 58			lda $58,x			LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
.b16f	ca				dex					DEX				; decrement index
.b170	10 fa			bpl $b16c			BPL	LAB_122D		; loop until all done
.b172	20 39 c2		jsr $c239			JSR	LAB_GARB		; garbage collection routine
.b175	a2 00			ldx #$00			LDX	#$00			; clear the index to restore bytes
.b177									LAB_1238
.b177	68				pla					PLA				; pop byte
.b178	95 59			sta $59,x			STA	Adatal,X		; save byte to Adatal to expneg
.b17a	e8				inx					INX				; increment index
.b17b	e0 08			cpx #$08			CPX	#$08			; compare with end + 1
.b17d	30 f8			bmi $b177			BMI	LAB_1238		; loop if more to do
.b17f	68				pla					PLA				; pop addr high byte
.b180	a8				tay					TAY				; copy back to Y
.b181	68				pla					PLA				; pop addr low byte
.b182	c4 36			cpy $36				CPY	Sstorh		; compare bottom of string mem high byte
.b184	90 06			bcc $b18c			BCC	LAB_124B		; if less then exit (is ok)
.b186	d0 05			bne $b18d			BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
.b188	c5 35			cmp $35				CMP	Sstorl		; compare with bottom of string mem low byte
.b18a	b0 01			bcs $b18d			BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
.b18c									LAB_124B
.b18c	60				rts					RTS
.b18d									LAB_OMER
.b18d	a2 0c			ldx #$0c			LDX	#$0C			; error code $0C ("Out of memory" error)
.b18f									LAB_XERR
.b18f	20 e0 b8		jsr $b8e0			JSR	LAB_CRLF		; print CR/LF
.b192	bd 0b d7		lda $d70b,x			LDA	LAB_BAER,X		; get error message pointer low byte
.b195	bc 0c d7		ldy $d70c,x			LDY	LAB_BAER+1,X	; get error message pointer high byte
.b198	20 1c b9		jsr $b91c			JSR	LAB_18C3		; print null terminated string from memory
.b19b	20 dc b3		jsr $b3dc			JSR	LAB_1491		; flush stack and clear continue flag
.b19e	a9 47			lda #$47			LDA	#<LAB_EMSG		; point to " Error" low addr
.b1a0	a0 d8			ldy #$d8			LDY	#>LAB_EMSG		; point to " Error" high addr
.b1a2									LAB_1269
.b1a2	20 1c b9		jsr $b91c			JSR	LAB_18C3		; print null terminated string from memory
.b1a5	a4 3c			ldy $3c				LDY	Clineh		; get current line high byte
.b1a7	c8				iny					INY				; increment it
.b1a8	f0 03			beq $b1ad			BEQ	LAB_1274		; go do warm start (was immediate mode)
.b1aa	20 d1 ca		jsr $cad1			JSR	LAB_2953		; print " in line [LINE #]"
.b1ad									LAB_1274
.b1ad	a9 00			lda #$00			LDA	#$00			; clear A
.b1af	85 93			sta $93				STA	IrqBase		; clear enabled byte
.b1b1	85 90			sta $90				STA	NmiBase		; clear enabled byte
.b1b3	a9 58			lda #$58			LDA	#<LAB_RMSG		; point to "Ready" message low byte
.b1b5	a0 d8			ldy #$d8			LDY	#>LAB_RMSG		; point to "Ready" message high byte
.b1b7	20 1c b9		jsr $b91c			JSR	LAB_18C3		; go do print string
.b1ba									LAB_127D
.b1ba	20 a0 b2		jsr $b2a0			JSR	LAB_1357		; call for BASIC input
.b1bd									LAB_1280
.b1bd	86 77			stx $77				STX	Bpntrl		; set BASIC execute pointer low byte
.b1bf	84 78			sty $78				STY	Bpntrh		; set BASIC execute pointer high byte
.b1c1	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b1c4	f0 f4			beq $b1ba			BEQ	LAB_127D		; loop while null
.b1c6	a2 ff			ldx #$ff			LDX	#$FF			; current line to null value
.b1c8	86 3c			stx $3c				STX	Clineh		; set current line high byte
.b1ca	90 06			bcc $b1d2			BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
.b1cc	20 d1 b2		jsr $b2d1			JSR	LAB_13A6		; crunch keywords into Basic tokens
.b1cf	4c 42 b5		jmp $b542			JMP	LAB_15F6		; go scan and interpret code
.b1d2									LAB_1295
.b1d2	20 a3 b7		jsr $b7a3			JSR	LAB_GFPN		; get fixed-point number into temp integer
.b1d5	20 d1 b2		jsr $b2d1			JSR	LAB_13A6		; crunch keywords into Basic tokens
.b1d8	84 0f			sty $0f				STY	Ibptr			; save index pointer to end of crunched line
.b1da	20 77 b3		jsr $b377			JSR	LAB_SSLN		; search BASIC for temp integer line number
.b1dd	90 44			bcc $b223			BCC	LAB_12E6		; branch if not found
.b1df	a0 01			ldy #$01			LDY	#$01			; set index to next line pointer high byte
.b1e1	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get next line pointer high byte
.b1e3	85 26			sta $26				STA	ut1_ph		; save it
.b1e5	a5 2f			lda $2f				LDA	Svarl			; get start of vars low byte
.b1e7	85 25			sta $25				STA	ut1_pl		; save it
.b1e9	a5 5f			lda $5f				LDA	Baslnh		; get found line pointer high byte
.b1eb	85 28			sta $28				STA	ut2_ph		; save it
.b1ed	a5 5e			lda $5e				LDA	Baslnl		; get found line pointer low byte
.b1ef	88				dey					DEY				; decrement index
.b1f0	f1 5e			sbc ($5e),y			SBC	(Baslnl),Y		; subtract next line pointer low byte
.b1f2	18				clc					CLC				; clear carry for add
.b1f3	65 2f			adc $2f				ADC	Svarl			; add start of vars low byte
.b1f5	85 2f			sta $2f				STA	Svarl			; save new start of vars low byte
.b1f7	85 27			sta $27				STA	ut2_pl		; save destination pointer low byte
.b1f9	a5 30			lda $30				LDA	Svarh			; get start of vars high byte
.b1fb	69 ff			adc #$ff			ADC	#$FF			; -1 + carry
.b1fd	85 30			sta $30				STA	Svarh			; save start of vars high byte
.b1ff	e5 5f			sbc $5f				SBC	Baslnh		; subtract found line pointer high byte
.b201	aa				tax					TAX				; copy to block count
.b202	38				sec					SEC				; set carry for subtract
.b203	a5 5e			lda $5e				LDA	Baslnl		; get found line pointer low byte
.b205	e5 2f			sbc $2f				SBC	Svarl			; subtract start of vars low byte
.b207	a8				tay					TAY				; copy to bytes in first block count
.b208	b0 03			bcs $b20d			BCS	LAB_12D0		; branch if overflow
.b20a	e8				inx					INX				; increment block count (correct for =0 loop exit)
.b20b	c6 28			dec $28				DEC	ut2_ph		; decrement destination high byte
.b20d									LAB_12D0
.b20d	18				clc					CLC				; clear carry for add
.b20e	65 25			adc $25				ADC	ut1_pl		; add source pointer low byte
.b210	90 03			bcc $b215			BCC	LAB_12D8		; branch if no overflow
.b212	c6 26			dec $26				DEC	ut1_ph		; else decrement source pointer high byte
.b214	18				clc					CLC				; clear carry
.b215									LAB_12D8
.b215	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get byte from source
.b217	91 27			sta ($27),y			STA	(ut2_pl),Y		; copy to destination
.b219	c8				iny					INY				; increment index
.b21a	d0 f9			bne $b215			BNE	LAB_12D8		; while <> 0 do this block
.b21c	e6 26			inc $26				INC	ut1_ph		; increment source pointer high byte
.b21e	e6 28			inc $28				INC	ut2_ph		; increment destination pointer high byte
.b220	ca				dex					DEX				; decrement block count
.b221	d0 f2			bne $b215			BNE	LAB_12D8		; loop until all done
.b223									LAB_12E6
.b223	ad 21 02		lda $0221			LDA	Ibuffs		; get byte from start of input buffer
.b226	f0 3f			beq $b267			BEQ	LAB_1319		; if null line just go flush stack/vars and exit
.b228	a5 39			lda $39				LDA	Ememl			; get end of mem low byte
.b22a	a4 3a			ldy $3a				LDY	Ememh			; get end of mem high byte
.b22c	85 35			sta $35				STA	Sstorl		; set bottom of string space low byte
.b22e	84 36			sty $36				STY	Sstorh		; set bottom of string space high byte
.b230	a5 2f			lda $2f				LDA	Svarl			; get start of vars low byte	(end of BASIC)
.b232	85 5b			sta $5b				STA	Obendl		; save old block end low byte
.b234	a4 30			ldy $30				LDY	Svarh			; get start of vars high byte	(end of BASIC)
.b236	84 5c			sty $5c				STY	Obendh		; save old block end high byte
.b238	65 0f			adc $0f				ADC	Ibptr			; add input buffer pointer	(also buffer length)
.b23a	90 01			bcc $b23d			BCC	LAB_1301		; branch if no overflow from add
.b23c	c8				iny					INY				; else increment high byte
.b23d									LAB_1301
.b23d	85 59			sta $59				STA	Nbendl		; save new block end low byte	(move to, low byte)
.b23f	84 5a			sty $5a				STY	Nbendh		; save new block end high byte
.b241	20 14 b1		jsr $b114			JSR	LAB_11CF		; open up space in memory
.b244	a5 33			lda $33				LDA	Earryl		; get array mem end low byte
.b246	a4 34			ldy $34				LDY	Earryh		; get array mem end high byte
.b248	85 2f			sta $2f				STA	Svarl			; save start of vars low byte
.b24a	84 30			sty $30				STY	Svarh			; save start of vars high byte
.b24c	a4 0f			ldy $0f				LDY	Ibptr			; get input buffer pointer	(also buffer length)
.b24e	88				dey					DEY				; adjust for loop type
.b24f									LAB_1311
.b24f	b9 1d 02		lda $021d,y			LDA	Ibuffs-4,Y		; get byte from crunched line
.b252	91 5e			sta ($5e),y			STA	(Baslnl),Y		; save it to program memory
.b254	88				dey					DEY				; decrement count
.b255	c0 03			cpy #$03			CPY	#$03			; compare with first byte-1
.b257	d0 f6			bne $b24f			BNE	LAB_1311		; continue while count <> 3
.b259	a5 0b			lda $0b				LDA	Itemph		; get line # high byte
.b25b	91 5e			sta ($5e),y			STA	(Baslnl),Y		; save it to program memory
.b25d	88				dey					DEY				; decrement count
.b25e	a5 0a			lda $0a				LDA	Itempl		; get line # low byte
.b260	91 5e			sta ($5e),y			STA	(Baslnl),Y		; save it to program memory
.b262	88				dey					DEY				; decrement count
.b263	a9 ff			lda #$ff			LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
.b265	91 5e			sta ($5e),y			STA	(Baslnl),Y		; save it to program memory
.b267									LAB_1319
.b267	20 b8 b3		jsr $b3b8			JSR	LAB_1477		; reset execution to start, clear vars and flush stack
.b26a	a6 2d			ldx $2d				LDX	Smeml			; get start of mem low byte
.b26c	a5 2e			lda $2e				LDA	Smemh			; get start of mem high byte
.b26e	a0 01			ldy #$01			LDY	#$01			; index to high byte of next line pointer
.b270									LAB_1325
.b270	86 25			stx $25				STX	ut1_pl		; set line start pointer low byte
.b272	85 26			sta $26				STA	ut1_ph		; set line start pointer high byte
.b274	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get it
.b276	f0 18			beq $b290			BEQ	LAB_133E		; exit if end of program
.b278	a0 04			ldy #$04			LDY	#$04			; point to first code byte of line
.b27a									LAB_1330
.b27a	c8				iny					INY				; next code byte
.b27b	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get byte
.b27d	d0 fb			bne $b27a			BNE	LAB_1330		; loop if not [EOL]
.b27f	38				sec					SEC				; set carry for add + 1
.b280	98				tya					TYA				; copy end index
.b281	65 25			adc $25				ADC	ut1_pl		; add to line start pointer low byte
.b283	aa				tax					TAX				; copy to X
.b284	a0 00			ldy #$00			LDY	#$00			; clear index, point to this line's next line pointer
.b286	91 25			sta ($25),y			STA	(ut1_pl),Y		; set next line pointer low byte
.b288	98				tya					TYA				; clear A
.b289	65 26			adc $26				ADC	ut1_ph		; add line start pointer high byte + carry
.b28b	c8				iny					INY				; increment index to high byte
.b28c	91 25			sta ($25),y			STA	(ut1_pl),Y		; save next line pointer low byte
.b28e	90 e0			bcc $b270			BCC	LAB_1325		; go do next line, branch always, carry clear
.b290									LAB_133E
.b290	4c ba b1		jmp $b1ba			JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
.b293									LAB_INLN
.b293	20 34 b9		jsr $b934			JSR	LAB_18E3		; print "?" character
.b296	20 31 b9		jsr $b931			JSR	LAB_18E0		; print " "
.b299	d0 05			bne $b2a0			BNE	LAB_1357		; call for BASIC input and return
.b29b									LAB_134B
.b29b	20 36 b9		jsr $b936			JSR	LAB_PRNA		; go print the character
.b29e	ca				dex					DEX				; decrement the buffer counter (delete)
>b29f	2c									.byte	$2C			; make LDX into BIT abs
.b2a0									LAB_1357
.b2a0	a2 00			ldx #$00			LDX	#$00			; clear BASIC line buffer pointer
.b2a2									LAB_1359
.b2a2	20 45 d1		jsr $d145			JSR	V_INPT		; call scan input device
.b2a5	90 fb			bcc $b2a2			BCC	LAB_1359		; loop if no byte
.b2a7	f0 f9			beq $b2a2			BEQ	LAB_1359		; loop until valid input (ignore NULLs)
.b2a9	c9 07			cmp #$07			CMP	#$07			; compare with [BELL]
.b2ab	f0 10			beq $b2bd			BEQ	LAB_1378		; branch if [BELL]
.b2ad	c9 0d			cmp #$0d			CMP	#$0D			; compare with [CR]
.b2af	f0 19			beq $b2ca			BEQ	LAB_1384		; do CR/LF exit if [CR]
.b2b1	e0 00			cpx #$00			CPX	#$00			; compare pointer with $00
.b2b3	d0 04			bne $b2b9			BNE	LAB_1374		; branch if not empty
.b2b5	c9 21			cmp #$21			CMP	#$21			; compare with [SP]+1
.b2b7	90 e9			bcc $b2a2			BCC	LAB_1359		; if < ignore character
.b2b9									LAB_1374
.b2b9	c9 08			cmp #$08			CMP	#$08			; compare with [BACKSPACE] (delete last character)
.b2bb	f0 de			beq $b29b			BEQ	LAB_134B		; go delete last character
.b2bd									LAB_1378
.b2bd	e0 47			cpx #$47			CPX	#Ibuffe-Ibuffs	; compare character count with max
.b2bf	b0 0c			bcs $b2cd			BCS	LAB_138E		; skip store and do [BELL] if buffer full
.b2c1	9d 21 02		sta $0221,x			STA	Ibuffs,X		; else store in buffer
.b2c4	e8				inx					INX				; increment pointer
.b2c5									LAB_137F
.b2c5	20 36 b9		jsr $b936			JSR	LAB_PRNA		; go print the character
.b2c8	d0 d8			bne $b2a2			BNE	LAB_1359		; always loop for next character
.b2ca									LAB_1384
.b2ca	4c d7 b8		jmp $b8d7			JMP	LAB_1866		; do CR/LF exit to BASIC
.b2cd									LAB_138E
.b2cd	a9 07			lda #$07			LDA	#$07			; [BELL] character into A
.b2cf	d0 f4			bne $b2c5			BNE	LAB_137F		; go print the [BELL] but ignore input character
.b2d1									LAB_13A6
.b2d1	a0 ff			ldy #$ff			LDY	#$FF			; set save index (makes for easy math later)
.b2d3	38				sec					SEC				; set carry for subtract
.b2d4	a5 77			lda $77				LDA	Bpntrl		; get basic execute pointer low byte
.b2d6	e9 21			sbc #$21			SBC	#<Ibuffs		; subtract input buffer start pointer
.b2d8	aa				tax					TAX				; copy result to X (index past line # if any)
.b2d9	86 12			stx $12				STX	Oquote		; clear open quote/DATA flag
.b2db									LAB_13AC
.b2db	bd 21 02		lda $0221,x			LDA	Ibuffs,X		; get byte from input buffer
.b2de	f0 51			beq $b331			BEQ	LAB_13EC		; if null save byte then exit
.b2e0	c9 5f			cmp #$5f			CMP	#'_'			; compare with "_"
.b2e2	b0 4d			bcs $b331			BCS	LAB_13EC		; if >= go save byte then continue crunching
.b2e4	c9 3c			cmp #$3c			CMP	#'<'			; compare with "<"
.b2e6	b0 0e			bcs $b2f6			BCS	LAB_13CC		; if >= go crunch now
.b2e8	c9 30			cmp #$30			CMP	#'0'			; compare with "0"
.b2ea	b0 45			bcs $b331			BCS	LAB_13EC		; if >= go save byte then continue crunching
.b2ec	85 0e			sta $0e				STA	Scnquo		; save buffer byte as search character
.b2ee	c9 22			cmp #$22			CMP	#$22			; is it quote character?
.b2f0	f0 61			beq $b353			BEQ	LAB_1410		; branch if so (copy quoted string)
.b2f2	c9 2a			cmp #$2a			CMP	#'*'			; compare with "*"
.b2f4	90 3b			bcc $b331			BCC	LAB_13EC		; if < go save byte then continue crunching
.b2f6									LAB_13CC
.b2f6	24 12			bit $12				BIT	Oquote		; get open quote/DATA token flag
.b2f8	70 37			bvs $b331			BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
.b2fa	86 2c			stx $2c				STX	TempB			; save buffer read index
.b2fc	84 6e			sty $6e				STY	csidx			; copy buffer save index
.b2fe	a0 6a			ldy #$6a			LDY	#<TAB_1STC		; get keyword first character table low address
.b300	84 27			sty $27				STY	ut2_pl		; save pointer low byte
.b302	a0 d3			ldy #$d3			LDY	#>TAB_1STC		; get keyword first character table high address
.b304	84 28			sty $28				STY	ut2_ph		; save pointer high byte
.b306	a0 00			ldy #$00			LDY	#$00			; clear table pointer
.b308									LAB_13D0
.b308	d1 27			cmp ($27),y			CMP	(ut2_pl),Y		; compare with keyword first character table byte
.b30a	f0 05			beq $b311			BEQ	LAB_13D1		; go do word_table_chr if match
.b30c	90 21			bcc $b32f			BCC	LAB_13EA		; if < keyword first character table byte go restore
.b30e	c8				iny					INY				; else increment pointer
.b30f	d0 f7			bne $b308			BNE	LAB_13D0		; and loop (branch always)
.b311									LAB_13D1
.b311	98				tya					TYA				; copy matching index
.b312	0a				asl a				ASL				; *2 (bytes per pointer)
.b313	aa				tax					TAX				; copy to new index
.b314	bd 88 d3		lda $d388,x			LDA	TAB_CHRT,X		; get keyword table pointer low byte
.b317	85 27			sta $27				STA	ut2_pl		; save pointer low byte
.b319	bd 89 d3		lda $d389,x			LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
.b31c	85 28			sta $28				STA	ut2_ph		; save pointer high byte
.b31e	a0 ff			ldy #$ff			LDY	#$FF			; clear table pointer (make -1 for start)
.b320	a6 2c			ldx $2c				LDX	TempB			; restore buffer read index
.b322									LAB_13D6
.b322	c8				iny					INY				; next table byte
.b323	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get byte from table
.b325									LAB_13D8
.b325	30 08			bmi $b32f			BMI	LAB_13EA		; all bytes matched so go save token
.b327	e8				inx					INX				; next buffer byte
.b328	dd 21 02		cmp $0221,x			CMP	Ibuffs,X		; compare with byte from input buffer
.b32b	f0 f5			beq $b322			BEQ	LAB_13D6		; go compare next if match
.b32d	d0 2b			bne $b35a			BNE	LAB_1417		; branch if >< (not found keyword)
.b32f									LAB_13EA
.b32f	a4 6e			ldy $6e				LDY	csidx			; restore save index
.b331									LAB_13EC
.b331	e8				inx					INX				; increment buffer index (to next input byte)
.b332	c8				iny					INY				; increment save index (to next output byte)
.b333	99 21 02		sta $0221,y			STA	Ibuffs,Y		; save byte to output
.b336	c9 00			cmp #$00			CMP	#$00			; set the flags, set carry
.b338	f0 32			beq $b36c			BEQ	LAB_142A		; do exit if was null [EOL]
.b33a	e9 3a			sbc #$3a			SBC	#':'			; subtract ":" (carry set by CMP #00)
.b33c	f0 04			beq $b342			BEQ	LAB_13FF		; branch if it was ":" (is now $00)
.b33e	c9 49			cmp #$49			CMP	#TK_DATA-$3A	; compare with DATA token - $3A
.b340	d0 02			bne $b344			BNE	LAB_1401		; branch if not DATA
.b342									LAB_13FF
.b342	85 12			sta $12				STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
.b344									LAB_1401
.b344	49 57			eor #$57			EOR	#TK_REM-$3A		; effectively subtract REM token offset
.b346	d0 93			bne $b2db			BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
.b348	85 0e			sta $0e				STA	Asrch			; else was REM so set search for [EOL]
.b34a									LAB_1408
.b34a	bd 21 02		lda $0221,x			LDA	Ibuffs,X		; get byte from input buffer
.b34d	f0 e2			beq $b331			BEQ	LAB_13EC		; branch if null [EOL]
.b34f	c5 0e			cmp $0e				CMP	Asrch			; compare with stored character
.b351	f0 de			beq $b331			BEQ	LAB_13EC		; branch if match (end quote)
.b353									LAB_1410
.b353	c8				iny					INY				; increment buffer save index
.b354	99 21 02		sta $0221,y			STA	Ibuffs,Y		; save byte to output
.b357	e8				inx					INX				; increment buffer read index
.b358	d0 f0			bne $b34a			BNE	LAB_1408		; loop while <> 0 (should never be 0!)
.b35a									LAB_1417
.b35a	a6 2c			ldx $2c				LDX	TempB			; compare has failed, restore buffer index (start byte!)
.b35c									LAB_141B
.b35c	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get table byte
.b35e	08				php					PHP				; save status
.b35f	c8				iny					INY				; increment table index
.b360	28				plp					PLP				; restore byte status
.b361	10 f9			bpl $b35c			BPL	LAB_141B		; if not end of keyword go do next
.b363	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get byte from keyword table
.b365	d0 be			bne $b325			BNE	LAB_13D8		; go test next word if not zero byte (end of table)
.b367	bd 21 02		lda $0221,x			LDA	Ibuffs,X		; restore byte from input buffer
.b36a	10 c3			bpl $b32f			BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
.b36c									LAB_142A
.b36c	c8				iny					INY				; increment pointer
.b36d	c8				iny					INY				; increment pointer (makes it next line pointer high byte)
.b36e	99 21 02		sta $0221,y			STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
.b371	c8				iny					INY				; adjust for line copy
.b372	c8				iny					INY				; adjust for line copy
.b373	c8				iny					INY				; adjust for line copy
.b374	c6 77			dec $77				DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
.b376	60				rts					RTS
.b377									LAB_SSLN
.b377	a5 2d			lda $2d				LDA	Smeml			; get start of mem low byte
.b379	a6 2e			ldx $2e				LDX	Smemh			; get start of mem high byte
.b37b									LAB_SHLN
.b37b	a0 01			ldy #$01			LDY	#$01			; set index
.b37d	85 5e			sta $5e				STA	Baslnl		; save low byte as current
.b37f	86 5f			stx $5f				STX	Baslnh		; save high byte as current
.b381	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get pointer high byte from addr
.b383	f0 1a			beq $b39f			BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
.b385	a0 03			ldy #$03			LDY	#$03			; set index to line # high byte
.b387	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get line # high byte
.b389	88				dey					DEY				; decrement index (point to low byte)
.b38a	c5 0b			cmp $0b				CMP	Itemph		; compare with temporary integer high byte
.b38c	d0 04			bne $b392			BNE	LAB_1455		; if <> skip low byte check
.b38e	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get line # low byte
.b390	c5 0a			cmp $0a				CMP	Itempl		; compare with temporary integer low byte
.b392									LAB_1455
.b392	b0 09			bcs $b39d			BCS	LAB_145E		; else if temp < this line, exit (passed line#)
.b394									LAB_1456
.b394	88				dey					DEY				; decrement index to next line ptr high byte
.b395	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get next line pointer high byte
.b397	aa				tax					TAX				; copy to X
.b398	88				dey					DEY				; decrement index to next line ptr low byte
.b399	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get next line pointer low byte
.b39b	90 de			bcc $b37b			BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
.b39d									LAB_145E
.b39d	f0 01			beq $b3a0			BEQ	LAB_1460		; exit if temp = found line #, carry is set
.b39f									LAB_145F
.b39f	18				clc					CLC				; clear found flag
.b3a0									LAB_1460
.b3a0	60				rts					RTS
.b3a1									LAB_NEW
.b3a1	d0 fd			bne $b3a0			BNE	LAB_1460		; exit if not end of statement (to do syntax error)
.b3a3									LAB_1463
.b3a3	a9 00			lda #$00			LDA	#$00			; clear A
.b3a5	a8				tay					TAY				; clear Y
.b3a6	91 2d			sta ($2d),y			STA	(Smeml),Y		; clear first line, next line pointer, low byte
.b3a8	c8				iny					INY				; increment index
.b3a9	91 2d			sta ($2d),y			STA	(Smeml),Y		; clear first line, next line pointer, high byte
.b3ab	18				clc					CLC				; clear carry
.b3ac	a5 2d			lda $2d				LDA	Smeml			; get start of mem low byte
.b3ae	69 02			adc #$02			ADC	#$02			; calculate end of BASIC low byte
.b3b0	85 2f			sta $2f				STA	Svarl			; save start of vars low byte
.b3b2	a5 2e			lda $2e				LDA	Smemh			; get start of mem high byte
.b3b4	69 00			adc #$00			ADC	#$00			; add any carry
.b3b6	85 30			sta $30				STA	Svarh			; save start of vars high byte
.b3b8									LAB_1477
.b3b8	18				clc					CLC				; clear carry
.b3b9	a5 2d			lda $2d				LDA	Smeml			; get start of mem low byte
.b3bb	69 ff			adc #$ff			ADC	#$FF			; -1
.b3bd	85 77			sta $77				STA	Bpntrl		; save BASIC execute pointer low byte
.b3bf	a5 2e			lda $2e				LDA	Smemh			; get start of mem high byte
.b3c1	69 ff			adc #$ff			ADC	#$FF			; -1+carry
.b3c3	85 78			sta $78				STA	Bpntrh		; save BASIC execute pointer high byte
.b3c5									LAB_147A
.b3c5	a5 39			lda $39				LDA	Ememl			; get end of mem low byte
.b3c7	a4 3a			ldy $3a				LDY	Ememh			; get end of mem high byte
.b3c9	85 35			sta $35				STA	Sstorl		; set bottom of string space low byte
.b3cb	84 36			sty $36				STY	Sstorh		; set bottom of string space high byte
.b3cd	a5 2f			lda $2f				LDA	Svarl			; get start of vars low byte
.b3cf	a4 30			ldy $30				LDY	Svarh			; get start of vars high byte
.b3d1	85 31			sta $31				STA	Sarryl		; save var mem end low byte
.b3d3	84 32			sty $32				STY	Sarryh		; save var mem end high byte
.b3d5	85 33			sta $33				STA	Earryl		; save array mem end low byte
.b3d7	84 34			sty $34				STY	Earryh		; save array mem end high byte
.b3d9	20 8d b5		jsr $b58d			JSR	LAB_161A		; perform RESTORE command
.b3dc									LAB_1491
.b3dc	a2 1b			ldx #$1b			LDX	#des_sk		; set descriptor stack pointer
.b3de	86 18			stx $18				STX	next_s		; save descriptor stack pointer
.b3e0	68				pla					PLA				; pull return address low byte
.b3e1	aa				tax					TAX				; copy return address low byte
.b3e2	68				pla					PLA				; pull return address high byte
.b3e3	8e fe 01		stx $01fe			STX	LAB_SKFE		; save to cleared stack
.b3e6	8d ff 01		sta $01ff			STA	LAB_SKFF		; save to cleared stack
.b3e9	a2 fd			ldx #$fd			LDX	#$FD			; new stack pointer
.b3eb	9a				txs					TXS				; reset stack
.b3ec	a9 00			lda #$00			LDA	#$00			; clear byte
.b3ee	85 14			sta $14				STA	Sufnxf		; clear subscript/FNX flag
.b3f0									LAB_14A6
.b3f0	60				rts					RTS
.b3f1									LAB_CLEAR
.b3f1	f0 d2			beq $b3c5			BEQ	LAB_147A		; if no following token go do "CLEAR"
.b3f3	60				rts					RTS
.b3f4									LAB_LIST
.b3f4	90 06			bcc $b3fc			BCC	LAB_14BD		; branch if next character numeric (LIST n..)
.b3f6	f0 04			beq $b3fc			BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
.b3f8	c9 b8			cmp #$b8			CMP	#TK_MINUS		; compare with token for -
.b3fa	d0 f4			bne $b3f0			BNE	LAB_14A6		; exit if not - (LIST -m)
.b3fc									LAB_14BD
.b3fc	20 a3 b7		jsr $b7a3			JSR	LAB_GFPN		; get fixed-point number into temp integer
.b3ff	20 77 b3		jsr $b377			JSR	LAB_SSLN		; search BASIC for temp integer line number
.b402	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b405	f0 0c			beq $b413			BEQ	LAB_14D4		; branch if no more characters
.b407	c9 b8			cmp #$b8			CMP	#TK_MINUS		; compare with token for -
.b409	d0 95			bne $b3a0			BNE	LAB_1460		; return if not "-" (will be Syntax error)
.b40b	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.b40e	20 a3 b7		jsr $b7a3			JSR	LAB_GFPN		; get fixed-point number into temp integer
.b411	d0 8d			bne $b3a0			BNE	LAB_1460		; exit if not ok
.b413									LAB_14D4
.b413	a5 0a			lda $0a				LDA	Itempl		; get temporary integer low byte
.b415	05 0b			ora $0b				ORA	Itemph		; OR temporary integer high byte
.b417	d0 06			bne $b41f			BNE	LAB_14E2		; branch if start set
.b419	a9 ff			lda #$ff			LDA	#$FF			; set for -1
.b41b	85 0a			sta $0a				STA	Itempl		; set temporary integer low byte
.b41d	85 0b			sta $0b				STA	Itemph		; set temporary integer high byte
.b41f									LAB_14E2
.b41f	a0 01			ldy #$01			LDY	#$01			; set index for line
.b421	84 12			sty $12				STY	Oquote		; clear open quote flag
.b423	20 e0 b8		jsr $b8e0			JSR	LAB_CRLF		; print CR/LF
.b426	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get next line pointer high byte
.b428	f0 3e			beq $b468			BEQ	LAB_152B		; if null all done so exit
.b42a	20 63 b5		jsr $b563			JSR	LAB_1629		; do CRTL-C check vector
.b42d	c8				iny					INY				; increment index for line
.b42e	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get line # low byte
.b430	aa				tax					TAX				; copy to X
.b431	c8				iny					INY				; increment index
.b432	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get line # high byte
.b434	c5 0b			cmp $0b				CMP	Itemph		; compare with temporary integer high byte
.b436	d0 04			bne $b43c			BNE	LAB_14FF		; branch if no high byte match
.b438	e4 0a			cpx $0a				CPX	Itempl		; compare with temporary integer low byte
.b43a	f0 02			beq $b43e			BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
.b43c									LAB_14FF
.b43c	b0 2a			bcs $b468			BCS	LAB_152B		; if greater all done so exit
.b43e									LAB_1501
.b43e	84 4b			sty $4b				STY	Tidx1			; save index for line
.b440	20 dc ca		jsr $cadc			JSR	LAB_295E		; print XA as unsigned integer
.b443	a9 20			lda #$20			LDA	#$20			; space is the next character
.b445									LAB_1508
.b445	a4 4b			ldy $4b				LDY	Tidx1			; get index for line
.b447	29 7f			and #$7f			AND	#$7F			; mask top out bit of character
.b449									LAB_150C
.b449	20 36 b9		jsr $b936			JSR	LAB_PRNA		; go print the character
.b44c	c9 22			cmp #$22			CMP	#$22			; was it " character
.b44e	d0 06			bne $b456			BNE	LAB_1519		; branch if not
.b450	a5 12			lda $12				LDA	Oquote		; get open quote flag
.b452	49 ff			eor #$ff			EOR	#$FF			; toggle it
.b454	85 12			sta $12				STA	Oquote		; save it back
.b456									LAB_1519
.b456	c8				iny					INY				; increment index
.b457	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get next byte
.b459	d0 0e			bne $b469			BNE	LAB_152E		; branch if not [EOL] (go print character)
.b45b	a8				tay					TAY				; else clear index
.b45c	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get next line pointer low byte
.b45e	aa				tax					TAX				; copy to X
.b45f	c8				iny					INY				; increment index
.b460	b1 5e			lda ($5e),y			LDA	(Baslnl),Y		; get next line pointer high byte
.b462	86 5e			stx $5e				STX	Baslnl		; set pointer to line low byte
.b464	85 5f			sta $5f				STA	Baslnh		; set pointer to line high byte
.b466	d0 b7			bne $b41f			BNE	LAB_14E2		; go do next line if not [EOT]
.b468									LAB_152B
.b468	60				rts					RTS
.b469									LAB_152E
.b469	10 de			bpl $b449			BPL	LAB_150C		; just go print it if not token byte
.b46b	24 12			bit $12				BIT	Oquote		; test the open quote flag
.b46d	30 da			bmi $b449			BMI	LAB_150C		; just go print character if open quote set
.b46f	a2 d5			ldx #$d5			LDX	#>LAB_KEYT		; get table address high byte
.b471	0a				asl a				ASL				; *2
.b472	0a				asl a				ASL				; *4
.b473	90 02			bcc $b477			BCC	LAB_152F		; branch if no carry
.b475	e8				inx					INX				; else increment high byte
.b476	18				clc					CLC				; clear carry for add
.b477									LAB_152F
.b477	69 6f			adc #$6f			ADC	#<LAB_KEYT		; add low byte
.b479	90 01			bcc $b47c			BCC	LAB_1530		; branch if no carry
.b47b	e8				inx					INX				; else increment high byte
.b47c									LAB_1530
.b47c	85 27			sta $27				STA	ut2_pl		; save table pointer low byte
.b47e	86 28			stx $28				STX	ut2_ph		; save table pointer high byte
.b480	84 4b			sty $4b				STY	Tidx1			; save index for line
.b482	a0 00			ldy #$00			LDY	#$00			; clear index
.b484	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get length
.b486	aa				tax					TAX				; copy length
.b487	c8				iny					INY				; increment index
.b488	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get 1st character
.b48a	ca				dex					DEX				; decrement length
.b48b	f0 b8			beq $b445			BEQ	LAB_1508		; if no more characters exit and print
.b48d	20 36 b9		jsr $b936			JSR	LAB_PRNA		; go print the character
.b490	c8				iny					INY				; increment index
.b491	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get keyword address low byte
.b493	48				pha					PHA				; save it for now
.b494	c8				iny					INY				; increment index
.b495	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get keyword address high byte
.b497	a0 00			ldy #$00			LDY	#$00
.b499	85 28			sta $28				STA	ut2_ph		; save keyword pointer high byte
.b49b	68				pla					PLA				; pull low byte
.b49c	85 27			sta $27				STA	ut2_pl		; save keyword pointer low byte
.b49e									LAB_1540
.b49e	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get character
.b4a0	ca				dex					DEX				; decrement character count
.b4a1	f0 a2			beq $b445			BEQ	LAB_1508		; if last character exit and print
.b4a3	20 36 b9		jsr $b936			JSR	LAB_PRNA		; go print the character
.b4a6	c8				iny					INY				; increment index
.b4a7	d0 f5			bne $b49e			BNE	LAB_1540		; loop for next character
.b4a9									LAB_FOR
.b4a9	a9 80			lda #$80			LDA	#$80			; set FNX
.b4ab	85 14			sta $14				STA	Sufnxf		; set subscript/FNX flag
.b4ad	20 02 b8		jsr $b802			JSR	LAB_LET		; go do LET
.b4b0	68				pla					PLA				; pull return address
.b4b1	68				pla					PLA				; pull return address
.b4b2	a9 10			lda #$10			LDA	#$10			; we need 16d bytes !
.b4b4	20 56 b1		jsr $b156			JSR	LAB_1212		; check room on stack for A bytes
.b4b7	20 e8 b6		jsr $b6e8			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.b4ba	18				clc					CLC				; clear carry for add
.b4bb	98				tya					TYA				; copy index to A
.b4bc	65 77			adc $77				ADC	Bpntrl		; add BASIC execute pointer low byte
.b4be	48				pha					PHA				; push onto stack
.b4bf	a5 78			lda $78				LDA	Bpntrh		; get BASIC execute pointer high byte
.b4c1	69 00			adc #$00			ADC	#$00			; add carry
.b4c3	48				pha					PHA				; push onto stack
.b4c4	a5 3c			lda $3c				LDA	Clineh		; get current line high byte
.b4c6	48				pha					PHA				; push onto stack
.b4c7	a5 3b			lda $3b				LDA	Clinel		; get current line low byte
.b4c9	48				pha					PHA				; push onto stack
.b4ca	a9 ae			lda #$ae			LDA	#TK_TO		; get "TO" token
.b4cc	20 39 bc		jsr $bc39			JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
.b4cf	20 18 bb		jsr $bb18			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.b4d2	20 15 bb		jsr $bb15			JSR	LAB_EVNM		; evaluate expression and check is numeric,
.b4d5	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.b4d7	09 7f			ora #$7f			ORA	#$7F			; set all non sign bits
.b4d9	25 61			and $61				AND	FAC1_1		; and FAC1 mantissa1
.b4db	85 61			sta $61				STA	FAC1_1		; save FAC1 mantissa1
.b4dd	a9 e8			lda #$e8			LDA	#<LAB_159F		; set return address low byte
.b4df	a0 b4			ldy #$b4			LDY	#>LAB_159F		; set return address high byte
.b4e1	85 25			sta $25				STA	ut1_pl		; save return address low byte
.b4e3	84 26			sty $26				STY	ut1_ph		; save return address high byte
.b4e5	4c cc bb		jmp $bbcc			JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
.b4e8									LAB_159F
.b4e8	a9 38			lda #$38			LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
.b4ea	a0 d2			ldy #$d2			LDY	#>LAB_259C		; set 1 pointer high addr
.b4ec	20 d7 c8		jsr $c8d7			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.b4ef	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b4f2	c9 b3			cmp #$b3			CMP	#TK_STEP		; compare with STEP token
.b4f4	d0 06			bne $b4fc			BNE	LAB_15B3		; jump if not "STEP"
.b4f6	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.b4f9	20 15 bb		jsr $bb15			JSR	LAB_EVNM		; evaluate expression and check is numeric,
.b4fc									LAB_15B3
.b4fc	20 43 c9		jsr $c943			JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
.b4ff	85 64			sta $64				STA	FAC1_s		; set FAC1 sign (b7)
.b501	20 c1 bb		jsr $bbc1			JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
.b504	a5 4c			lda $4c				LDA	Frnxth		; get var pointer for FOR/NEXT high byte
.b506	48				pha					PHA				; push on stack
.b507	a5 4b			lda $4b				LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
.b509	48				pha					PHA				; push on stack
.b50a	a9 81			lda #$81			LDA	#TK_FOR		; get FOR token
.b50c	48				pha					PHA				; push on stack
.b50d									LAB_15C2
.b50d	20 63 b5		jsr $b563			JSR	LAB_1629		; do CRTL-C check vector
.b510	a5 77			lda $77				LDA	Bpntrl		; get BASIC execute pointer low byte
.b512	a4 78			ldy $78				LDY	Bpntrh		; get BASIC execute pointer high byte
.b514	a6 3c			ldx $3c				LDX	Clineh		; continue line is $FFxx for immediate mode
.b516	e8				inx					INX				; increment it (now $00 if immediate mode)
.b517	85 3f			sta $3f				STA	Cpntrl		; save continue pointer low byte
.b519	84 40			sty $40				STY	Cpntrh		; save continue pointer high byte
.b51b									LAB_15D1
.b51b	a0 00			ldy #$00			LDY	#$00			; clear index
.b51d	b1 77			lda ($77),y			LDA	(Bpntrl),Y		; get next byte
.b51f	f0 07			beq $b528			BEQ	LAB_15DC		; branch if null [EOL]
.b521	c9 3a			cmp #$3a			CMP	#':'			; compare with ":"
.b523	f0 1d			beq $b542			BEQ	LAB_15F6		; branch if = (statement separator)
.b525									LAB_15D9
.b525	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; else syntax error then warm start
.b528									LAB_15DC
.b528	a0 02			ldy #$02			LDY	#$02			; set index
.b52a	b1 77			lda ($77),y			LDA	(Bpntrl),Y		; get next line pointer high byte
.b52c	18				clc					CLC				; clear carry for no "BREAK" message
.b52d	f0 50			beq $b57f			BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
.b52f	c8				iny					INY				; increment index
.b530	b1 77			lda ($77),y			LDA	(Bpntrl),Y		; get line # low byte
.b532	85 3b			sta $3b				STA	Clinel		; save current line low byte
.b534	c8				iny					INY				; increment index
.b535	b1 77			lda ($77),y			LDA	(Bpntrl),Y		; get line # high byte
.b537	85 3c			sta $3c				STA	Clineh		; save current line high byte
.b539	98				tya					TYA				; A now = 4
.b53a	65 77			adc $77				ADC	Bpntrl		; add BASIC execute pointer low byte
.b53c	85 77			sta $77				STA	Bpntrl		; save BASIC execute pointer low byte
.b53e	90 02			bcc $b542			BCC	LAB_15F6		; branch if no overflow
.b540	e6 78			inc $78				INC	Bpntrh		; else increment BASIC execute pointer high byte
.b542									LAB_15F6
.b542	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.b545									LAB_15F9
.b545	20 4b b5		jsr $b54b			JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
.b548									LAB_15FC
.b548	4c 0d b5		jmp $b50d			JMP	LAB_15C2		; loop
.b54b									LAB_15FF
.b54b	f0 4e			beq $b59b			BEQ	LAB_1628		; exit if zero [EOL]
.b54d									LAB_1602
.b54d	0a				asl a				ASL				; *2 bytes per vector and normalise token
.b54e	b0 03			bcs $b553			BCS	LAB_1609		; branch if was token
.b550	4c 02 b8		jmp $b802			JMP	LAB_LET		; else go do implied LET
.b553									LAB_1609
.b553	c9 58			cmp #$58			CMP	#(TK_TAB-$80)*2	; compare normalised token * 2 with TAB
.b555	b0 ce			bcs $b525			BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
.b557	a8				tay					TAY				; copy to index
.b558	b9 60 d2		lda $d260,y			LDA	LAB_CTBL+1,Y	; get vector high byte
.b55b	48				pha					PHA				; onto stack
.b55c	b9 5f d2		lda $d25f,y			LDA	LAB_CTBL,Y		; get vector low byte
.b55f	48				pha					PHA				; onto stack
.b560	4c 70 00		jmp $0070			JMP	LAB_IGBY		; jump to increment and scan memory
.b563									LAB_1629
.b563	6c 03 02		jmp ($0203)			JMP	(VEC_CC)		; ctrl c check vector
.b566									LAB_1636
.b566	c9 03			cmp #$03			CMP	#$03			; compare with CTRL-C
.b568									LAB_STOP
.b568	b0 01			bcs $b56b			BCS	LAB_163B		; branch if token follows STOP
.b56a									LAB_END
.b56a	18				clc					CLC				; clear the carry, indicate a normal program end
.b56b									LAB_163B
.b56b	d0 61			bne $b5ce			BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
.b56d	a5 78			lda $78				LDA	Bpntrh		; get the BASIC execute pointer high byte
.b56f	a4 77			ldy $77				LDY	Bpntrl		; get BASIC execute pointer low byte
.b571	84 3f			sty $3f				STY	Cpntrl		; save continue pointer low byte
.b573	85 40			sta $40				STA	Cpntrh		; save continue pointer high byte
.b575									LAB_1647
.b575	a5 3b			lda $3b				LDA	Clinel		; get current line low byte
.b577	a4 3c			ldy $3c				LDY	Clineh		; get current line high byte
.b579	85 3d			sta $3d				STA	Blinel		; save break line low byte
.b57b	84 3e			sty $3e				STY	Blineh		; save break line high byte
.b57d									LAB_164F
.b57d	68				pla					PLA				; pull return address low
.b57e	68				pla					PLA				; pull return address high
.b57f									LAB_1651
.b57f	90 07			bcc $b588			BCC	LAB_165E		; if was program end just do warm start
.b581	a9 40			lda #$40			LDA	#<LAB_BMSG		; point to "Break" low byte
.b583	a0 d8			ldy #$d8			LDY	#>LAB_BMSG		; point to "Break" high byte
.b585	4c a2 b1		jmp $b1a2			JMP	LAB_1269		; print "Break" and do warm start
.b588									LAB_165E
.b588	4c ad b1		jmp $b1ad			JMP	LAB_1274		; go do warm start
.b58b									LAB_RESTORE
.b58b	d0 0f			bne $b59c			BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
.b58d									LAB_161A
.b58d	38				sec					SEC				; set carry for subtract
.b58e	a5 2d			lda $2d				LDA	Smeml			; get start of mem low byte
.b590	e9 01			sbc #$01			SBC	#$01			; -1
.b592	a4 2e			ldy $2e				LDY	Smemh			; get start of mem high byte
.b594	b0 01			bcs $b597			BCS	LAB_1624		; branch if no underflow
.b596									LAB_uflow
.b596	88				dey					DEY				; else decrement high byte
.b597									LAB_1624
.b597	85 43			sta $43				STA	Dptrl			; save DATA pointer low byte
.b599	84 44			sty $44				STY	Dptrh			; save DATA pointer high byte
.b59b									LAB_1628
.b59b	60				rts					RTS
.b59c									LAB_RESTOREn
.b59c	20 a3 b7		jsr $b7a3			JSR	LAB_GFPN		; get fixed-point number into temp integer
.b59f	20 eb b6		jsr $b6eb			JSR	LAB_SNBL		; scan for next BASIC line
.b5a2	a5 3c			lda $3c				LDA	Clineh		; get current line high byte
.b5a4	c5 0b			cmp $0b				CMP	Itemph		; compare with temporary integer high byte
.b5a6	b0 0b			bcs $b5b3			BCS	LAB_reset_search	; branch if >= (start search from beginning)
.b5a8	98				tya					TYA				; else copy line index to A
.b5a9	38				sec					SEC				; set carry (+1)
.b5aa	65 77			adc $77				ADC	Bpntrl		; add BASIC execute pointer low byte
.b5ac	a6 78			ldx $78				LDX	Bpntrh		; get BASIC execute pointer high byte
.b5ae	90 07			bcc $b5b7			BCC	LAB_go_search	; branch if no overflow to high byte
.b5b0	e8				inx					INX				; increment high byte
.b5b1	b0 04			bcs $b5b7			BCS	LAB_go_search	; branch always (can never be carry clear)
.b5b3									LAB_reset_search
.b5b3	a5 2d			lda $2d				LDA	Smeml			; get start of mem low byte
.b5b5	a6 2e			ldx $2e				LDX	Smemh			; get start of mem high byte
.b5b7									LAB_go_search
.b5b7	20 7b b3		jsr $b37b			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.b5ba	b0 03			bcs $b5bf			BCS	LAB_line_found	; if carry set go set pointer
.b5bc	4c bd b6		jmp $b6bd			JMP	LAB_16F7		; else go do "Undefined statement" error
.b5bf									LAB_line_found
.b5bf	a5 5e			lda $5e				LDA	Baslnl		; get pointer low byte
.b5c1	e9 01			sbc #$01			SBC	#$01			; -1
.b5c3	a4 5f			ldy $5f				LDY	Baslnh		; get pointer high byte
.b5c5	b0 d0			bcs $b597			BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
.b5c7	90 cd			bcc $b596			BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
.b5c9									LAB_NULL
.b5c9	20 e6 c4		jsr $c4e6			JSR	LAB_GTBY		; get byte parameter
.b5cc	86 06			stx $06				STX	Nullct		; save new NULL count
.b5ce									LAB_167A
.b5ce	60				rts					RTS
.b5cf									LAB_CONT
.b5cf	d0 fd			bne $b5ce			BNE	LAB_167A		; if following byte exit to do syntax error
.b5d1	a4 40			ldy $40				LDY	Cpntrh		; get continue pointer high byte
.b5d3	c0 02			cpy #$02			CPY #>Ibuffs
.b5d5	d0 05			bne $b5dc			BNE	LAB_166C		; go do continue if we can
.b5d7	a2 1e			ldx #$1e			LDX	#$1E			; error code $1E ("Can't continue" error)
.b5d9	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; do error #X, then warm start
.b5dc									LAB_166C
.b5dc	a9 93			lda #$93			LDA	#TK_ON		; set token for ON
.b5de	20 6e cf		jsr $cf6e			JSR	LAB_IRQ		; set IRQ flags
.b5e1	a9 93			lda #$93			LDA	#TK_ON		; set token for ON
.b5e3	20 71 cf		jsr $cf71			JSR	LAB_NMI		; set NMI flags
.b5e6	84 78			sty $78				STY	Bpntrh		; save BASIC execute pointer high byte
.b5e8	a5 3f			lda $3f				LDA	Cpntrl		; get continue pointer low byte
.b5ea	85 77			sta $77				STA	Bpntrl		; save BASIC execute pointer low byte
.b5ec	a5 3d			lda $3d				LDA	Blinel		; get break line low byte
.b5ee	a4 3e			ldy $3e				LDY	Blineh		; get break line high byte
.b5f0	85 3b			sta $3b				STA	Clinel		; set current line low byte
.b5f2	84 3c			sty $3c				STY	Clineh		; set current line high byte
.b5f4	60				rts					RTS
.b5f5									LAB_RUN
.b5f5	d0 03			bne $b5fa			BNE	LAB_1696		; branch if RUN n
.b5f7	4c b8 b3		jmp $b3b8			JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
.b5fa									LAB_1696
.b5fa	20 c5 b3		jsr $b3c5			JSR	LAB_147A		; go do "CLEAR"
.b5fd	f0 2e			beq $b62d			BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
.b5ff									LAB_DO
.b5ff	a9 05			lda #$05			LDA	#$05			; need 5 bytes for DO
.b601	20 56 b1		jsr $b156			JSR	LAB_1212		; check room on stack for A bytes
.b604	a5 78			lda $78				LDA	Bpntrh		; get BASIC execute pointer high byte
.b606	48				pha					PHA				; push on stack
.b607	a5 77			lda $77				LDA	Bpntrl		; get BASIC execute pointer low byte
.b609	48				pha					PHA				; push on stack
.b60a	a5 3c			lda $3c				LDA	Clineh		; get current line high byte
.b60c	48				pha					PHA				; push on stack
.b60d	a5 3b			lda $3b				LDA	Clinel		; get current line low byte
.b60f	48				pha					PHA				; push on stack
.b610	a9 9d			lda #$9d			LDA	#TK_DO		; token for DO
.b612	48				pha					PHA				; push on stack
.b613	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b616	4c 0d b5		jmp $b50d			JMP	LAB_15C2		; go do interpreter inner loop
.b619									LAB_GOSUB
.b619	a9 05			lda #$05			LDA	#$05			; need 5 bytes for GOSUB
.b61b	20 56 b1		jsr $b156			JSR	LAB_1212		; check room on stack for A bytes
.b61e	a5 78			lda $78				LDA	Bpntrh		; get BASIC execute pointer high byte
.b620	48				pha					PHA				; push on stack
.b621	a5 77			lda $77				LDA	Bpntrl		; get BASIC execute pointer low byte
.b623	48				pha					PHA				; push on stack
.b624	a5 3c			lda $3c				LDA	Clineh		; get current line high byte
.b626	48				pha					PHA				; push on stack
.b627	a5 3b			lda $3b				LDA	Clinel		; get current line low byte
.b629	48				pha					PHA				; push on stack
.b62a	a9 8d			lda #$8d			LDA	#TK_GOSUB		; token for GOSUB
.b62c	48				pha					PHA				; push on stack
.b62d									LAB_16B0
.b62d	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b630	20 36 b6		jsr $b636			JSR	LAB_GOTO		; perform GOTO n
.b633	4c 0d b5		jmp $b50d			JMP	LAB_15C2		; go do interpreter inner loop
.b636									LAB_GOTO
.b636	20 a3 b7		jsr $b7a3			JSR	LAB_GFPN		; get fixed-point number into temp integer
.b639	20 eb b6		jsr $b6eb			JSR	LAB_SNBL		; scan for next BASIC line
.b63c	a5 3c			lda $3c				LDA	Clineh		; get current line high byte
.b63e	c5 0b			cmp $0b				CMP	Itemph		; compare with temporary integer high byte
.b640	b0 0b			bcs $b64d			BCS	LAB_16D0		; branch if >= (start search from beginning)
.b642	98				tya					TYA				; else copy line index to A
.b643	38				sec					SEC				; set carry (+1)
.b644	65 77			adc $77				ADC	Bpntrl		; add BASIC execute pointer low byte
.b646	a6 78			ldx $78				LDX	Bpntrh		; get BASIC execute pointer high byte
.b648	90 07			bcc $b651			BCC	LAB_16D4		; branch if no overflow to high byte
.b64a	e8				inx					INX				; increment high byte
.b64b	b0 04			bcs $b651			BCS	LAB_16D4		; branch always (can never be carry)
.b64d									LAB_16D0
.b64d	a5 2d			lda $2d				LDA	Smeml			; get start of mem low byte
.b64f	a6 2e			ldx $2e				LDX	Smemh			; get start of mem high byte
.b651									LAB_16D4
.b651	20 7b b3		jsr $b37b			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.b654	90 67			bcc $b6bd			BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
.b656	a5 5e			lda $5e				LDA	Baslnl		; get pointer low byte
.b658	e9 01			sbc #$01			SBC	#$01			; -1
.b65a	85 77			sta $77				STA	Bpntrl		; save BASIC execute pointer low byte
.b65c	a5 5f			lda $5f				LDA	Baslnh		; get pointer high byte
.b65e	e9 00			sbc #$00			SBC	#$00			; subtract carry
.b660	85 78			sta $78				STA	Bpntrh		; save BASIC execute pointer high byte
.b662									LAB_16E5
.b662	60				rts					RTS
.b663									LAB_DONOK
.b663	a2 22			ldx #$22			LDX	#$22			; error code $22 ("LOOP without DO" error)
.b665	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; do error #X, then warm start
.b668									LAB_LOOP
.b668	a8				tay					TAY				; save following token
.b669	ba				tsx					TSX				; copy stack pointer
.b66a	bd 03 01		lda $0103,x			LDA	LAB_STAK+3,X	; get token byte from stack
.b66d	c9 9d			cmp #$9d			CMP	#TK_DO		; compare with DO token
.b66f	d0 f2			bne $b663			BNE	LAB_DONOK		; branch if no matching DO
.b671	e8				inx					INX				; dump calling routine return address
.b672	e8				inx					INX				; dump calling routine return address
.b673	9a				txs					TXS				; correct stack
.b674	98				tya					TYA				; get saved following token back
.b675	f0 20			beq $b697			BEQ	LoopAlways		; if no following token loop forever
.b677	c9 3a			cmp #$3a			CMP	#':'			; could be ':'
.b679	f0 1c			beq $b697			BEQ	LoopAlways		; if :... loop forever
.b67b	e9 b4			sbc #$b4			SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
.b67d	aa				tax					TAX				; copy to X (if it was UNTIL then Y will be correct)
.b67e	f0 04			beq $b684			BEQ	DoRest		; branch if was UNTIL
.b680	ca				dex					DEX				; decrement result
.b681	d0 62			bne $b6e5			BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
.b683	ca				dex					DEX				; set invert result byte
.b684									DoRest
.b684	86 4c			stx $4c				STX	Frnxth		; save invert result byte
.b686	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.b689	20 29 bb		jsr $bb29			JSR	LAB_EVEX		; evaluate expression
.b68c	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.b68e	f0 02			beq $b692			BEQ	DoCmp			; if =0 go do straight compare
.b690	a9 ff			lda #$ff			LDA	#$FF			; else set all bits
.b692									DoCmp
.b692	ba				tsx					TSX				; copy stack pointer
.b693	45 4c			eor $4c				EOR	Frnxth		; EOR with invert byte
.b695	d0 1a			bne $b6b1			BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
.b697									LoopAlways
.b697	bd 02 01		lda $0102,x			LDA	LAB_STAK+2,X	; get current line low byte
.b69a	85 3b			sta $3b				STA	Clinel		; save current line low byte
.b69c	bd 03 01		lda $0103,x			LDA	LAB_STAK+3,X	; get current line high byte
.b69f	85 3c			sta $3c				STA	Clineh		; save current line high byte
.b6a1	bd 04 01		lda $0104,x			LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
.b6a4	85 77			sta $77				STA	Bpntrl		; save BASIC execute pointer low byte
.b6a6	bd 05 01		lda $0105,x			LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
.b6a9	85 78			sta $78				STA	Bpntrh		; save BASIC execute pointer high byte
.b6ab	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b6ae	4c 0d b5		jmp $b50d			JMP	LAB_15C2		; go do interpreter inner loop
.b6b1									LoopDone
.b6b1	e8				inx					INX				; dump DO token
.b6b2	e8				inx					INX				; dump current line low byte
.b6b3	e8				inx					INX				; dump current line high byte
.b6b4	e8				inx					INX				; dump BASIC execute pointer low byte
.b6b5	e8				inx					INX				; dump BASIC execute pointer high byte
.b6b6	9a				txs					TXS				; correct stack
.b6b7	4c d7 b6		jmp $b6d7			JMP	LAB_DATA		; go perform DATA (find : or [EOL])
.b6ba									LAB_16F4
.b6ba	a2 04			ldx #$04			LDX	#$04			; error code $04 ("RETURN without GOSUB" error)
>b6bc	2c									.byte	$2C			; makes next line BIT LAB_0EA2
.b6bd									LAB_16F7
.b6bd	a2 0e			ldx #$0e			LDX	#$0E			; error code $0E ("Undefined statement" error)
.b6bf	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; do error #X, then warm start
.b6c2									LAB_RETURN
.b6c2	d0 9e			bne $b662			BNE	LAB_16E5		; exit if following token (to allow syntax error)
.b6c4									LAB_16E8
.b6c4	68				pla					PLA				; dump calling routine return address
.b6c5	68				pla					PLA				; dump calling routine return address
.b6c6	68				pla					PLA				; pull token
.b6c7	c9 8d			cmp #$8d			CMP	#TK_GOSUB		; compare with GOSUB token
.b6c9	d0 ef			bne $b6ba			BNE	LAB_16F4		; branch if no matching GOSUB
.b6cb									LAB_16FF
.b6cb	68				pla					PLA				; pull current line low byte
.b6cc	85 3b			sta $3b				STA	Clinel		; save current line low byte
.b6ce	68				pla					PLA				; pull current line high byte
.b6cf	85 3c			sta $3c				STA	Clineh		; save current line high byte
.b6d1	68				pla					PLA				; pull BASIC execute pointer low byte
.b6d2	85 77			sta $77				STA	Bpntrl		; save BASIC execute pointer low byte
.b6d4	68				pla					PLA				; pull BASIC execute pointer high byte
.b6d5	85 78			sta $78				STA	Bpntrh		; save BASIC execute pointer high byte
.b6d7									LAB_DATA
.b6d7	20 e8 b6		jsr $b6e8			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.b6da									LAB_170F
.b6da	98				tya					TYA				; copy index to A
.b6db	18				clc					CLC				; clear carry for add
.b6dc	65 77			adc $77				ADC	Bpntrl		; add BASIC execute pointer low byte
.b6de	85 77			sta $77				STA	Bpntrl		; save BASIC execute pointer low byte
.b6e0	90 02			bcc $b6e4			BCC	LAB_1719		; skip next if no carry
.b6e2	e6 78			inc $78				INC	Bpntrh		; else increment BASIC execute pointer high byte
.b6e4									LAB_1719
.b6e4	60				rts					RTS
.b6e5									LAB_16FC
.b6e5	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; do syntax error then warm start
.b6e8									LAB_SNBS
.b6e8	a2 3a			ldx #$3a			LDX	#':'			; set look for character = ":"
>b6ea	2c									.byte	$2C			; makes next line BIT $00A2
.b6eb									LAB_SNBL
.b6eb	a2 00			ldx #$00			LDX	#$00			; set alt search character = [EOL]
.b6ed	a0 00			ldy #$00			LDY	#$00			; set search character = [EOL]
.b6ef	84 0e			sty $0e				STY	Asrch			; store search character
.b6f1									LAB_1725
.b6f1	8a				txa					TXA				; get alt search character
.b6f2	45 0e			eor $0e				EOR	Asrch			; toggle search character, effectively swap with $00
.b6f4	85 0e			sta $0e				STA	Asrch			; save swapped search character
.b6f6									LAB_172D
.b6f6	b1 77			lda ($77),y			LDA	(Bpntrl),Y		; get next byte
.b6f8	f0 ea			beq $b6e4			BEQ	LAB_1719		; exit if null [EOL]
.b6fa	c5 0e			cmp $0e				CMP	Asrch			; compare with search character
.b6fc	f0 e6			beq $b6e4			BEQ	LAB_1719		; exit if found
.b6fe	c8				iny					INY				; increment index
.b6ff	c9 22			cmp #$22			CMP	#$22			; compare current character with open quote
.b701	d0 f3			bne $b6f6			BNE	LAB_172D		; if not open quote go get next character
.b703	f0 ec			beq $b6f1			BEQ	LAB_1725		; if found go swap search character for alt search character
.b705									LAB_IF
.b705	20 29 bb		jsr $bb29			JSR	LAB_EVEX		; evaluate the expression
.b708	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b70b	c9 b1			cmp #$b1			CMP	#TK_THEN		; compare with THEN token
.b70d	f0 11			beq $b720			BEQ	LAB_174B		; if it was THEN go do IF
.b70f	c9 89			cmp #$89			CMP	#TK_GOTO		; compare with GOTO token
.b711	d0 d2			bne $b6e5			BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
.b713	a6 77			ldx $77				LDX	Bpntrl		; save the basic pointer low byte
.b715	a4 78			ldy $78				LDY	Bpntrh		; save the basic pointer high byte
.b717	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.b71a	b0 c9			bcs $b6e5			BCS	LAB_16FC		; if not numeric go do syntax error
.b71c	86 77			stx $77				STX	Bpntrl		; restore the basic pointer low byte
.b71e	84 78			sty $78				STY	Bpntrh		; restore the basic pointer high byte
.b720									LAB_174B
.b720	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.b722	f0 1e			beq $b742			BEQ	LAB_174E		; if the result was zero go look for an ELSE
.b724	20 70 00		jsr $0070			JSR	LAB_IGBY		; else increment and scan memory
.b727	b0 03			bcs $b72c			BCS	LAB_174D		; if not numeric go do var or keyword
.b729									LAB_174C
.b729	4c 36 b6		jmp $b636			JMP	LAB_GOTO		; else was numeric so do GOTO n
.b72c									LAB_174D
.b72c	68				pla				      PLA                     ; discard interpreter loop return address
.b72d	68				pla				      PLA                     ; so data structures are at the correct stack offset
.b72e	20 76 00		jsr $0076		      JSR   LAB_GBYT          ; restore token or variable
.b731	20 4b b5		jsr $b54b		      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
.b734	a0 00			ldy #$00		      LDY   #$00              ; clear the index
.b736	b1 77			lda ($77),y		      LDA   (Bpntrl),Y        ; get the next BASIC byte
.b738	c9 ad			cmp #$ad		      CMP   #TK_ELSE          ; compare it with the token for ELSE
.b73a	d0 03			bne $b73f		      BNE   LAB_no_ELSE       ; no - continue on this line
.b73c	20 d7 b6		jsr $b6d7		      JSR   LAB_DATA          ; yes - skip the rest of the line
.b73f									LAB_no_ELSE
.b73f	4c 0d b5		jmp $b50d		      JMP LAB_15C2            ; return to the interpreter inner loop
.b742									LAB_174E
.b742	a0 00			ldy #$00			LDY	#$00			; clear the BASIC byte index
.b744	a2 01			ldx #$01			LDX	#$01			; clear the nesting depth
.b746									LAB_1750
.b746	c8				iny					INY				; increment the BASIC byte index
.b747	b1 77			lda ($77),y			LDA	(Bpntrl),Y		; get the next BASIC byte
.b749	f0 0f			beq $b75a			BEQ	LAB_1753		; if EOL go add the pointer and return
.b74b	c9 8b			cmp #$8b			CMP	#TK_IF		; compare the byte with the token for IF
.b74d	d0 03			bne $b752			BNE	LAB_1752		; if not IF token skip the depth increment
.b74f	e8				inx					INX				; else increment the nesting depth ..
.b750	d0 f4			bne $b746			BNE	LAB_1750		; .. and continue looking
.b752									LAB_1752
.b752	c9 ad			cmp #$ad			CMP	#TK_ELSE		; compare the byte with the token for ELSE
.b754	d0 f0			bne $b746			BNE	LAB_1750		; if not ELSE token continue looking
.b756	ca				dex					DEX				; was ELSE so decrement the nesting depth
.b757	d0 ed			bne $b746			BNE	LAB_1750		; loop if still nested
.b759	c8				iny					INY				; increment the BASIC byte index past the ELSE
.b75a									LAB_1753
.b75a	98				tya					TYA				; else copy line index to A
.b75b	18				clc					CLC				; clear carry for add
.b75c	65 77			adc $77				ADC	Bpntrl		; add the BASIC execute pointer low byte
.b75e	85 77			sta $77				STA	Bpntrl		; save the BASIC execute pointer low byte
.b760	90 02			bcc $b764			BCC	LAB_1754		; branch if no overflow to high byte
.b762	e6 78			inc $78				INC	Bpntrh		; else increment the BASIC execute pointer high byte
.b764									LAB_1754
.b764	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b767	90 c0			bcc $b729			BCC	LAB_174C		; if numeric do GOTO n
.b769	4c 4b b5		jmp $b54b			JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
.b76c									LAB_REM
.b76c	20 eb b6		jsr $b6eb			JSR	LAB_SNBL		; scan for next BASIC line
.b76f	4c da b6		jmp $b6da			JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
.b772									LAB_16FD
.b772	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; do syntax error then warm start
.b775									LAB_ON
.b775	c9 a9			cmp #$a9			CMP	#TK_IRQ		; was it IRQ token ?
.b777	d0 03			bne $b77c			BNE	LAB_NOIN		; if not go check NMI
.b779	4c 92 cf		jmp $cf92			JMP	LAB_SIRQ		; else go set-up IRQ
.b77c									LAB_NOIN
.b77c	c9 aa			cmp #$aa			CMP	#TK_NMI		; was it NMI token ?
.b77e	d0 03			bne $b783			BNE	LAB_NONM		; if not go do normal ON command
.b780	4c 96 cf		jmp $cf96			JMP	LAB_SNMI		; else go set-up NMI
.b783									LAB_NONM
.b783	20 e6 c4		jsr $c4e6			JSR	LAB_GTBY		; get byte parameter
.b786	48				pha					PHA				; push GOTO/GOSUB token
.b787	c9 8d			cmp #$8d			CMP	#TK_GOSUB		; compare with GOSUB token
.b789	f0 04			beq $b78f			BEQ	LAB_176B		; branch if GOSUB
.b78b	c9 89			cmp #$89			CMP	#TK_GOTO		; compare with GOTO token
.b78d									LAB_1767
.b78d	d0 e3			bne $b772			BNE	LAB_16FD		; if not GOTO do syntax error then warm start
.b78f									LAB_176B
.b78f	c6 63			dec $63				DEC	FAC1_3		; decrement index (byte value)
.b791	d0 04			bne $b797			BNE	LAB_1773		; branch if not zero
.b793	68				pla					PLA				; pull GOTO/GOSUB token
.b794	4c 4d b5		jmp $b54d			JMP	LAB_1602		; go execute it
.b797									LAB_1773
.b797	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.b79a	20 a3 b7		jsr $b7a3			JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
.b79d	c9 2c			cmp #$2c			CMP	#$2C			; compare next character with ","
.b79f	f0 ee			beq $b78f			BEQ	LAB_176B		; loop if ","
.b7a1									LAB_177E
.b7a1	68				pla					PLA				; else pull keyword token (run out of options)
.b7a2									LAB_177F
.b7a2	60				rts					RTS
.b7a3									LAB_GFPN
.b7a3	a2 00			ldx #$00			LDX	#$00			; clear reg
.b7a5	86 0a			stx $0a				STX	Itempl		; clear temporary integer low byte
.b7a7									LAB_1785
.b7a7	86 0b			stx $0b				STX	Itemph		; save temporary integer high byte
.b7a9	b0 f7			bcs $b7a2			BCS	LAB_177F		; return if carry set, end of scan, character was
.b7ab	e0 19			cpx #$19			CPX	#$19			; compare high byte with $19
.b7ad	a8				tay					TAY				; ensure Zb = 0 if the branch is taken
.b7ae	b0 dd			bcs $b78d			BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
.b7b0	e9 2f			sbc #$2f			SBC	#'0'-1		; subtract "0", $2F + carry, from byte
.b7b2	a8				tay					TAY				; copy binary digit
.b7b3	a5 0a			lda $0a				LDA	Itempl		; get temporary integer low byte
.b7b5	0a				asl a				ASL				; *2 low byte
.b7b6	26 0b			rol $0b				ROL	Itemph		; *2 high byte
.b7b8	0a				asl a				ASL				; *2 low byte
.b7b9	26 0b			rol $0b				ROL	Itemph		; *2 high byte, *4
.b7bb	65 0a			adc $0a				ADC	Itempl		; + low byte, *5
.b7bd	85 0a			sta $0a				STA	Itempl		; save it
.b7bf	8a				txa					TXA				; get high byte copy to A
.b7c0	65 0b			adc $0b				ADC	Itemph		; + high byte, *5
.b7c2	06 0a			asl $0a				ASL	Itempl		; *2 low byte, *10d
.b7c4	2a				rol a				ROL				; *2 high byte, *10d
.b7c5	aa				tax					TAX				; copy high byte back to X
.b7c6	98				tya					TYA				; get binary digit back
.b7c7	65 0a			adc $0a				ADC	Itempl		; add number low byte
.b7c9	85 0a			sta $0a				STA	Itempl		; save number low byte
.b7cb	90 01			bcc $b7ce			BCC	LAB_17B3		; if no overflow to high byte get next character
.b7cd	e8				inx					INX				; else increment high byte
.b7ce									LAB_17B3
.b7ce	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.b7d1	4c a7 b7		jmp $b7a7			JMP	LAB_1785		; loop for next character
.b7d4									LAB_DEC
.b7d4	a9 3c			lda #$3c			LDA	#<LAB_2AFD		; set -1 pointer low byte
>b7d6	2c									.byte	$2C			; BIT abs to skip the LDA below
.b7d7									LAB_INC
.b7d7	a9 38			lda #$38			LDA	#<LAB_259C		; set 1 pointer low byte
.b7d9									LAB_17B5
.b7d9	48				pha					PHA				; save +/-1 pointer low byte
.b7da									LAB_17B7
.b7da	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get var address
.b7dd	a6 11			ldx $11				LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.b7df	30 1e			bmi $b7ff			BMI	IncrErr		; exit if string
.b7e1	85 4b			sta $4b				STA	Lvarpl		; save var address low byte
.b7e3	84 4c			sty $4c				STY	Lvarph		; save var address high byte
.b7e5	20 d7 c8		jsr $c8d7			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.b7e8	68				pla					PLA				; get +/-1 pointer low byte
.b7e9	48				pha					PHA				; save +/-1 pointer low byte
.b7ea	a0 d2			ldy #$d2			LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
.b7ec	20 18 c6		jsr $c618			JSR	LAB_246C		; add (AY) to FAC1
.b7ef	20 fd c8		jsr $c8fd			JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
.b7f2	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b7f5	c9 2c			cmp #$2c			CMP	#','			; compare with ","
.b7f7	d0 a8			bne $b7a1			BNE	LAB_177E		; exit if not "," (either end or error)
.b7f9	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.b7fc	4c da b7		jmp $b7da			JMP	LAB_17B7		; go do next var
.b7ff									IncrErr
.b7ff	4c 24 bb		jmp $bb24			JMP	LAB_1ABC		; do "Type mismatch" error then warm start
.b802									LAB_LET
.b802	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get var address
.b805	85 4b			sta $4b				STA	Lvarpl		; save var address low byte
.b807	84 4c			sty $4c				STY	Lvarph		; save var address high byte
.b809	a9 c2			lda #$c2			LDA	#TK_EQUAL		; get = token
.b80b	20 39 bc		jsr $bc39			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.b80e	a5 11			lda $11				LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.b810	48				pha					PHA				; push data type flag
.b811	20 29 bb		jsr $bb29			JSR	LAB_EVEX		; evaluate expression
.b814	68				pla					PLA				; pop data type flag
.b815	2a				rol a				ROL				; set carry if type = string
.b816	20 1b bb		jsr $bb1b			JSR	LAB_CKTM		; type match check, set C for string
.b819	b0 03			bcs $b81e			BCS	LAB_17D5		; branch if string
.b81b	4c fd c8		jmp $c8fd			JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
.b81e									LAB_17D5
.b81e	a0 02			ldy #$02			LDY	#$02			; set index to pointer high byte
.b820	b1 62			lda ($62),y			LDA	(des_pl),Y		; get string pointer high byte
.b822	c5 36			cmp $36				CMP	Sstorh		; compare bottom of string space high byte
.b824	90 17			bcc $b83d			BCC	LAB_17F4		; if less assign value and exit (was in program memory)
.b826	d0 07			bne $b82f			BNE	LAB_17E6		; branch if >
.b828	88				dey					DEY				; decrement index
.b829	b1 62			lda ($62),y			LDA	(des_pl),Y		; get pointer low byte
.b82b	c5 35			cmp $35				CMP	Sstorl		; compare bottom of string space low byte
.b82d	90 0e			bcc $b83d			BCC	LAB_17F4		; if less assign value and exit (was in program memory)
.b82f									LAB_17E6
.b82f	a4 63			ldy $63				LDY	des_ph		; get descriptor pointer high byte
.b831	c4 30			cpy $30				CPY	Svarh			; compare start of vars high byte
.b833	90 08			bcc $b83d			BCC	LAB_17F4		; branch if less (descriptor is on stack)
.b835	d0 0d			bne $b844			BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
.b837	a5 62			lda $62				LDA	des_pl		; get descriptor pointer low byte
.b839	c5 2f			cmp $2f				CMP	Svarl			; compare start of vars low byte
.b83b	b0 07			bcs $b844			BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
.b83d									LAB_17F4
.b83d	a5 62			lda $62				LDA	des_pl		; get descriptor pointer low byte
.b83f	a4 63			ldy $63				LDY	des_ph		; get descriptor pointer high byte
.b841	4c 5a b8		jmp $b85a			JMP	LAB_1811		; clean stack, copy descriptor to variable and return
.b844									LAB_17FB
.b844	a0 00			ldy #$00			LDY	#$00			; index to length
.b846	b1 62			lda ($62),y			LDA	(des_pl),Y		; get string length
.b848	20 8a c1		jsr $c18a			JSR	LAB_209C		; copy string
.b84b	a5 52			lda $52				LDA	des_2l		; get descriptor pointer low byte
.b84d	a4 53			ldy $53				LDY	des_2h		; get descriptor pointer high byte
.b84f	85 6c			sta $6c				STA	ssptr_l		; save descriptor pointer low byte
.b851	84 6d			sty $6d				STY	ssptr_h		; save descriptor pointer high byte
.b853	20 6b c3		jsr $c36b			JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
.b856	a9 60			lda #$60			LDA	#<FAC1_e		; set descriptor pointer low byte
.b858	a0 00			ldy #$00			LDY	#>FAC1_e		; get descriptor pointer high byte
.b85a									LAB_1811
.b85a	85 52			sta $52				STA	des_2l		; save descriptor_2 pointer low byte
.b85c	84 53			sty $53				STY	des_2h		; save descriptor_2 pointer high byte
.b85e	20 cd c3		jsr $c3cd			JSR	LAB_22EB		; clean descriptor stack, YA = pointer
.b861	a0 00			ldy #$00			LDY	#$00			; index to length
.b863	b1 52			lda ($52),y			LDA	(des_2l),Y		; get string length
.b865	91 4b			sta ($4b),y			STA	(Lvarpl),Y		; copy to let string variable
.b867	c8				iny					INY				; index to string pointer low byte
.b868	b1 52			lda ($52),y			LDA	(des_2l),Y		; get string pointer low byte
.b86a	91 4b			sta ($4b),y			STA	(Lvarpl),Y		; copy to let string variable
.b86c	c8				iny					INY				; index to string pointer high byte
.b86d	b1 52			lda ($52),y			LDA	(des_2l),Y		; get string pointer high byte
.b86f	91 4b			sta ($4b),y			STA	(Lvarpl),Y		; copy to let string variable
.b871	60				rts					RTS
.b872									LAB_GET
.b872	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get var address
.b875	85 4b			sta $4b				STA	Lvarpl		; save var address low byte
.b877	84 4c			sty $4c				STY	Lvarph		; save var address high byte
.b879	20 5a cf		jsr $cf5a			JSR	INGET			; get input byte
.b87c	a6 11			ldx $11				LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.b87e	30 07			bmi $b887			BMI	LAB_GETS		; go get string character
.b880	a8				tay					TAY				; copy character to Y
.b881	20 be c0		jsr $c0be			JSR	LAB_1FD0		; convert Y to byte in FAC1
.b884	4c fd c8		jmp $c8fd			JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
.b887									LAB_GETS
.b887	48				pha					PHA				; save character
.b888	a9 01			lda #$01			LDA	#$01			; string is single byte
.b88a	b0 01			bcs $b88d			BCS	LAB_IsByte		; branch if byte received
.b88c	68				pla					PLA				; string is null
.b88d									LAB_IsByte
.b88d	20 92 c1		jsr $c192			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.b890	f0 05			beq $b897			BEQ	LAB_NoSt		; skip store if null string
.b892	68				pla					PLA				; get character back
.b893	a0 00			ldy #$00			LDY	#$00			; clear index
.b895	91 61			sta ($61),y			STA	(str_pl),Y		; save byte in string (byte IS string!)
.b897									LAB_NoSt
.b897	20 df c1		jsr $c1df			JSR	LAB_RTST		; check for space on descriptor stack then put address
.b89a	4c 1e b8		jmp $b81e			JMP	LAB_17D5		; do string LET and return
.b89d									LAB_1829
.b89d	20 1f b9		jsr $b91f			JSR	LAB_18C6		; print string from Sutill/Sutilh
.b8a0									LAB_182C
.b8a0	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b8a3									LAB_PRINT
.b8a3	f0 3b			beq $b8e0			BEQ	LAB_CRLF		; if nothing following just print CR/LF
.b8a5									LAB_1831
.b8a5	c9 ac			cmp #$ac			CMP	#TK_TAB		; compare with TAB( token
.b8a7	f0 51			beq $b8fa			BEQ	LAB_18A2		; go do TAB/SPC
.b8a9	c9 b0			cmp #$b0			CMP	#TK_SPC		; compare with SPC( token
.b8ab	f0 4d			beq $b8fa			BEQ	LAB_18A2		; go do TAB/SPC
.b8ad	c9 2c			cmp #$2c			CMP	#','			; compare with ","
.b8af	f0 33			beq $b8e4			BEQ	LAB_188B		; go do move to next TAB mark
.b8b1	c9 3b			cmp #$3b			CMP	#';'			; compare with ";"
.b8b3	f0 61			beq $b916			BEQ	LAB_18BD		; if ";" continue with PRINT processing
.b8b5	20 29 bb		jsr $bb29			JSR	LAB_EVEX		; evaluate expression
.b8b8	24 11			bit $11				BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.b8ba	30 e1			bmi $b89d			BMI	LAB_1829		; branch if string
.b8bc	20 ef ca		jsr $caef			JSR	LAB_296E		; convert FAC1 to string
.b8bf	20 9c c1		jsr $c19c			JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.b8c2	a0 00			ldy #$00			LDY	#$00			; clear index
.b8c4	a5 08			lda $08				LDA	TWidth		; get terminal width byte
.b8c6	f0 0a			beq $b8d2			BEQ	LAB_185E		; skip check if zero
.b8c8	38				sec					SEC				; set carry for subtract
.b8c9	e5 07			sbc $07				SBC	TPos			; subtract terminal position
.b8cb	f1 62			sbc ($62),y			SBC	(des_pl),Y		; subtract string length
.b8cd	b0 03			bcs $b8d2			BCS	LAB_185E		; branch if less than terminal width
.b8cf	20 e0 b8		jsr $b8e0			JSR	LAB_CRLF		; else print CR/LF
.b8d2									LAB_185E
.b8d2	20 1f b9		jsr $b91f			JSR	LAB_18C6		; print string from Sutill/Sutilh
.b8d5	f0 c9			beq $b8a0			BEQ	LAB_182C		; always go continue processing line
.b8d7									LAB_1866
.b8d7	a9 00			lda #$00			LDA	#$00			; clear byte
.b8d9	9d 21 02		sta $0221,x			STA	Ibuffs,X		; null terminate input
.b8dc	a2 21			ldx #$21			LDX	#<Ibuffs		; set X to buffer start-1 low byte
.b8de	a0 02			ldy #$02			LDY	#>Ibuffs		; set Y to buffer start-1 high byte
.b8e0									LAB_CRLF
.b8e0	a9 0d			lda #$0d			LDA	#$0D			; load [CR]
.b8e2	80 52			bra $b936			BRA LAB_PRNA
.b8e4									LAB_188B
.b8e4	a5 07			lda $07				LDA	TPos			; get terminal position
.b8e6	c5 09			cmp $09				CMP	Iclim			; compare with input column limit
.b8e8	90 05			bcc $b8ef			BCC	LAB_1897		; branch if less
.b8ea	20 e0 b8		jsr $b8e0			JSR	LAB_CRLF		; else print CR/LF (next line)
.b8ed	d0 27			bne $b916			BNE	LAB_18BD		; continue with PRINT processing (branch always)
.b8ef									LAB_1897
.b8ef	38				sec					SEC				; set carry for subtract
.b8f0									LAB_1898
.b8f0	e5 17			sbc $17				SBC	TabSiz		; subtract TAB size
.b8f2	b0 fc			bcs $b8f0			BCS	LAB_1898		; loop if result was +ve
.b8f4	49 ff			eor #$ff			EOR	#$FF			; complement it
.b8f6	69 01			adc #$01			ADC	#$01			; +1 (twos complement)
.b8f8	d0 12			bne $b90c			BNE	LAB_18B6		; always print A spaces (result is never $00)
.b8fa									LAB_18A2
.b8fa	48				pha					PHA				; save token
.b8fb	20 e3 c4		jsr $c4e3			JSR	LAB_SGBY		; scan and get byte parameter
.b8fe	c9 29			cmp #$29			CMP	#$29			; is next character )
.b900	d0 7b			bne $b97d			BNE	LAB_1910		; if not do syntax error then warm start
.b902	68				pla					PLA				; get token back
.b903	c9 ac			cmp #$ac			CMP	#TK_TAB		; was it TAB ?
.b905	d0 06			bne $b90d			BNE	LAB_18B7		; if not go do SPC
.b907	8a				txa					TXA				; copy integer value to A
.b908	e5 07			sbc $07				SBC	TPos			; subtract terminal position
.b90a	90 0a			bcc $b916			BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
.b90c									LAB_18B6
.b90c	aa				tax					TAX				; copy result to X
.b90d									LAB_18B7
.b90d	8a				txa					TXA				; set flags on size for SPC
.b90e	f0 06			beq $b916			BEQ	LAB_18BD		; branch if result was = $0, already here
.b910									LAB_18BA
.b910	20 31 b9		jsr $b931			JSR	LAB_18E0		; print " "
.b913	ca				dex					DEX				; decrement count
.b914	d0 fa			bne $b910			BNE	LAB_18BA		; loop if not all done
.b916									LAB_18BD
.b916	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.b919	d0 8a			bne $b8a5			BNE	LAB_1831		; if more to print go do it
.b91b	60				rts					RTS
.b91c									LAB_18C3
.b91c	20 9c c1		jsr $c19c			JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.b91f									LAB_18C6
.b91f	20 98 c3		jsr $c398			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.b922	a0 00			ldy #$00			LDY	#$00			; reset index
.b924	aa				tax					TAX				; copy length to X
.b925	f0 49			beq $b970			BEQ	LAB_188C		; exit (RTS) if null string
.b927									LAB_18CD
.b927	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get next byte
.b929	20 36 b9		jsr $b936			JSR	LAB_PRNA		; go print the character
.b92c	c8				iny					INY				; increment index
.b92d	ca				dex					DEX				; decrement count
.b92e	d0 f7			bne $b927			BNE	LAB_18CD		; loop if not done yet
.b930	60				rts					RTS
.b931									LAB_18E0
.b931	a9 20			lda #$20			LDA	#$20			; load " "
>b933	2c									.byte	$2C			; change next line to BIT LAB_3FA9
.b934									LAB_18E3
.b934	a9 3f			lda #$3f			LDA	#$3F			; load "?" character
.b936									LAB_PRNA
.b936	c9 20			cmp #$20			CMP	#' '			; compare with " "
.b938	90 19			bcc $b953			BCC	LAB_18F9		; branch if less (non printing)
.b93a	48				pha					PHA				; save the character
.b93b	a5 08			lda $08				LDA	TWidth		; get terminal width
.b93d	d0 0a			bne $b949			BNE	LAB_18F0		; branch if not zero (not infinite length)
.b93f	a5 07			lda $07				LDA	TPos			; get position
.b941	e5 17			sbc $17				SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
.b943	d0 0b			bne $b950			BNE	LAB_18F7		; skip reset if different
.b945	85 07			sta $07				STA	TPos			; else reset position
.b947	f0 07			beq $b950			BEQ	LAB_18F7		; go print character
.b949									LAB_18F0
.b949	c5 07			cmp $07				CMP	TPos			; compare with terminal character position
.b94b	d0 03			bne $b950			BNE	LAB_18F7		; branch if not at end of line
.b94d	20 e0 b8		jsr $b8e0			JSR	LAB_CRLF		; else print CR/LF
.b950									LAB_18F7
.b950	e6 07			inc $07				INC	TPos			; increment terminal position
.b952	68				pla					PLA				; get character back
.b953									LAB_18F9
.b953	20 48 d1		jsr $d148			JSR	V_OUTP		; output byte via output vector
.b956	c9 0d			cmp #$0d			CMP	#$0D			; compare with [CR]
.b958	d0 14			bne $b96e			BNE	LAB_188A		; branch if not [CR]
.b95a	86 2c			stx $2c				STX	TempB			; save buffer index
.b95c	a6 06			ldx $06				LDX	Nullct		; get null count
.b95e	f0 0a			beq $b96a			BEQ	LAB_1886		; branch if no nulls
.b960	a9 00			lda #$00			LDA	#$00			; load [NULL]
.b962									LAB_1880
.b962	20 36 b9		jsr $b936			JSR	LAB_PRNA		; go print the character
.b965	ca				dex					DEX				; decrement count
.b966	d0 fa			bne $b962			BNE	LAB_1880		; loop if not all done
.b968	a9 0d			lda #$0d			LDA	#$0D			; restore the character (and set the flags)
.b96a									LAB_1886
.b96a	86 07			stx $07				STX	TPos			; clear terminal position (X always = zero when we get here)
.b96c	a6 2c			ldx $2c				LDX	TempB			; restore buffer index
.b96e									LAB_188A
.b96e	29 ff			and #$ff			AND	#$FF			; set the flags
.b970									LAB_188C
.b970	60				rts					RTS
.b971									LAB_1904
.b971	a5 15			lda $15				LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
.b973	10 0b			bpl $b980			BPL	LAB_1913		; branch if INPUT (go do redo)
.b975	a5 41			lda $41				LDA	Dlinel		; get current DATA line low byte
.b977	a4 42			ldy $42				LDY	Dlineh		; get current DATA line high byte
.b979	85 3b			sta $3b				STA	Clinel		; save current line low byte
.b97b	84 3c			sty $3c				STY	Clineh		; save current line high byte
.b97d									LAB_1910
.b97d	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; do syntax error then warm start
.b980									LAB_1913
.b980	a9 70			lda #$70			LDA	#<LAB_REDO		; point to redo message (low addr)
.b982	a0 d8			ldy #$d8			LDY	#>LAB_REDO		; point to redo message (high addr)
.b984	20 1c b9		jsr $b91c			JSR	LAB_18C3		; print null terminated string from memory
.b987	a5 3f			lda $3f				LDA	Cpntrl		; get continue pointer low byte
.b989	a4 40			ldy $40				LDY	Cpntrh		; get continue pointer high byte
.b98b	85 77			sta $77				STA	Bpntrl		; save BASIC execute pointer low byte
.b98d	84 78			sty $78				STY	Bpntrh		; save BASIC execute pointer high byte
.b98f	60				rts					RTS
.b990									LAB_INPUT
.b990	c9 22			cmp #$22			CMP	#$22			; compare next byte with open quote
.b992	d0 0b			bne $b99f			BNE	LAB_1934		; branch if no prompt string
.b994	20 06 bc		jsr $bc06			JSR	LAB_1BC1		; print "..." string
.b997	a9 3b			lda #$3b			LDA	#$3B			; load A with ";"
.b999	20 39 bc		jsr $bc39			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.b99c	20 1f b9		jsr $b91f			JSR	LAB_18C6		; print string from Sutill/Sutilh
.b99f									LAB_1934
.b99f	20 c2 c0		jsr $c0c2			JSR	LAB_CKRN		; check not Direct, back here if ok
.b9a2	20 93 b2		jsr $b293			JSR	LAB_INLN		; print "? " and get BASIC input
.b9a5	a9 00			lda #$00			LDA	#$00			; set mode = INPUT
.b9a7	cd 21 02		cmp $0221			CMP	Ibuffs		; test first byte in buffer
.b9aa	d0 09			bne $b9b5			BNE	LAB_1953		; branch if not null input
.b9ac	4c 75 b5		jmp $b575			JMP	LAB_1647		; go do BREAK exit
.b9af									LAB_READ
.b9af	a6 43			ldx $43				LDX	Dptrl			; get DATA pointer low byte
.b9b1	a4 44			ldy $44				LDY	Dptrh			; get DATA pointer high byte
.b9b3	a9 80			lda #$80			LDA	#$80			; set mode = READ
.b9b5									LAB_1953
.b9b5	85 15			sta $15				STA	Imode			; set input mode flag, $00=INPUT, $80=READ
.b9b7	86 45			stx $45				STX	Rdptrl		; save READ pointer low byte
.b9b9	84 46			sty $46				STY	Rdptrh		; save READ pointer high byte
.b9bb									LAB_195B
.b9bb	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get (var) address
.b9be	85 4b			sta $4b				STA	Lvarpl		; save address low byte
.b9c0	84 4c			sty $4c				STY	Lvarph		; save address high byte
.b9c2	a5 77			lda $77				LDA	Bpntrl		; get BASIC execute pointer low byte
.b9c4	a4 78			ldy $78				LDY	Bpntrh		; get BASIC execute pointer high byte
.b9c6	85 0a			sta $0a				STA	Itempl		; save as temporary integer low byte
.b9c8	84 0b			sty $0b				STY	Itemph		; save as temporary integer high byte
.b9ca	a6 45			ldx $45				LDX	Rdptrl		; get READ pointer low byte
.b9cc	a4 46			ldy $46				LDY	Rdptrh		; get READ pointer high byte
.b9ce	86 77			stx $77				STX	Bpntrl		; set BASIC execute pointer low byte
.b9d0	84 78			sty $78				STY	Bpntrh		; set BASIC execute pointer high byte
.b9d2	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b9d5	d0 11			bne $b9e8			BNE	LAB_1988		; branch if not null
.b9d7	24 15			bit $15				BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
.b9d9	30 65			bmi $ba40			BMI	LAB_19DD		; branch if READ
.b9db	20 34 b9		jsr $b934			JSR	LAB_18E3		; print "?" character (double ? for extended input)
.b9de	20 93 b2		jsr $b293			JSR	LAB_INLN		; print "? " and get BASIC input
.b9e1	86 77			stx $77				STX	Bpntrl		; set BASIC execute pointer low byte
.b9e3	84 78			sty $78				STY	Bpntrh		; set BASIC execute pointer high byte
.b9e5									LAB_1985
.b9e5	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.b9e8									LAB_1988
.b9e8	24 11			bit $11				BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.b9ea	10 24			bpl $ba10			BPL	LAB_19B0		; branch if numeric
.b9ec	85 0d			sta $0d				STA	Srchc			; save search character
.b9ee	c9 22			cmp #$22			CMP	#$22			; was it " ?
.b9f0	f0 07			beq $b9f9			BEQ	LAB_1999		; branch if so
.b9f2	a9 3a			lda #$3a			LDA	#':'			; else search character is ":"
.b9f4	85 0d			sta $0d				STA	Srchc			; set new search character
.b9f6	a9 2c			lda #$2c			LDA	#','			; other search character is ","
.b9f8	18				clc					CLC				; clear carry for add
.b9f9									LAB_1999
.b9f9	85 0e			sta $0e				STA	Asrch			; set second search character
.b9fb	a5 77			lda $77				LDA	Bpntrl		; get BASIC execute pointer low byte
.b9fd	a4 78			ldy $78				LDY	Bpntrh		; get BASIC execute pointer high byte
.b9ff	69 00			adc #$00			ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
.ba01	90 01			bcc $ba04			BCC	LAB_19A4		; branch if no execute pointer low byte rollover
.ba03	c8				iny					INY				; else increment high byte
.ba04									LAB_19A4
.ba04	20 a2 c1		jsr $c1a2			JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
.ba07	20 29 c5		jsr $c529			JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
.ba0a	20 1e b8		jsr $b81e			JSR	LAB_17D5		; go do string LET
.ba0d	4c 16 ba		jmp $ba16			JMP	LAB_19B6		; go check string terminator
.ba10									LAB_19B0
.ba10	20 00 ca		jsr $ca00			JSR	LAB_2887		; get FAC1 from string
.ba13	20 fd c8		jsr $c8fd			JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
.ba16									LAB_19B6
.ba16	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.ba19	f0 0a			beq $ba25			BEQ	LAB_19C5		; branch if null (last entry)
.ba1b	c9 2c			cmp #$2c			CMP	#','			; else compare with ","
.ba1d	f0 03			beq $ba22			BEQ	LAB_19C2		; branch if ","
.ba1f	4c 71 b9		jmp $b971			JMP	LAB_1904		; else go handle bad input data
.ba22									LAB_19C2
.ba22	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.ba25									LAB_19C5
.ba25	a5 77			lda $77				LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
.ba27	a4 78			ldy $78				LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
.ba29	85 45			sta $45				STA	Rdptrl		; save for now
.ba2b	84 46			sty $46				STY	Rdptrh		; save for now
.ba2d	a5 0a			lda $0a				LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
.ba2f	a4 0b			ldy $0b				LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
.ba31	85 77			sta $77				STA	Bpntrl		; set BASIC execute pointer low byte
.ba33	84 78			sty $78				STY	Bpntrh		; set BASIC execute pointer high byte
.ba35	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.ba38	f0 2c			beq $ba66			BEQ	LAB_1A03		; if null go do extra ignored message
.ba3a	20 46 bc		jsr $bc46			JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
.ba3d	4c bb b9		jmp $b9bb			JMP	LAB_195B		; go INPUT next variable from list
.ba40									LAB_19DD
.ba40	20 e8 b6		jsr $b6e8			JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.ba43	c8				iny					INY				; increment index
.ba44	aa				tax					TAX				; copy character ([:] or [EOL])
.ba45	d0 12			bne $ba59			BNE	LAB_19F6		; branch if [:]
.ba47	a2 06			ldx #$06			LDX	#$06			; set for "Out of DATA" error
.ba49	c8				iny					INY				; increment index, now points to next line pointer high byte
.ba4a	b1 77			lda ($77),y			LDA	(Bpntrl),Y		; get next line pointer high byte
.ba4c	f0 73			beq $bac1			BEQ	LAB_1A54		; branch if end (eventually does error X)
.ba4e	c8				iny					INY				; increment index
.ba4f	b1 77			lda ($77),y			LDA	(Bpntrl),Y		; get next line # low byte
.ba51	85 41			sta $41				STA	Dlinel		; save current DATA line low byte
.ba53	c8				iny					INY				; increment index
.ba54	b1 77			lda ($77),y			LDA	(Bpntrl),Y		; get next line # high byte
.ba56	c8				iny					INY				; increment index
.ba57	85 42			sta $42				STA	Dlineh		; save current DATA line high byte
.ba59									LAB_19F6
.ba59	b1 77			lda ($77),y			LDA	(Bpntrl),Y		; get byte
.ba5b	c8				iny					INY				; increment index
.ba5c	aa				tax					TAX				; copy to X
.ba5d	20 da b6		jsr $b6da			JSR	LAB_170F		; set BASIC execute pointer
.ba60	e0 83			cpx #$83			CPX	#TK_DATA		; compare with "DATA" token
.ba62	f0 81			beq $b9e5			BEQ	LAB_1985		; was "DATA" so go do next READ
.ba64	d0 da			bne $ba40			BNE	LAB_19DD		; go find next statement if not "DATA"
.ba66									LAB_1A03
.ba66	a5 45			lda $45				LDA	Rdptrl		; get temp READ pointer low byte
.ba68	a4 46			ldy $46				LDY	Rdptrh		; get temp READ pointer high byte
.ba6a	a6 15			ldx $15				LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
.ba6c	10 03			bpl $ba71			BPL	LAB_1A0E		; branch if INPUT
.ba6e	4c 97 b5		jmp $b597			JMP	LAB_1624		; save AY as DATA pointer and return
.ba71									LAB_1A0E
.ba71	a0 00			ldy #$00			LDY	#$00			; clear index
.ba73	b1 45			lda ($45),y			LDA	(Rdptrl),Y		; get next byte
.ba75	d0 01			bne $ba78			BNE	LAB_1A1B		; error if not end of INPUT
.ba77	60				rts					RTS
.ba78									LAB_1A1B
.ba78	a9 60			lda #$60			LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
.ba7a	a0 d8			ldy #$d8			LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
.ba7c	4c 1c b9		jmp $b91c			JMP	LAB_18C3		; print null terminated string from memory and return
.ba7f									LAB_11A1
.ba7f	ba				tsx					TSX				; copy stack pointer
.ba80	e8				inx					INX				; +1 pass return address
.ba81	e8				inx					INX				; +2 pass return address
.ba82	e8				inx					INX				; +3 pass calling routine return address
.ba83	e8				inx					INX				; +4 pass calling routine return address
.ba84									LAB_11A6
.ba84	bd 01 01		lda $0101,x			LDA	LAB_STAK+1,X	; get token byte from stack
.ba87	c9 81			cmp #$81			CMP	#TK_FOR		; is it FOR token
.ba89	d0 21			bne $baac			BNE	LAB_11CE		; exit if not FOR token
.ba8b	a5 4c			lda $4c				LDA	Frnxth		; get var pointer for FOR/NEXT high byte
.ba8d	d0 0a			bne $ba99			BNE	LAB_11BB		; branch if not null
.ba8f	bd 02 01		lda $0102,x			LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
.ba92	85 4b			sta $4b				STA	Frnxtl		; save var pointer for FOR/NEXT low byte
.ba94	bd 03 01		lda $0103,x			LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
.ba97	85 4c			sta $4c				STA	Frnxth		; save var pointer for FOR/NEXT high byte
.ba99									LAB_11BB
.ba99	dd 03 01		cmp $0103,x			CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
.ba9c	d0 07			bne $baa5			BNE	LAB_11C7		; branch if no match
.ba9e	a5 4b			lda $4b				LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
.baa0	dd 02 01		cmp $0102,x			CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
.baa3	f0 07			beq $baac			BEQ	LAB_11CE		; exit if match found
.baa5									LAB_11C7
.baa5	8a				txa					TXA				; copy index
.baa6	18				clc					CLC				; clear carry for add
.baa7	69 10			adc #$10			ADC	#$10			; add FOR stack use size
.baa9	aa				tax					TAX				; copy back to index
.baaa	d0 d8			bne $ba84			BNE	LAB_11A6		; loop if not at start of stack
.baac									LAB_11CE
.baac	60				rts					RTS
.baad									LAB_NEXT
.baad	d0 04			bne $bab3			BNE	LAB_1A46		; branch if NEXT var
.baaf	a0 00			ldy #$00			LDY	#$00			; else clear Y
.bab1	f0 03			beq $bab6			BEQ	LAB_1A49		; branch always (no variable to search for)
.bab3									LAB_1A46
.bab3	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get variable address
.bab6									LAB_1A49
.bab6	85 4b			sta $4b				STA	Frnxtl		; store variable pointer low byte
.bab8	84 4c			sty $4c				STY	Frnxth		; store variable pointer high byte
.baba	20 7f ba		jsr $ba7f			JSR	LAB_11A1		; search the stack for FOR activity
.babd	f0 04			beq $bac3			BEQ	LAB_1A56		; branch if found
.babf	a2 00			ldx #$00			LDX	#$00			; else set error $00 ("NEXT without FOR" error)
.bac1									LAB_1A54
.bac1	f0 63			beq $bb26			BEQ	LAB_1ABE		; do error #X, then warm start
.bac3									LAB_1A56
.bac3	9a				txs					TXS				; set stack pointer, X set by search, dumps return addresses
.bac4	8a				txa					TXA				; copy stack pointer
.bac5	38				sec					SEC				; set carry for subtract
.bac6	e9 f7			sbc #$f7			SBC	#$F7			; point to TO var
.bac8	85 27			sta $27				STA	ut2_pl		; save pointer to TO var for compare
.baca	69 fb			adc #$fb			ADC	#$FB			; point to STEP var
.bacc	a0 01			ldy #$01			LDY	#>LAB_STAK		; point to stack page high byte
.bace	20 d7 c8		jsr $c8d7			JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
.bad1	ba				tsx					TSX				; get stack pointer back
.bad2	bd 08 01		lda $0108,x			LDA	LAB_STAK+8,X	; get step sign
.bad5	85 64			sta $64				STA	FAC1_s		; save FAC1 sign (b7)
.bad7	a5 4b			lda $4b				LDA	Frnxtl		; get FOR variable pointer low byte
.bad9	a4 4c			ldy $4c				LDY	Frnxth		; get FOR variable pointer high byte
.badb	20 18 c6		jsr $c618			JSR	LAB_246C		; add (FOR variable) to FAC1
.bade	20 fd c8		jsr $c8fd			JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
.bae1	a0 01			ldy #$01			LDY	#>LAB_STAK		; point to stack page high byte
.bae3	20 73 c9		jsr $c973			JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
.bae6	ba				tsx					TSX				; get stack pointer back
.bae7	dd 08 01		cmp $0108,x			CMP	LAB_STAK+8,X	; compare step sign
.baea	f0 17			beq $bb03			BEQ	LAB_1A9B		; branch if = (loop complete)
.baec	bd 0d 01		lda $010d,x			LDA	LAB_STAK+$0D,X	; get FOR line low byte
.baef	85 3b			sta $3b				STA	Clinel		; save current line low byte
.baf1	bd 0e 01		lda $010e,x			LDA	LAB_STAK+$0E,X	; get FOR line high byte
.baf4	85 3c			sta $3c				STA	Clineh		; save current line high byte
.baf6	bd 10 01		lda $0110,x			LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
.baf9	85 77			sta $77				STA	Bpntrl		; save BASIC execute pointer low byte
.bafb	bd 0f 01		lda $010f,x			LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
.bafe	85 78			sta $78				STA	Bpntrh		; save BASIC execute pointer high byte
.bb00									LAB_1A98
.bb00	4c 0d b5		jmp $b50d			JMP	LAB_15C2		; go do interpreter inner loop
.bb03									LAB_1A9B
.bb03	8a				txa					TXA				; stack copy to A
.bb04	69 0f			adc #$0f			ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
.bb06	aa				tax					TAX				; copy back to index
.bb07	9a				txs					TXS				; copy to stack pointer
.bb08	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.bb0b	c9 2c			cmp #$2c			CMP	#','			; compare with ","
.bb0d	d0 f1			bne $bb00			BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
.bb0f	20 70 00		jsr $0070			JSR	LAB_IGBY		; else increment and scan memory
.bb12	20 b3 ba		jsr $bab3			JSR	LAB_1A46		; do NEXT (var)
.bb15									LAB_EVNM
.bb15	20 29 bb		jsr $bb29			JSR	LAB_EVEX		; evaluate expression
.bb18									LAB_CTNM
.bb18	18				clc					CLC				; destination is numeric
>bb19	24									.byte	$24			; makes next line BIT $38
.bb1a									LAB_CTST
.bb1a	38				sec					SEC				; required type is string
.bb1b									LAB_CKTM
.bb1b	24 11			bit $11				BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.bb1d	30 03			bmi $bb22			BMI	LAB_1ABA		; branch if data type is string
.bb1f	b0 03			bcs $bb24			BCS	LAB_1ABC		; if required type is string do type mismatch error
.bb21									LAB_1AB9
.bb21	60				rts					RTS
.bb22									LAB_1ABA
.bb22	b0 fd			bcs $bb21			BCS	LAB_1AB9		; exit if required type is string
.bb24									LAB_1ABC
.bb24	a2 18			ldx #$18			LDX	#$18			; error code $18 ("Type mismatch" error)
.bb26									LAB_1ABE
.bb26	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; do error #X, then warm start
.bb29									LAB_EVEX
.bb29	a6 77			ldx $77				LDX	Bpntrl		; get BASIC execute pointer low byte
.bb2b	d0 02			bne $bb2f			BNE	LAB_1AC7		; skip next if not zero
.bb2d	c6 78			dec $78				DEC	Bpntrh		; else decrement BASIC execute pointer high byte
.bb2f									LAB_1AC7
.bb2f	c6 77			dec $77				DEC	Bpntrl		; decrement BASIC execute pointer low byte
.bb31									LAB_EVEZ
.bb31	a9 00			lda #$00			LDA	#$00			; set null precedence (flag done)
.bb33									LAB_1ACC
.bb33	48				pha					PHA				; push precedence byte
.bb34	a9 02			lda #$02			LDA	#$02			; 2 bytes
.bb36	20 56 b1		jsr $b156			JSR	LAB_1212		; check room on stack for A bytes
.bb39	20 15 bc		jsr $bc15			JSR	LAB_GVAL		; get value from line
.bb3c	a9 00			lda #$00			LDA	#$00			; clear A
.bb3e	85 4f			sta $4f				STA	comp_f		; clear compare function flag
.bb40									LAB_1ADB
.bb40	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.bb43									LAB_1ADE
.bb43	38				sec					SEC				; set carry for subtract
.bb44	e9 c1			sbc #$c1			SBC	#TK_GT		; subtract token for > (lowest comparison function)
.bb46	90 17			bcc $bb5f			BCC	LAB_1AFA		; branch if < TK_GT
.bb48	c9 03			cmp #$03			CMP	#$03			; compare with ">" to "<" tokens
.bb4a	b0 13			bcs $bb5f			BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
.bb4c	c9 01			cmp #$01			CMP	#$01			; compare with token for =
.bb4e	2a				rol a				ROL				; *2, b0 = carry (=1 if token was = or <)
.bb4f	49 01			eor #$01			EOR	#$01			; toggle b0
.bb51	45 4f			eor $4f				EOR	comp_f		; EOR with compare function flag bits
.bb53	c5 4f			cmp $4f				CMP	comp_f		; compare with compare function flag
.bb55	90 67			bcc $bbbe			BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
.bb57	85 4f			sta $4f				STA	comp_f		; save new compare function flag
.bb59	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.bb5c	4c 43 bb		jmp $bb43			JMP	LAB_1ADE		; go do next character
.bb5f									LAB_1AFA
.bb5f	a6 4f			ldx $4f				LDX	comp_f		; get compare function flag
.bb61	d0 2c			bne $bb8f			BNE	LAB_1B2A		; branch if compare function
.bb63	b0 79			bcs $bbde			BCS	LAB_1B78		; go do functions
.bb65	69 0a			adc #$0a			ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
.bb67	90 75			bcc $bbde			BCC	LAB_1B78		; branch if < + operator
.bb69	d0 07			bne $bb72			BNE	LAB_1B0B		; branch if not + token
.bb6b	24 11			bit $11				BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.bb6d	10 03			bpl $bb72			BPL	LAB_1B0B		; branch if not string
.bb6f	4c 2e c3		jmp $c32e			JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
.bb72									LAB_1B0B
.bb72	85 25			sta $25				STA	ut1_pl		; save it
.bb74	0a				asl a				ASL				; *2
.bb75	65 25			adc $25				ADC	ut1_pl		; *3
.bb77	a8				tay					TAY				; copy to index
.bb78									LAB_1B13
.bb78	68				pla					PLA				; pull previous precedence
.bb79	d9 43 d3		cmp $d343,y			CMP	LAB_OPPT,Y		; compare with precedence byte
.bb7c	b0 65			bcs $bbe3			BCS	LAB_1B7D		; branch if A >=
.bb7e	20 18 bb		jsr $bb18			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.bb81									LAB_1B1C
.bb81	48				pha					PHA				; save precedence
.bb82									LAB_1B1D
.bb82	20 aa bb		jsr $bbaa			JSR	LAB_1B43		; get vector, execute function then continue evaluation
.bb85	68				pla					PLA				; restore precedence
.bb86	a4 4d			ldy $4d				LDY	prstk			; get precedence stacked flag
.bb88	10 19			bpl $bba3			BPL	LAB_1B3C		; branch if stacked values
.bb8a	aa				tax					TAX				; copy precedence (set flags)
.bb8b	f0 76			beq $bc03			BEQ	LAB_1B9D		; exit if done
.bb8d	d0 5d			bne $bbec			BNE	LAB_1B86		; else pop FAC2 and return, branch always
.bb8f									LAB_1B2A
.bb8f	26 11			rol $11				ROL	Dtypef		; shift data type flag into Cb
.bb91	8a				txa					TXA				; copy compare function flag
.bb92	85 11			sta $11				STA	Dtypef		; clear data type flag, X is 0xxx xxxx
.bb94	2a				rol a				ROL				; shift data type into compare function byte b0
.bb95	a6 77			ldx $77				LDX	Bpntrl		; get BASIC execute pointer low byte
.bb97	d0 02			bne $bb9b			BNE	LAB_1B34		; branch if no underflow
.bb99	c6 78			dec $78				DEC	Bpntrh		; else decrement BASIC execute pointer high byte
.bb9b									LAB_1B34
.bb9b	c6 77			dec $77				DEC	Bpntrl		; decrement BASIC execute pointer low byte
=12										TK_LT_PLUS	= TK_LT-TK_PLUS
.bb9d	a0 24			ldy #$24			LDY	#TK_LT_PLUS*3	; set offset to last operator entry
.bb9f	85 4f			sta $4f				STA	comp_f		; save new compare function flag
.bba1	d0 d5			bne $bb78			BNE	LAB_1B13		; branch always
.bba3									LAB_1B3C
.bba3	d9 43 d3		cmp $d343,y			CMP	LAB_OPPT,Y		;.compare with stacked function precedence
.bba6	b0 44			bcs $bbec			BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
.bba8	90 d7			bcc $bb81			BCC	LAB_1B1C		; branch always
.bbaa									LAB_1B43
.bbaa	b9 45 d3		lda $d345,y			LDA	LAB_OPPT+2,Y	; get function vector high byte
.bbad	48				pha					PHA				; onto stack
.bbae	b9 44 d3		lda $d344,y			LDA	LAB_OPPT+1,Y	; get function vector low byte
.bbb1	48				pha					PHA				; onto stack
.bbb2	20 c1 bb		jsr $bbc1			JSR	LAB_1B5B		; function will return here, then the next RTS will call
.bbb5	a5 4f			lda $4f				LDA	comp_f		; get compare function flag
.bbb7	48				pha					PHA				; push compare evaluation byte
.bbb8	b9 43 d3		lda $d343,y			LDA	LAB_OPPT,Y		; get precedence byte
.bbbb	4c 33 bb		jmp $bb33			JMP	LAB_1ACC		; continue evaluating expression
.bbbe									LAB_1B53
.bbbe	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; do syntax error then warm start
.bbc1									LAB_1B5B
.bbc1	68				pla					PLA				; get return addr low byte
.bbc2	85 25			sta $25				STA	ut1_pl		; save it
.bbc4	e6 25			inc $25				INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
.bbc6	68				pla					PLA				; get return addr high byte
.bbc7	85 26			sta $26				STA	ut1_ph		; save it
.bbc9	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.bbcb	48				pha					PHA				; push sign
.bbcc									LAB_1B66
.bbcc	20 33 c9		jsr $c933			JSR	LAB_27BA		; round FAC1
.bbcf	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.bbd1	48				pha					PHA				; push on stack
.bbd2	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.bbd4	48				pha					PHA				; push on stack
.bbd5	a5 61			lda $61				LDA	FAC1_1		; get FAC1 mantissa1
.bbd7	48				pha					PHA				; push on stack
.bbd8	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.bbda	48				pha					PHA				; push on stack
.bbdb	6c 25 00		jmp ($0025)			JMP	(ut1_pl)		; return, sort of
.bbde									LAB_1B78
.bbde	a0 ff			ldy #$ff			LDY	#$FF			; flag function
.bbe0	68				pla					PLA				; pull precedence byte
.bbe1									LAB_1B7B
.bbe1	f0 20			beq $bc03			BEQ	LAB_1B9D		; exit if done
.bbe3									LAB_1B7D
.bbe3	c9 64			cmp #$64			CMP	#$64			; compare previous precedence with $64
.bbe5	f0 03			beq $bbea			BEQ	LAB_1B84		; branch if was $64 (< function)
.bbe7	20 18 bb		jsr $bb18			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.bbea									LAB_1B84
.bbea	84 4d			sty $4d				STY	prstk			; save precedence stacked flag
.bbec									LAB_1B86
.bbec	68				pla					PLA				; pop byte
.bbed	4a				lsr a				LSR				; shift out comparison evaluation lowest bit
.bbee	85 16			sta $16				STA	Cflag			; save comparison evaluation flag
.bbf0	68				pla					PLA				; pop exponent
.bbf1	85 67			sta $67				STA	FAC2_e		; save FAC2 exponent
.bbf3	68				pla					PLA				; pop mantissa1
.bbf4	85 68			sta $68				STA	FAC2_1		; save FAC2 mantissa1
.bbf6	68				pla					PLA				; pop mantissa2
.bbf7	85 69			sta $69				STA	FAC2_2		; save FAC2 mantissa2
.bbf9	68				pla					PLA				; pop mantissa3
.bbfa	85 6a			sta $6a				STA	FAC2_3		; save FAC2 mantissa3
.bbfc	68				pla					PLA				; pop sign
.bbfd	85 6b			sta $6b				STA	FAC2_s		; save FAC2 sign (b7)
.bbff	45 64			eor $64				EOR	FAC1_s		; EOR FAC1 sign (b7)
.bc01	85 6c			sta $6c				STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.bc03									LAB_1B9D
.bc03	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.bc05	60				rts					RTS
.bc06									LAB_1BC1
.bc06	a5 77			lda $77				LDA	Bpntrl		; get BASIC execute pointer low byte
.bc08	a4 78			ldy $78				LDY	Bpntrh		; get BASIC execute pointer high byte
.bc0a	69 00			adc #$00			ADC	#$00			; add carry to low byte
.bc0c	90 01			bcc $bc0f			BCC	LAB_1BCA		; branch if no overflow
.bc0e	c8				iny					INY				; increment high byte
.bc0f									LAB_1BCA
.bc0f	20 9c c1		jsr $c19c			JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.bc12	4c 29 c5		jmp $c529			JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
.bc15									LAB_GVAL
.bc15	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.bc18	b0 03			bcs $bc1d			BCS	LAB_1BAC		; branch if not numeric character
.bc1a									LAB_1BA9
.bc1a	4c 00 ca		jmp $ca00			JMP	LAB_2887		; get FAC1 from string and return
.bc1d									LAB_1BAC
.bc1d	aa				tax					TAX				; set the flags
.bc1e	30 2f			bmi $bc4f			BMI	LAB_1BD0		; if -ve go test token values
.bc20	c9 24			cmp #$24			CMP	#'$'			; compare with "$"
.bc22	f0 f6			beq $bc1a			BEQ	LAB_1BA9		; branch if "$", hex number
.bc24	c9 25			cmp #$25			CMP	#'%'			; else compare with "%"
.bc26	f0 f2			beq $bc1a			BEQ	LAB_1BA9		; branch if "%", binary number
.bc28	c9 2e			cmp #$2e			CMP	#'.'			; compare with "."
.bc2a	f0 ee			beq $bc1a			BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
.bc2c	c9 22			cmp #$22			CMP	#$22			; compare with "
.bc2e	f0 d6			beq $bc06			BEQ	LAB_1BC1		; branch if open quote
.bc30	c9 28			cmp #$28			CMP	#'('			; compare with "("
.bc32	d0 4f			bne $bc83			BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
.bc34									LAB_1BF7
.bc34	20 31 bb		jsr $bb31			JSR	LAB_EVEZ		; evaluate expression, no decrement
.bc37									LAB_1BFB
.bc37	a9 29			lda #$29			LDA	#$29			; load A with ")"
.bc39									LAB_SCCA
.bc39	a0 00			ldy #$00			LDY	#$00			; clear index
.bc3b	d1 77			cmp ($77),y			CMP	(Bpntrl),Y		; check next byte is = A
.bc3d	d0 0b			bne $bc4a			BNE	LAB_SNER		; if not do syntax error then warm start
.bc3f	4c 70 00		jmp $0070			JMP	LAB_IGBY		; increment and scan memory then return
.bc42									LAB_1BFE
.bc42	a9 28			lda #$28			LDA	#$28			; load A with "("
.bc44	d0 f3			bne $bc39			BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.bc46									LAB_1C01
.bc46	a9 2c			lda #$2c			LDA	#$2C			; load A with ","
.bc48	d0 ef			bne $bc39			BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.bc4a									LAB_SNER
.bc4a	a2 02			ldx #$02			LDX	#$02			; error code $02 ("Syntax" error)
.bc4c	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; do error #X, then warm start
.bc4f									LAB_1BD0
.bc4f	c9 b8			cmp #$b8			CMP	#TK_MINUS		; compare with token for -
.bc51	f0 29			beq $bc7c			BEQ	LAB_1C11		; branch if - token (do set-up for functions)
.bc53	c9 b7			cmp #$b7			CMP	#TK_PLUS		; compare with token for +
.bc55	f0 be			beq $bc15			BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
.bc57	c9 b2			cmp #$b2			CMP	#TK_NOT		; compare with token for NOT
.bc59	d0 13			bne $bc6e			BNE	LAB_1BE7		; branch if not token for NOT
=11										TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
.bc5b	a0 21			ldy #$21			LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
.bc5d	d0 1f			bne $bc7e			BNE	LAB_1C13		; do set-up for function then execute (branch always)
.bc5f									LAB_EQUAL
.bc5f	20 f0 be		jsr $bef0			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.bc62	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.bc64	49 ff			eor #$ff			EOR	#$FF			; invert it
.bc66	a8				tay					TAY				; copy it
.bc67	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.bc69	49 ff			eor #$ff			EOR	#$FF			; invert it
.bc6b	4c a5 c0		jmp $c0a5			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.bc6e									LAB_1BE7
.bc6e	c9 af			cmp #$af			CMP	#TK_FN		; compare with token for FN
.bc70	d0 03			bne $bc75			BNE	LAB_1BEE		; branch if not token for FN
.bc72	4c 0c c1		jmp $c10c			JMP	LAB_201E		; go evaluate FNx
.bc75									LAB_1BEE
.bc75	e9 c4			sbc #$c4			SBC	#TK_SGN		; subtract with token for SGN
.bc77	b0 1b			bcs $bc94			BCS	LAB_1C27		; if a function token go do it
.bc79	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; else do syntax error
.bc7c									LAB_1C11
=10										TK_GT_PLUS	= TK_GT-TK_PLUS
.bc7c	a0 1e			ldy #$1e			LDY	#TK_GT_PLUS*3	; set offset from base to > operator
.bc7e									LAB_1C13
.bc7e	68				pla					PLA				; dump return address low byte
.bc7f	68				pla					PLA				; dump return address high byte
.bc80	4c 82 bb		jmp $bb82			JMP	LAB_1B1D		; execute function then continue evaluation
.bc83									LAB_1C18
.bc83	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get (var) address
.bc86	85 62			sta $62				STA	FAC1_2		; save address low byte in FAC1 mantissa2
.bc88	84 63			sty $63				STY	FAC1_3		; save address high byte in FAC1 mantissa3
.bc8a	a6 11			ldx $11				LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.bc8c	30 03			bmi $bc91			BMI	LAB_1C25	; if string then return (does RTS)
.bc8e									LAB_1C24
.bc8e	4c d7 c8		jmp $c8d7			JMP	LAB_UFAC	; unpack memory (AY) into FAC1
.bc91									LAB_1C25
.bc91	46 6d			lsr $6d				LSR	FAC1_r		; clear bit 7 (<$80) = do not round up
.bc93	60				rts					RTS
.bc94									LAB_1C27
.bc94	0a				asl a				ASL				; *2 (2 bytes per function address)
.bc95	a8				tay					TAY				; copy to index
.bc96	b9 fe d2		lda $d2fe,y			LDA	LAB_FTBM,Y		; get function jump vector high byte
.bc99	48				pha					PHA				; push functions jump vector high byte
.bc9a	b9 fd d2		lda $d2fd,y			LDA	LAB_FTBL,Y		; get function jump vector low byte
.bc9d	48				pha					PHA				; push functions jump vector low byte
.bc9e	b9 b8 d2		lda $d2b8,y			LDA	LAB_FTPM,Y		; get function pre process vector high byte
.bca1	f0 05			beq $bca8			BEQ	LAB_1C56		; skip pre process if null vector
.bca3	48				pha					PHA				; push functions pre process vector high byte
.bca4	b9 b7 d2		lda $d2b7,y			LDA	LAB_FTPL,Y		; get function pre process vector low byte
.bca7	48				pha					PHA				; push functions pre process vector low byte
.bca8									LAB_1C56
.bca8	60				rts					RTS				; do function, or pre process, call
.bca9									LAB_PPFS
.bca9	20 34 bc		jsr $bc34			JSR	LAB_1BF7		; process expression in parenthesis
.bcac	4c 1a bb		jmp $bb1a			JMP	LAB_CTST		; check if source is string then do function,
.bcaf									LAB_PPFN
.bcaf	20 34 bc		jsr $bc34			JSR	LAB_1BF7		; process expression in parenthesis
.bcb2	4c 18 bb		jmp $bb18			JMP	LAB_CTNM		; check if source is numeric then do function,
.bcb5									LAB_PPBI
.bcb5	46 11			lsr $11				LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.bcb7	4c 70 00		jmp $0070			JMP	LAB_IGBY		; increment and scan memory then do function
.bcba									LAB_LRMS
.bcba	20 31 bb		jsr $bb31			JSR	LAB_EVEZ		; evaluate (should be string) expression
.bcbd	20 46 bc		jsr $bc46			JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
.bcc0	20 1a bb		jsr $bb1a			JSR	LAB_CTST		; check if source is string, else do type mismatch
.bcc3	68				pla					PLA				; get function jump vector low byte
.bcc4	aa				tax					TAX				; save functions jump vector low byte
.bcc5	68				pla					PLA				; get function jump vector high byte
.bcc6	a8				tay					TAY				; save functions jump vector high byte
.bcc7	a5 63			lda $63				LDA	des_ph		; get descriptor pointer high byte
.bcc9	48				pha					PHA				; push string pointer high byte
.bcca	a5 62			lda $62				LDA	des_pl		; get descriptor pointer low byte
.bccc	48				pha					PHA				; push string pointer low byte
.bccd	98				tya					TYA				; get function jump vector high byte back
.bcce	48				pha					PHA				; save functions jump vector high byte
.bccf	8a				txa					TXA				; get function jump vector low byte back
.bcd0	48				pha					PHA				; save functions jump vector low byte
.bcd1	20 e6 c4		jsr $c4e6			JSR	LAB_GTBY		; get byte parameter
.bcd4	8a				txa					TXA				; copy byte parameter to A
.bcd5	60				rts					RTS				; go do function
.bcd6									LAB_BHSS
.bcd6	20 31 bb		jsr $bb31			JSR	LAB_EVEZ		; process expression
.bcd9	20 18 bb		jsr $bb18			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.bcdc	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.bcde	c9 98			cmp #$98			CMP	#$98			; compare with exponent = 2^24
.bce0	b0 20			bcs $bd02			BCS	LAB_BHER		; branch if n>=2^24 (is too big)
.bce2	20 aa c9		jsr $c9aa			JSR	LAB_2831		; convert FAC1 floating-to-fixed
.bce5	a2 02			ldx #$02			LDX	#$02			; 3 bytes to do
.bce7									LAB_CFAC
.bce7	b5 61			lda $61,x			LDA	FAC1_1,X		; get byte from FAC1
.bce9	95 0a			sta $0a,x			STA	nums_1,X		; save byte to temp
.bceb	ca				dex					DEX				; decrement index
.bcec	10 f9			bpl $bce7			BPL	LAB_CFAC		; copy FAC1 mantissa to temp
.bcee	20 76 00		jsr $0076			JSR	LAB_GBYT		; get next BASIC byte
.bcf1	a2 00			ldx #$00			LDX	#$00			; set default to no leading "0"s
.bcf3	c9 29			cmp #$29			CMP	#')'			; compare with close bracket
.bcf5	f0 0a			beq $bd01			BEQ	LAB_1C54		; if ")" go do rest of function
.bcf7	20 38 c5		jsr $c538			JSR	LAB_SCGB		; scan for "," and get byte
.bcfa	20 76 00		jsr $0076			JSR	LAB_GBYT		; get last byte back
.bcfd	c9 29			cmp #$29			CMP	#')'			; is next character )
.bcff	d0 01			bne $bd02			BNE	LAB_BHER		; if not ")" go do error
.bd01									LAB_1C54
.bd01	60				rts					RTS				; else do function
.bd02									LAB_BHER
.bd02	4c 73 bf		jmp $bf73			JMP	LAB_FCER		; do function call error then warm start
.bd05									LAB_EOR
.bd05	20 2c bd		jsr $bd2c			JSR	GetFirst		; get first integer expression (no sign check)
.bd08	45 0d			eor $0d				EOR	XOAw_l		; EOR with expression 1 low byte
.bd0a	a8				tay					TAY				; save in Y
.bd0b	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.bd0d	45 0e			eor $0e				EOR	XOAw_h		; EOR with expression 1 high byte
.bd0f	4c a5 c0		jmp $c0a5			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.bd12									LAB_OR
.bd12	20 2c bd		jsr $bd2c			JSR	GetFirst		; get first integer expression (no sign check)
.bd15	05 0d			ora $0d				ORA	XOAw_l		; OR with expression 1 low byte
.bd17	a8				tay					TAY				; save in Y
.bd18	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.bd1a	05 0e			ora $0e				ORA	XOAw_h		; OR with expression 1 high byte
.bd1c	4c a5 c0		jmp $c0a5			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.bd1f									LAB_AND
.bd1f	20 2c bd		jsr $bd2c			JSR	GetFirst		; get first integer expression (no sign check)
.bd22	25 0d			and $0d				AND	XOAw_l		; AND with expression 1 low byte
.bd24	a8				tay					TAY				; save in Y
.bd25	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.bd27	25 0e			and $0e				AND	XOAw_h		; AND with expression 1 high byte
.bd29	4c a5 c0		jmp $c0a5			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.bd2c									GetFirst
.bd2c	20 f0 be		jsr $bef0			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.bd2f	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.bd31	85 0e			sta $0e				STA	XOAw_h		; save it
.bd33	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.bd35	85 0d			sta $0d				STA	XOAw_l		; save it
.bd37	20 1d c6		jsr $c61d			JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
.bd3a	20 f0 be		jsr $bef0			JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.bd3d	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.bd3f									LAB_1C95
.bd3f	60				rts					RTS
.bd40									LAB_LTHAN
.bd40	20 1b bb		jsr $bb1b			JSR	LAB_CKTM		; type match check, set C for string
.bd43	b0 13			bcs $bd58			BCS	LAB_1CAE		; branch if string
.bd45	a5 6b			lda $6b				LDA	FAC2_s		; get FAC2 sign (b7)
.bd47	09 7f			ora #$7f			ORA	#$7F			; set all non sign bits
.bd49	25 68			and $68				AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
.bd4b	85 68			sta $68				STA	FAC2_1		; save FAC2 mantissa1
.bd4d	a9 67			lda #$67			LDA	#<FAC2_e		; set pointer low byte to FAC2
.bd4f	a0 00			ldy #$00			LDY	#>FAC2_e		; set pointer high byte to FAC2
.bd51	20 71 c9		jsr $c971			JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
.bd54	aa				tax					TAX				; copy result
.bd55	4c 89 bd		jmp $bd89			JMP	LAB_1CE1		; go evaluate result
.bd58									LAB_1CAE
.bd58	46 11			lsr $11				LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.bd5a	c6 4f			dec $4f				DEC	comp_f		; clear < bit in compare function flag
.bd5c	20 98 c3		jsr $c398			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.bd5f	85 60			sta $60				STA	str_ln		; save length
.bd61	86 61			stx $61				STX	str_pl		; save string pointer low byte
.bd63	84 62			sty $62				STY	str_ph		; save string pointer high byte
.bd65	a5 69			lda $69				LDA	FAC2_2		; get descriptor pointer low byte
.bd67	a4 6a			ldy $6a				LDY	FAC2_3		; get descriptor pointer high byte
.bd69	20 9c c3		jsr $c39c			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.bd6c	86 69			stx $69				STX	FAC2_2		; save string pointer low byte
.bd6e	84 6a			sty $6a				STY	FAC2_3		; save string pointer high byte
.bd70	aa				tax					TAX				; copy length
.bd71	38				sec					SEC				; set carry for subtract
.bd72	e5 60			sbc $60				SBC	str_ln		; subtract string 1 length
.bd74	f0 08			beq $bd7e			BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
.bd76	a9 01			lda #$01			LDA	#$01			; set str 1 length > string 2 length
.bd78	90 04			bcc $bd7e			BCC	LAB_1CD6		; branch if so
.bd7a	a6 60			ldx $60				LDX	str_ln		; get string 1 length
.bd7c	a9 ff			lda #$ff			LDA	#$FF			; set str 1 length < string 2 length
.bd7e									LAB_1CD6
.bd7e	85 64			sta $64				STA	FAC1_s		; save length compare
.bd80	a0 ff			ldy #$ff			LDY	#$FF			; set index
.bd82	e8				inx					INX				; adjust for loop
.bd83									LAB_1CDB
.bd83	c8				iny					INY				; increment index
.bd84	ca				dex					DEX				; decrement count
.bd85	d0 07			bne $bd8e			BNE	LAB_1CE6		; branch if still bytes to do
.bd87	a6 64			ldx $64				LDX	FAC1_s		; get length compare back
.bd89									LAB_1CE1
.bd89	30 0f			bmi $bd9a			BMI	LAB_1CF2		; branch if str 1 < str 2
.bd8b	18				clc					CLC				; flag str 1 <= str 2
.bd8c	90 0c			bcc $bd9a			BCC	LAB_1CF2		; go evaluate result
.bd8e									LAB_1CE6
.bd8e	b1 69			lda ($69),y			LDA	(FAC2_2),Y		; get string 2 byte
.bd90	d1 61			cmp ($61),y			CMP	(FAC1_1),Y		; compare with string 1 byte
.bd92	f0 ef			beq $bd83			BEQ	LAB_1CDB		; loop if bytes =
.bd94	a2 ff			ldx #$ff			LDX	#$FF			; set str 1 < string 2
.bd96	b0 02			bcs $bd9a			BCS	LAB_1CF2		; branch if so
.bd98	a2 01			ldx #$01			LDX	#$01			;  set str 1 > string 2
.bd9a									LAB_1CF2
.bd9a	e8				inx					INX				; x = 0, 1 or 2
.bd9b	8a				txa					TXA				; copy to A
.bd9c	2a				rol a				ROL				; *2 (1, 2 or 4)
.bd9d	25 16			and $16				AND	Cflag			; AND with comparison evaluation flag
.bd9f	f0 02			beq $bda3			BEQ	LAB_1CFB		; branch if 0 (compare is false)
.bda1	a9 ff			lda #$ff			LDA	#$FF			; else set result true
.bda3									LAB_1CFB
.bda3	4c 54 c9		jmp $c954			JMP	LAB_27DB		; save A as integer byte and return
.bda6									LAB_1CFE
.bda6	20 46 bc		jsr $bc46			JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
.bda9									LAB_DIM
.bda9	aa				tax					TAX				; copy "DIM" flag to X
.bdaa	20 f9 bd		jsr $bdf9			JSR	LAB_1D10		; search for variable
.bdad	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.bdb0	d0 f4			bne $bda6			BNE	LAB_1CFE		; scan for "," and loop if not null
.bdb2	60				rts					RTS
.bdb3									LAB_LSHIFT
.bdb3	20 e9 bd		jsr $bde9			JSR	GetPair		; get integer expression and byte (no sign check)
.bdb6	a5 62			lda $62				LDA	FAC1_2		; get expression high byte
.bdb8	a6 2c			ldx $2c				LDX	TempB			; get shift count
.bdba	f0 22			beq $bdde			BEQ	NoShift		; branch if zero
.bdbc	e0 10			cpx #$10			CPX	#$10			; compare bit count with 16d
.bdbe	b0 23			bcs $bde3			BCS	TooBig		; branch if >=
.bdc0									Ls_loop
.bdc0	06 63			asl $63				ASL	FAC1_3		; shift low byte
.bdc2	2a				rol a				ROL				; shift high byte
.bdc3	ca				dex					DEX				; decrement bit count
.bdc4	d0 fa			bne $bdc0			BNE	Ls_loop		; loop if shift not complete
.bdc6	a4 63			ldy $63				LDY	FAC1_3		; get expression low byte
.bdc8	4c a5 c0		jmp $c0a5			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.bdcb									LAB_RSHIFT
.bdcb	20 e9 bd		jsr $bde9			JSR	GetPair		; get integer expression and byte (no sign check)
.bdce	a5 62			lda $62				LDA	FAC1_2		; get expression high byte
.bdd0	a6 2c			ldx $2c				LDX	TempB			; get shift count
.bdd2	f0 0a			beq $bdde			BEQ	NoShift		; branch if zero
.bdd4	e0 10			cpx #$10			CPX	#$10			; compare bit count with 16d
.bdd6	b0 0b			bcs $bde3			BCS	TooBig		; branch if >=
.bdd8									Rs_loop
.bdd8	4a				lsr a				LSR				; shift high byte
.bdd9	66 63			ror $63				ROR	FAC1_3		; shift low byte
.bddb	ca				dex					DEX				; decrement bit count
.bddc	d0 fa			bne $bdd8			BNE	Rs_loop		; loop if shift not complete
.bdde									NoShift
.bdde	a4 63			ldy $63				LDY	FAC1_3		; get expression low byte
.bde0	4c a5 c0		jmp $c0a5			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.bde3									TooBig
.bde3	a9 00			lda #$00			LDA	#$00			; clear high byte
.bde5	a8				tay					TAY				; copy to low byte
.bde6	4c a5 c0		jmp $c0a5			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.bde9									GetPair
.bde9	20 e9 c4		jsr $c4e9			JSR	LAB_EVBY		; evaluate byte expression, result in X
.bdec	86 2c			stx $2c				STX	TempB			; save it
.bdee	20 1d c6		jsr $c61d			JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
.bdf1	4c f0 be		jmp $bef0			JMP	LAB_EVIR		; evaluate integer expression (no sign check)
.bdf4									LAB_GVAR
.bdf4	a2 00			ldx #$00			LDX	#$00			; set DIM flag = $00
.bdf6	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory (1st character)
.bdf9									LAB_1D10
.bdf9	86 10			stx $10				STX	Defdim		; save DIM flag
.bdfb									LAB_1D12
.bdfb	85 47			sta $47				STA	Varnm1		; save 1st character
.bdfd	29 7f			and #$7f			AND	#$7F			; clear FN flag bit
.bdff	20 68 be		jsr $be68			JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.be02	b0 03			bcs $be07			BCS	LAB_1D1F		; branch if ok
.be04	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; else syntax error then warm start
.be07									LAB_1D1F
.be07	a2 00			ldx #$00			LDX	#$00			; clear 2nd character temp
.be09	86 11			stx $11				STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
.be0b	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory (2nd character)
.be0e	90 05			bcc $be15			BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
.be10	20 68 be		jsr $be68			JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.be13	90 0b			bcc $be20			BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
.be15									LAB_1D2D
.be15	aa				tax					TAX				; copy 2nd character
.be16									LAB_1D2E
.be16	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory (3rd character)
.be19	90 fb			bcc $be16			BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
.be1b	20 68 be		jsr $be68			JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.be1e	b0 f6			bcs $be16			BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
.be20									LAB_1D38
.be20	c9 24			cmp #$24			CMP	#'$'			; compare with "$"
.be22	d0 0b			bne $be2f			BNE	LAB_1D47		; branch if not string
.be24	a9 ff			lda #$ff			LDA	#$FF			; set data type = string
.be26	85 11			sta $11				STA	Dtypef		; set data type flag, $FF=string, $00=numeric
.be28	8a				txa					TXA				; get 2nd character back
.be29	09 80			ora #$80			ORA	#$80			; set top bit (indicate string var)
.be2b	aa				tax					TAX				; copy back to 2nd character temp
.be2c	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.be2f									LAB_1D47
.be2f	86 48			stx $48				STX	Varnm2		; save 2nd character
.be31	05 14			ora $14				ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
.be33	c9 28			cmp #$28			CMP	#'('			; compare with "("
.be35	d0 03			bne $be3a			BNE	LAB_1D53		; branch if not "("
.be37	4c 02 bf		jmp $bf02			JMP	LAB_1E17		; go find, or make, array
.be3a									LAB_1D53
.be3a	a9 00			lda #$00			LDA	#$00			; clear A
.be3c	85 14			sta $14				STA	Sufnxf		; clear subscript/FNX flag
.be3e	a5 2f			lda $2f				LDA	Svarl			; get start of vars low byte
.be40	a6 30			ldx $30				LDX	Svarh			; get start of vars high byte
.be42	a0 00			ldy #$00			LDY	#$00			; clear index
.be44									LAB_1D5D
.be44	86 5f			stx $5f				STX	Vrschh		; save search address high byte
.be46									LAB_1D5F
.be46	85 5e			sta $5e				STA	Vrschl		; save search address low byte
.be48	e4 32			cpx $32				CPX	Sarryh		; compare high address with var space end
.be4a	d0 04			bne $be50			BNE	LAB_1D69		; skip next compare if <>
.be4c	c5 31			cmp $31				CMP	Sarryl		; compare low address with var space end
.be4e	f0 2c			beq $be7c			BEQ	LAB_1D8B		; if not found go make new var
.be50									LAB_1D69
.be50	a5 47			lda $47				LDA	Varnm1		; get 1st character of var to find
.be52	d1 5e			cmp ($5e),y			CMP	(Vrschl),Y		; compare with variable name 1st character
.be54	d0 08			bne $be5e			BNE	LAB_1D77		; branch if no match
.be56	a5 48			lda $48				LDA	Varnm2		; get 2nd character of var to find
.be58	c8				iny					INY				; index to point to variable name 2nd character
.be59	d1 5e			cmp ($5e),y			CMP	(Vrschl),Y		; compare with variable name 2nd character
.be5b	f0 69			beq $bec6			BEQ	LAB_1DD7		; branch if match (found var)
.be5d	88				dey					DEY				; else decrement index (now = $00)
.be5e									LAB_1D77
.be5e	18				clc					CLC				; clear carry for add
.be5f	a5 5e			lda $5e				LDA	Vrschl		; get search address low byte
.be61	69 06			adc #$06			ADC	#$06			; +6 (offset to next var name)
.be63	90 e1			bcc $be46			BCC	LAB_1D5F		; loop if no overflow to high byte
.be65	e8				inx					INX				; else increment high byte
.be66	d0 dc			bne $be44			BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
.be68									LAB_CASC
.be68	c9 61			cmp #$61			CMP	#'a'			; compare with "a"
.be6a	b0 0a			bcs $be76			BCS	LAB_1D83		; go check <"z"+1
.be6c									LAB_1D82
.be6c	c9 41			cmp #$41			CMP	#'A'			; compare with "A"
.be6e	90 05			bcc $be75			BCC	LAB_1D8A		; exit if less
.be70	e9 5b			sbc #$5b			SBC	#$5B			; subtract "Z"+1
.be72	38				sec					SEC				; set carry
.be73	e9 a5			sbc #$a5			SBC	#$A5			; subtract $A5 (restore byte)
.be75									LAB_1D8A
.be75	60				rts					RTS
.be76									LAB_1D83
.be76	e9 7b			sbc #$7b			SBC	#$7B			; subtract "z"+1
.be78	38				sec					SEC				; set carry
.be79	e9 85			sbc #$85			SBC	#$85			; subtract $85 (restore byte)
.be7b	60				rts					RTS
.be7c									LAB_1D8B
.be7c	68				pla					PLA				; pop return address low byte
.be7d	48				pha					PHA				; push return address low byte
=$bc85									LAB_1C18p2	= LAB_1C18+2
.be7e	c9 85			cmp #$85			CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
.be80	d0 05			bne $be87			BNE	LAB_1D98		; if not get (var) go create new var
.be82	a9 39			lda #$39			LDA	#<LAB_1D96		; low byte point to $00,$00
.be84	a0 d2			ldy #$d2			LDY	#>LAB_1D96		; high byte point to $00,$00
.be86	60				rts					RTS
.be87									LAB_1D98
.be87	a5 31			lda $31				LDA	Sarryl		; get var mem end low byte
.be89	a4 32			ldy $32				LDY	Sarryh		; get var mem end high byte
.be8b	85 5e			sta $5e				STA	Ostrtl		; save old block start low byte
.be8d	84 5f			sty $5f				STY	Ostrth		; save old block start high byte
.be8f	a5 33			lda $33				LDA	Earryl		; get array mem end low byte
.be91	a4 34			ldy $34				LDY	Earryh		; get array mem end high byte
.be93	85 5b			sta $5b				STA	Obendl		; save old block end low byte
.be95	84 5c			sty $5c				STY	Obendh		; save old block end high byte
.be97	18				clc					CLC				; clear carry for add
.be98	69 06			adc #$06			ADC	#$06			; +6 (space for one var)
.be9a	90 01			bcc $be9d			BCC	LAB_1DAE		; branch if no overflow to high byte
.be9c	c8				iny					INY				; else increment high byte
.be9d									LAB_1DAE
.be9d	85 59			sta $59				STA	Nbendl		; set new block end low byte
.be9f	84 5a			sty $5a				STY	Nbendh		; set new block end high byte
.bea1	20 14 b1		jsr $b114			JSR	LAB_11CF		; open up space in memory
.bea4	a5 59			lda $59				LDA	Nbendl		; get new start low byte
.bea6	a4 5a			ldy $5a				LDY	Nbendh		; get new start high byte (-$100)
.bea8	c8				iny					INY				; correct high byte
.bea9	85 31			sta $31				STA	Sarryl		; save new var mem end low byte
.beab	84 32			sty $32				STY	Sarryh		; save new var mem end high byte
.bead	a0 00			ldy #$00			LDY	#$00			; clear index
.beaf	a5 47			lda $47				LDA	Varnm1		; get var name 1st character
.beb1	91 5e			sta ($5e),y			STA	(Vrschl),Y		; save var name 1st character
.beb3	c8				iny					INY				; increment index
.beb4	a5 48			lda $48				LDA	Varnm2		; get var name 2nd character
.beb6	91 5e			sta ($5e),y			STA	(Vrschl),Y		; save var name 2nd character
.beb8	a9 00			lda #$00			LDA	#$00			; clear A
.beba	c8				iny					INY				; increment index
.bebb	91 5e			sta ($5e),y			STA	(Vrschl),Y		; initialise var byte
.bebd	c8				iny					INY				; increment index
.bebe	91 5e			sta ($5e),y			STA	(Vrschl),Y		; initialise var byte
.bec0	c8				iny					INY				; increment index
.bec1	91 5e			sta ($5e),y			STA	(Vrschl),Y		; initialise var byte
.bec3	c8				iny					INY				; increment index
.bec4	91 5e			sta ($5e),y			STA	(Vrschl),Y		; initialise var byte
.bec6									LAB_1DD7
.bec6	a5 5e			lda $5e				LDA	Vrschl		; get var address low byte
.bec8	18				clc					CLC				; clear carry for add
.bec9	69 02			adc #$02			ADC	#$02			; +2 (offset past var name bytes)
.becb	a4 5f			ldy $5f				LDY	Vrschh		; get var address high byte
.becd	90 01			bcc $bed0			BCC	LAB_1DE1		; branch if no overflow from add
.becf	c8				iny					INY				; else increment high byte
.bed0									LAB_1DE1
.bed0	85 49			sta $49				STA	Cvaral		; save current var address low byte
.bed2	84 4a			sty $4a				STY	Cvarah		; save current var address high byte
.bed4	60				rts					RTS
.bed5									LAB_1DE6
.bed5	a5 0f			lda $0f				LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
.bed7	0a				asl a				ASL				; *2 (also clears the carry !)
.bed8	69 05			adc #$05			ADC	#$05			; +5 (result is 7, 9 or 11 here)
.beda	65 5e			adc $5e				ADC	Astrtl		; add array start pointer low byte
.bedc	a4 5f			ldy $5f				LDY	Astrth		; get array pointer high byte
.bede	90 01			bcc $bee1			BCC	LAB_1DF2		; branch if no overflow
.bee0	c8				iny					INY				; else increment high byte
.bee1									LAB_1DF2
.bee1	85 59			sta $59				STA	Adatal		; save array data pointer low byte
.bee3	84 5a			sty $5a				STY	Adatah		; save array data pointer high byte
.bee5	60				rts					RTS
.bee6									LAB_EVIN
.bee6	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.bee9	20 15 bb		jsr $bb15			JSR	LAB_EVNM		; evaluate expression and check is numeric,
.beec									LAB_EVPI
.beec	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.beee	30 0d			bmi $befd			BMI	LAB_1E12		; do function call error if -ve
.bef0									LAB_EVIR
.bef0	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.bef2	c9 90			cmp #$90			CMP	#$90			; compare with exponent = 2^16 (n>2^15)
.bef4	90 09			bcc $beff			BCC	LAB_1E14		; branch if n<2^16 (is ok)
.bef6	a9 40			lda #$40			LDA	#<LAB_1DF7		; set pointer low byte to -32768
.bef8	a0 d2			ldy #$d2			LDY	#>LAB_1DF7		; set pointer high byte to -32768
.befa	20 71 c9		jsr $c971			JSR	LAB_27F8		; compare FAC1 with (AY)
.befd									LAB_1E12
.befd	d0 74			bne $bf73			BNE	LAB_FCER		; if <> do function call error then warm start
.beff									LAB_1E14
.beff	4c aa c9		jmp $c9aa			JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
.bf02									LAB_1E17
.bf02	a5 10			lda $10				LDA	Defdim		; get DIM flag
.bf04	48				pha					PHA				; push it
.bf05	a5 11			lda $11				LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.bf07	48				pha					PHA				; push it
.bf08	a0 00			ldy #$00			LDY	#$00			; clear dimensions count
.bf0a									LAB_1E1F
.bf0a	98				tya					TYA				; copy dimensions count
.bf0b	48				pha					PHA				; save it
.bf0c	a5 48			lda $48				LDA	Varnm2		; get array name 2nd byte
.bf0e	48				pha					PHA				; save it
.bf0f	a5 47			lda $47				LDA	Varnm1		; get array name 1st byte
.bf11	48				pha					PHA				; save it
.bf12	20 e6 be		jsr $bee6			JSR	LAB_EVIN		; evaluate integer expression
.bf15	68				pla					PLA				; pull array name 1st byte
.bf16	85 47			sta $47				STA	Varnm1		; restore array name 1st byte
.bf18	68				pla					PLA				; pull array name 2nd byte
.bf19	85 48			sta $48				STA	Varnm2		; restore array name 2nd byte
.bf1b	68				pla					PLA				; pull dimensions count
.bf1c	a8				tay					TAY				; restore it
.bf1d	ba				tsx					TSX				; copy stack pointer
.bf1e	bd 02 01		lda $0102,x			LDA	LAB_STAK+2,X	; get DIM flag
.bf21	48				pha					PHA				; push it
.bf22	bd 01 01		lda $0101,x			LDA	LAB_STAK+1,X	; get data type flag
.bf25	48				pha					PHA				; push it
.bf26	a5 62			lda $62				LDA	FAC1_2		; get this dimension size high byte
.bf28	9d 02 01		sta $0102,x			STA	LAB_STAK+2,X	; stack before flag bytes
.bf2b	a5 63			lda $63				LDA	FAC1_3		; get this dimension size low byte
.bf2d	9d 01 01		sta $0101,x			STA	LAB_STAK+1,X	; stack before flag bytes
.bf30	c8				iny					INY				; increment dimensions count
.bf31	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.bf34	c9 2c			cmp #$2c			CMP	#','			; compare with ","
.bf36	f0 d2			beq $bf0a			BEQ	LAB_1E1F		; if found go do next dimension
.bf38	84 0f			sty $0f				STY	Dimcnt		; store dimensions count
.bf3a	20 37 bc		jsr $bc37			JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.bf3d	68				pla					PLA				; pull data type flag
.bf3e	85 11			sta $11				STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
.bf40	68				pla					PLA				; pull DIM flag
.bf41	85 10			sta $10				STA	Defdim		; restore DIM flag
.bf43	a6 31			ldx $31				LDX	Sarryl		; get array mem start low byte
.bf45	a5 32			lda $32				LDA	Sarryh		; get array mem start high byte
.bf47									LAB_1E5C
.bf47	86 5e			stx $5e				STX	Astrtl		; save as array start pointer low byte
.bf49	85 5f			sta $5f				STA	Astrth		; save as array start pointer high byte
.bf4b	c5 34			cmp $34				CMP	Earryh		; compare with array mem end high byte
.bf4d	d0 04			bne $bf53			BNE	LAB_1E68		; branch if not reached array mem end
.bf4f	e4 33			cpx $33				CPX	Earryl		; else compare with array mem end low byte
.bf51	f0 39			beq $bf8c			BEQ	LAB_1EA1		; go build array if not found
.bf53									LAB_1E68
.bf53	a0 00			ldy #$00			LDY	#$00			; clear index
.bf55	b1 5e			lda ($5e),y			LDA	(Astrtl),Y		; get array name first byte
.bf57	c8				iny					INY				; increment index to second name byte
.bf58	c5 47			cmp $47				CMP	Varnm1		; compare with this array name first byte
.bf5a	d0 06			bne $bf62			BNE	LAB_1E77		; branch if no match
.bf5c	a5 48			lda $48				LDA	Varnm2		; else get this array name second byte
.bf5e	d1 5e			cmp ($5e),y			CMP	(Astrtl),Y		; compare with array name second byte
.bf60	f0 16			beq $bf78			BEQ	LAB_1E8D		; array found so branch
.bf62									LAB_1E77
.bf62	c8				iny					INY				; increment index
.bf63	b1 5e			lda ($5e),y			LDA	(Astrtl),Y		; get array size low byte
.bf65	18				clc					CLC				; clear carry for add
.bf66	65 5e			adc $5e				ADC	Astrtl		; add array start pointer low byte
.bf68	aa				tax					TAX				; copy low byte to X
.bf69	c8				iny					INY				; increment index
.bf6a	b1 5e			lda ($5e),y			LDA	(Astrtl),Y		; get array size high byte
.bf6c	65 5f			adc $5f				ADC	Astrth		; add array mem pointer high byte
.bf6e	90 d7			bcc $bf47			BCC	LAB_1E5C		; if no overflow go check next array
.bf70									LAB_1E85
.bf70	a2 10			ldx #$10			LDX	#$10			; error code $10 ("Array bounds" error)
>bf72	2c									.byte	$2C			; makes next bit BIT LAB_08A2
.bf73									LAB_FCER
.bf73	a2 08			ldx #$08			LDX	#$08			; error code $08 ("Function call" error)
.bf75									LAB_1E8A
.bf75	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; do error #X, then warm start
.bf78									LAB_1E8D
.bf78	a2 12			ldx #$12			LDX	#$12			; set error $12 ("Double dimension" error)
.bf7a	a5 10			lda $10				LDA	Defdim		; get DIM flag
.bf7c	d0 f7			bne $bf75			BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
.bf7e	20 d5 be		jsr $bed5			JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
.bf81	a5 0f			lda $0f				LDA	Dimcnt		; get dimensions count
.bf83	a0 04			ldy #$04			LDY	#$04			; set index to array's # of dimensions
.bf85	d1 5e			cmp ($5e),y			CMP	(Astrtl),Y		; compare with no of dimensions
.bf87	d0 e7			bne $bf70			BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
.bf89	4c 0f c0		jmp $c00f			JMP	LAB_1F28		; found array so go get element
.bf8c									LAB_1EA1
.bf8c	20 d5 be		jsr $bed5			JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
.bf8f	20 5e b1		jsr $b15e			JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.bf92	a0 00			ldy #$00			LDY	#$00			; clear Y (don't need to clear A)
.bf94	84 6f			sty $6f				STY	Aspth			; clear array data size high byte
.bf96	a5 47			lda $47				LDA	Varnm1		; get variable name 1st byte
.bf98	91 5e			sta ($5e),y			STA	(Astrtl),Y		; save array name 1st byte
.bf9a	c8				iny					INY				; increment index
.bf9b	a5 48			lda $48				LDA	Varnm2		; get variable name 2nd byte
.bf9d	91 5e			sta ($5e),y			STA	(Astrtl),Y		; save array name 2nd byte
.bf9f	a5 0f			lda $0f				LDA	Dimcnt		; get dimensions count
.bfa1	a0 04			ldy #$04			LDY	#$04			; index to dimension count
.bfa3	84 6e			sty $6e				STY	Asptl			; set array data size low byte (four bytes per element)
.bfa5	91 5e			sta ($5e),y			STA	(Astrtl),Y		; set array's dimensions count
.bfa7	18				clc					CLC				; clear carry for add (clear on subsequent loops)
.bfa8									LAB_1EC0
.bfa8	a2 0b			ldx #$0b			LDX	#$0B			; set default dimension value low byte
.bfaa	a9 00			lda #$00			LDA	#$00			; set default dimension value high byte
.bfac	24 10			bit $10				BIT	Defdim		; test default DIM flag
.bfae	50 07			bvc $bfb7			BVC	LAB_1ED0		; branch if b6 of Defdim is clear
.bfb0	68				pla					PLA				; else pull dimension value low byte
.bfb1	69 01			adc #$01			ADC	#$01			; +1 (allow for zeroeth element)
.bfb3	aa				tax					TAX				; copy low byte to X
.bfb4	68				pla					PLA				; pull dimension value high byte
.bfb5	69 00			adc #$00			ADC	#$00			; add carry from low byte
.bfb7									LAB_1ED0
.bfb7	c8				iny					INY				; index to dimension value high byte
.bfb8	91 5e			sta ($5e),y			STA	(Astrtl),Y		; save dimension value high byte
.bfba	c8				iny					INY				; index to dimension value high byte
.bfbb	8a				txa					TXA				; get dimension value low byte
.bfbc	91 5e			sta ($5e),y			STA	(Astrtl),Y		; save dimension value low byte
.bfbe	20 5e c0		jsr $c05e			JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
.bfc1	86 6e			stx $6e				STX	Asptl			; save array data size low byte
.bfc3	85 6f			sta $6f				STA	Aspth			; save array data size high byte
.bfc5	a4 25			ldy $25				LDY	ut1_pl		; restore index (saved by subroutine)
.bfc7	c6 0f			dec $0f				DEC	Dimcnt		; decrement dimensions count
.bfc9	d0 dd			bne $bfa8			BNE	LAB_1EC0		; loop while not = 0
.bfcb	65 5a			adc $5a				ADC	Adatah		; add size high byte to first element high byte
.bfcd	b0 5d			bcs $c02c			BCS	LAB_1F45		; if overflow go do "Out of memory" error
.bfcf	85 5a			sta $5a				STA	Adatah		; save end of array high byte
.bfd1	a8				tay					TAY				; copy end high byte to Y
.bfd2	8a				txa					TXA				; get array size low byte
.bfd3	65 59			adc $59				ADC	Adatal		; add array start low byte
.bfd5	90 03			bcc $bfda			BCC	LAB_1EF3		; branch if no carry
.bfd7	c8				iny					INY				; else increment end of array high byte
.bfd8	f0 52			beq $c02c			BEQ	LAB_1F45		; if overflow go do "Out of memory" error
.bfda									LAB_1EF3
.bfda	20 5e b1		jsr $b15e			JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.bfdd	85 33			sta $33				STA	Earryl		; save array mem end low byte
.bfdf	84 34			sty $34				STY	Earryh		; save array mem end high byte
.bfe1	a9 00			lda #$00			LDA	#$00			; clear byte for array clear
.bfe3	e6 6f			inc $6f				INC	Aspth			; increment array size high byte (now block count)
.bfe5	a4 6e			ldy $6e				LDY	Asptl			; get array size low byte (now index to block)
.bfe7	f0 05			beq $bfee			BEQ	LAB_1F07		; branch if low byte = $00
.bfe9									LAB_1F02
.bfe9	88				dey					DEY				; decrement index (do 0 to n-1)
.bfea	91 59			sta ($59),y			STA	(Adatal),Y		; zero byte
.bfec	d0 fb			bne $bfe9			BNE	LAB_1F02		; loop until this block done
.bfee									LAB_1F07
.bfee	c6 5a			dec $5a				DEC	Adatah		; decrement array pointer high byte
.bff0	c6 6f			dec $6f				DEC	Aspth			; decrement block count high byte
.bff2	d0 f5			bne $bfe9			BNE	LAB_1F02		; loop until all blocks done
.bff4	e6 5a			inc $5a				INC	Adatah		; correct for last loop
.bff6	38				sec					SEC				; set carry for subtract
.bff7	a0 02			ldy #$02			LDY	#$02			; index to array size low byte
.bff9	a5 33			lda $33				LDA	Earryl		; get array mem end low byte
.bffb	e5 5e			sbc $5e				SBC	Astrtl		; subtract array start low byte
.bffd	91 5e			sta ($5e),y			STA	(Astrtl),Y		; save array size low byte
.bfff	c8				iny					INY				; index to array size high byte
.c000	a5 34			lda $34				LDA	Earryh		; get array mem end high byte
.c002	e5 5f			sbc $5f				SBC	Astrth		; subtract array start high byte
.c004	91 5e			sta ($5e),y			STA	(Astrtl),Y		; save array size high byte
.c006	a5 10			lda $10				LDA	Defdim		; get default DIM flag
.c008	d0 53			bne $c05d			BNE	LAB_1F7B		; exit (RET) if this was a DIM command
.c00a	c8				iny					INY				; index to # of dimensions
.c00b									LAB_1F24
.c00b	b1 5e			lda ($5e),y			LDA	(Astrtl),Y		; get array's dimension count
.c00d	85 0f			sta $0f				STA	Dimcnt		; save it
.c00f									LAB_1F28
.c00f	a9 00			lda #$00			LDA	#$00			; clear byte
.c011	85 6e			sta $6e				STA	Asptl			; clear array data pointer low byte
.c013									LAB_1F2C
.c013	85 6f			sta $6f				STA	Aspth			; save array data pointer high byte
.c015	c8				iny					INY				; increment index (point to array bound high byte)
.c016	68				pla					PLA				; pull array index low byte
.c017	aa				tax					TAX				; copy to X
.c018	85 62			sta $62				STA	FAC1_2		; save index low byte to FAC1 mantissa2
.c01a	68				pla					PLA				; pull array index high byte
.c01b	85 63			sta $63				STA	FAC1_3		; save index high byte to FAC1 mantissa3
.c01d	d1 5e			cmp ($5e),y			CMP	(Astrtl),Y		; compare with array bound high byte
.c01f	90 0e			bcc $c02f			BCC	LAB_1F48		; branch if within bounds
.c021	d0 06			bne $c029			BNE	LAB_1F42		; if outside bounds do array bounds error
.c023	c8				iny					INY				; index to array bound low byte
.c024	8a				txa					TXA				; get array index low byte
.c025	d1 5e			cmp ($5e),y			CMP	(Astrtl),Y		; compare with array bound low byte
.c027	90 07			bcc $c030			BCC	LAB_1F49		; branch if within bounds
.c029									LAB_1F42
.c029	4c 70 bf		jmp $bf70			JMP	LAB_1E85		; else do array bounds error
.c02c									LAB_1F45
.c02c	4c 8d b1		jmp $b18d			JMP	LAB_OMER		; do "Out of memory" error then warm start
.c02f									LAB_1F48
.c02f	c8				iny					INY				; index to array bound low byte
.c030									LAB_1F49
.c030	a5 6f			lda $6f				LDA	Aspth			; get array data pointer high byte
.c032	05 6e			ora $6e				ORA	Asptl			; OR with array data pointer low byte
.c034	f0 0a			beq $c040			BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
.c036	20 5e c0		jsr $c05e			JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
.c039	8a				txa					TXA				; get result low byte
.c03a	65 62			adc $62				ADC	FAC1_2		; add index low byte from FAC1 mantissa2
.c03c	aa				tax					TAX				; save result low byte
.c03d	98				tya					TYA				; get result high byte
.c03e	a4 25			ldy $25				LDY	ut1_pl		; restore index
.c040									LAB_1F5A
.c040	65 63			adc $63				ADC	FAC1_3		; add index high byte from FAC1 mantissa3
.c042	86 6e			stx $6e				STX	Asptl			; save array data pointer low byte
.c044	c6 0f			dec $0f				DEC	Dimcnt		; decrement dimensions count
.c046	d0 cb			bne $c013			BNE	LAB_1F2C		; loop if dimensions still to do
.c048	06 6e			asl $6e				ASL	Asptl			; array data pointer low byte * 2
.c04a	2a				rol a				ROL				; array data pointer high byte * 2
.c04b	06 6e			asl $6e				ASL	Asptl			; array data pointer low byte * 4
.c04d	2a				rol a				ROL				; array data pointer high byte * 4
.c04e	a8				tay					TAY				; copy high byte
.c04f	a5 6e			lda $6e				LDA	Asptl			; get low byte
.c051	65 59			adc $59				ADC	Adatal		; add array data start pointer low byte
.c053	85 49			sta $49				STA	Cvaral		; save as current var address low byte
.c055	98				tya					TYA				; get high byte back
.c056	65 5a			adc $5a				ADC	Adatah		; add array data start pointer high byte
.c058	85 4a			sta $4a				STA	Cvarah		; save as current var address high byte
.c05a	a8				tay					TAY				; copy high byte to Y
.c05b	a5 49			lda $49				LDA	Cvaral		; get current var address low byte
.c05d									LAB_1F7B
.c05d	60				rts					RTS
.c05e									LAB_1F7C
.c05e	84 25			sty $25				STY	ut1_pl		; save index
.c060	b1 5e			lda ($5e),y			LDA	(Astrtl),Y		; get dimension size low byte
.c062	85 2a			sta $2a				STA	dims_l		; save dimension size low byte
.c064	88				dey					DEY				; decrement index
.c065	b1 5e			lda ($5e),y			LDA	(Astrtl),Y		; get dimension size high byte
.c067	85 2b			sta $2b				STA	dims_h		; save dimension size high byte
.c069	a9 10			lda #$10			LDA	#$10			; count = $10 (16 bit multiply)
.c06b	85 5c			sta $5c				STA	numbit		; save bit count
.c06d	a2 00			ldx #$00			LDX	#$00			; clear result low byte
.c06f	a0 00			ldy #$00			LDY	#$00			; clear result high byte
.c071									LAB_1F8F
.c071	8a				txa					TXA				; get result low byte
.c072	0a				asl a				ASL				; *2
.c073	aa				tax					TAX				; save result low byte
.c074	98				tya					TYA				; get result high byte
.c075	2a				rol a				ROL				; *2
.c076	a8				tay					TAY				; save result high byte
.c077	b0 b3			bcs $c02c			BCS	LAB_1F45		; if overflow go do "Out of memory" error
.c079	06 6e			asl $6e				ASL	Asptl			; shift multiplier low byte
.c07b	26 6f			rol $6f				ROL	Aspth			; shift multiplier high byte
.c07d	90 0b			bcc $c08a			BCC	LAB_1FA8		; skip add if no carry
.c07f	18				clc					CLC				; else clear carry for add
.c080	8a				txa					TXA				; get result low byte
.c081	65 2a			adc $2a				ADC	dims_l		; add dimension size low byte
.c083	aa				tax					TAX				; save result low byte
.c084	98				tya					TYA				; get result high byte
.c085	65 2b			adc $2b				ADC	dims_h		; add dimension size high byte
.c087	a8				tay					TAY				; save result high byte
.c088	b0 a2			bcs $c02c			BCS	LAB_1F45		; if overflow go do "Out of memory" error
.c08a									LAB_1FA8
.c08a	c6 5c			dec $5c				DEC	numbit		; decrement bit count
.c08c	d0 e3			bne $c071			BNE	LAB_1F8F		; loop until all done
.c08e	60				rts					RTS
.c08f									LAB_FRE
.c08f	a5 11			lda $11				LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.c091	10 03			bpl $c096			BPL	LAB_1FB4		; branch if numeric
.c093	20 98 c3		jsr $c398			JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.c096									LAB_1FB4
.c096	20 39 c2		jsr $c239			JSR	LAB_GARB		; go do garbage collection
.c099	38				sec					SEC				; set carry for subtract
.c09a	a5 35			lda $35				LDA	Sstorl		; get bottom of string space low byte
.c09c	e5 33			sbc $33				SBC	Earryl		; subtract array mem end low byte
.c09e	a8				tay					TAY				; copy result to Y
.c09f	a5 36			lda $36				LDA	Sstorh		; get bottom of string space high byte
.c0a1	e5 34			sbc $34				SBC	Earryh		; subtract array mem end high byte
.c0a3	80 0b			bra $c0b0			BRA LAB_UAYFC
.c0a5									LAB_AYFC
.c0a5	46 11			lsr $11				LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.c0a7	85 61			sta $61				STA	FAC1_1		; save FAC1 mantissa1
.c0a9	84 62			sty $62				STY	FAC1_2		; save FAC1 mantissa2
.c0ab	a2 90			ldx #$90			LDX	#$90		; set exponent=2^16 (integer)
.c0ad	4c 5c c9		jmp $c95c			JMP	LAB_27E3	; set exp=X, clear FAC1_3, normalise and return
.c0b0									LAB_UAYFC
.c0b0	46 11			lsr $11				LSR Dtypef		; clear data type flag, $FF=string, $00=numeric
.c0b2	85 61			sta $61				STA FAC1_1		; save FAC1 mantissa1
.c0b4	84 62			sty $62				STY FAC1_2		; save FAC1 mantissa2
.c0b6	a2 90			ldx #$90			LDX #$90		; set exponent=2^16 (integer)
.c0b8	38				sec					SEC				; always positive
.c0b9	4c 61 c9		jmp $c961			JMP LAB_STFA	; set exp=X, clear FAC1_3, normalise and return
.c0bc									LAB_POS
.c0bc	a4 07			ldy $07				LDY	TPos			; get terminal position
.c0be									LAB_1FD0
.c0be	a9 00			lda #$00			LDA	#$00			; clear high byte
.c0c0	f0 e3			beq $c0a5			BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
.c0c2									LAB_CKRN
.c0c2	a6 3c			ldx $3c				LDX	Clineh		; get current line high byte
.c0c4	e8				inx					INX				; increment it
.c0c5	d0 96			bne $c05d			BNE	LAB_1F7B		; return if can continue not direct mode
.c0c7									LAB_1FD9
.c0c7	a2 16			ldx #$16			LDX	#$16			; error code $16 ("Illegal direct" error)
.c0c9									LAB_1FDB
.c0c9	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; go do error #X, then warm start
.c0cc									LAB_DEF
.c0cc	20 fd c0		jsr $c0fd			JSR	LAB_200B		; check FNx syntax
.c0cf	85 50			sta $50				STA	func_l		; save function pointer low byte
.c0d1	84 51			sty $51				STY	func_h		; save function pointer high byte
.c0d3	20 c2 c0		jsr $c0c2			JSR	LAB_CKRN		; check not Direct (back here if ok)
.c0d6	20 42 bc		jsr $bc42			JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
.c0d9	a9 80			lda #$80			LDA	#$80			; set flag for FNx
.c0db	85 14			sta $14				STA	Sufnxf		; save subscript/FNx flag
.c0dd	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get (var) address
.c0e0	20 18 bb		jsr $bb18			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.c0e3	20 37 bc		jsr $bc37			JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.c0e6	a9 c2			lda #$c2			LDA	#TK_EQUAL		; get = token
.c0e8	20 39 bc		jsr $bc39			JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.c0eb	a5 4a			lda $4a				LDA	Cvarah		; get current var address high byte
.c0ed	48				pha					PHA				; push it
.c0ee	a5 49			lda $49				LDA	Cvaral		; get current var address low byte
.c0f0	48				pha					PHA				; push it
.c0f1	a5 78			lda $78				LDA	Bpntrh		; get BASIC execute pointer high byte
.c0f3	48				pha					PHA				; push it
.c0f4	a5 77			lda $77				LDA	Bpntrl		; get BASIC execute pointer low byte
.c0f6	48				pha					PHA				; push it
.c0f7	20 d7 b6		jsr $b6d7			JSR	LAB_DATA		; go perform DATA
.c0fa	4c 6c c1		jmp $c16c			JMP	LAB_207A		; put execute pointer and variable pointer into function
.c0fd									LAB_200B
.c0fd	a9 af			lda #$af			LDA	#TK_FN		; get FN" token
.c0ff	20 39 bc		jsr $bc39			JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
.c102	09 80			ora #$80			ORA	#$80			; set FN flag bit
.c104	85 14			sta $14				STA	Sufnxf		; save FN flag so array variable test fails
.c106	20 fb bd		jsr $bdfb			JSR	LAB_1D12		; search for FN variable
.c109	4c 18 bb		jmp $bb18			JMP	LAB_CTNM		; check if source is numeric and return, else do type
.c10c									LAB_201E
.c10c	20 fd c0		jsr $c0fd			JSR	LAB_200B		; check FNx syntax
.c10f	48				pha					PHA				; push function pointer low byte
.c110	98				tya					TYA				; copy function pointer high byte
.c111	48				pha					PHA				; push function pointer high byte
.c112	20 42 bc		jsr $bc42			JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
.c115	20 29 bb		jsr $bb29			JSR	LAB_EVEX		; evaluate expression
.c118	20 37 bc		jsr $bc37			JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
.c11b	20 18 bb		jsr $bb18			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.c11e	68				pla					PLA				; pop function pointer high byte
.c11f	85 51			sta $51				STA	func_h		; restore it
.c121	68				pla					PLA				; pop function pointer low byte
.c122	85 50			sta $50				STA	func_l		; restore it
.c124	a2 20			ldx #$20			LDX	#$20			; error code $20 ("Undefined function" error)
.c126	a0 03			ldy #$03			LDY	#$03			; index to variable pointer high byte
.c128	b1 50			lda ($50),y			LDA	(func_l),Y		; get variable pointer high byte
.c12a	f0 9d			beq $c0c9			BEQ	LAB_1FDB		; if zero go do undefined function error
.c12c	85 4a			sta $4a				STA	Cvarah		; save variable address high byte
.c12e	88				dey					DEY				; index to variable address low byte
.c12f	b1 50			lda ($50),y			LDA	(func_l),Y		; get variable address low byte
.c131	85 49			sta $49				STA	Cvaral		; save variable address low byte
.c133	aa				tax					TAX				; copy address low byte
.c134	c8				iny					INY				; index to mantissa_3
.c135									LAB_2043
.c135	b1 49			lda ($49),y			LDA	(Cvaral),Y		; get byte from variable
.c137	48				pha					PHA				; stack it
.c138	88				dey					DEY				; decrement index
.c139	10 fa			bpl $c135			BPL	LAB_2043		; loop until variable stacked
.c13b	a4 4a			ldy $4a				LDY	Cvarah		; get variable address high byte
.c13d	20 01 c9		jsr $c901			JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
.c140	a5 78			lda $78				LDA	Bpntrh		; get BASIC execute pointer high byte
.c142	48				pha					PHA				; push it
.c143	a5 77			lda $77				LDA	Bpntrl		; get BASIC execute pointer low byte
.c145	48				pha					PHA				; push it
.c146	b1 50			lda ($50),y			LDA	(func_l),Y		; get function execute pointer low byte
.c148	85 77			sta $77				STA	Bpntrl		; save as BASIC execute pointer low byte
.c14a	c8				iny					INY				; index to high byte
.c14b	b1 50			lda ($50),y			LDA	(func_l),Y		; get function execute pointer high byte
.c14d	85 78			sta $78				STA	Bpntrh		; save as BASIC execute pointer high byte
.c14f	a5 4a			lda $4a				LDA	Cvarah		; get variable address high byte
.c151	48				pha					PHA				; push it
.c152	a5 49			lda $49				LDA	Cvaral		; get variable address low byte
.c154	48				pha					PHA				; push it
.c155	20 15 bb		jsr $bb15			JSR	LAB_EVNM		; evaluate expression and check is numeric,
.c158	68				pla					PLA				; pull variable address low byte
.c159	85 50			sta $50				STA	func_l		; save variable address low byte
.c15b	68				pla					PLA				; pull variable address high byte
.c15c	85 51			sta $51				STA	func_h		; save variable address high byte
.c15e	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.c161	f0 03			beq $c166			BEQ	LAB_2074		; branch if null (should be [EOL] marker)
.c163	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; else syntax error then warm start
.c166									LAB_2074
.c166	68				pla					PLA				; pull BASIC execute pointer low byte
.c167	85 77			sta $77				STA	Bpntrl		; restore BASIC execute pointer low byte
.c169	68				pla					PLA				; pull BASIC execute pointer high byte
.c16a	85 78			sta $78				STA	Bpntrh		; restore BASIC execute pointer high byte
.c16c									LAB_207A
.c16c	a0 00			ldy #$00			LDY	#$00			; clear index
.c16e	68				pla					PLA				; pull BASIC execute pointer low byte
.c16f	91 50			sta ($50),y			STA	(func_l),Y		; save to function
.c171	c8				iny					INY				; increment index
.c172	68				pla					PLA				; pull BASIC execute pointer high byte
.c173	91 50			sta ($50),y			STA	(func_l),Y		; save to function
.c175	c8				iny					INY				; increment index
.c176	68				pla					PLA				; pull current var address low byte
.c177	91 50			sta ($50),y			STA	(func_l),Y		; save to function
.c179	c8				iny					INY				; increment index
.c17a	68				pla					PLA				; pull current var address high byte
.c17b	91 50			sta ($50),y			STA	(func_l),Y		; save to function
.c17d	60				rts					RTS
.c17e									LAB_STRS
.c17e	20 18 bb		jsr $bb18			JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.c181	20 ef ca		jsr $caef			JSR	LAB_296E		; convert FAC1 to string
.c184	a9 97			lda #$97			LDA	#<Decssp1		; set result string low pointer
.c186	a0 00			ldy #$00			LDY	#>Decssp1		; set result string high pointer
.c188	f0 12			beq $c19c			BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
.c18a									LAB_209C
.c18a	a6 62			ldx $62				LDX	des_pl		; get descriptor pointer low byte
.c18c	a4 63			ldy $63				LDY	des_ph		; get descriptor pointer high byte
.c18e	86 52			stx $52				STX	des_2l		; save descriptor pointer low byte
.c190	84 53			sty $53				STY	des_2h		; save descriptor pointer high byte
.c192									LAB_MSSP
.c192	20 07 c2		jsr $c207			JSR	LAB_2115		; make space in string memory for string A long
.c195	86 61			stx $61				STX	str_pl		; save string pointer low byte
.c197	84 62			sty $62				STY	str_ph		; save string pointer high byte
.c199	85 60			sta $60				STA	str_ln		; save length
.c19b	60				rts					RTS
.c19c									LAB_20AE
.c19c	a2 22			ldx #$22			LDX	#$22			; set terminator to "
.c19e	86 0d			stx $0d				STX	Srchc			; set search character (terminator 1)
.c1a0	86 0e			stx $0e				STX	Asrch			; set terminator 2
.c1a2									LAB_20B4
.c1a2	85 6c			sta $6c				STA	ssptr_l		; store string start low byte
.c1a4	84 6d			sty $6d				STY	ssptr_h		; store string start high byte
.c1a6	85 61			sta $61				STA	str_pl		; save string pointer low byte
.c1a8	84 62			sty $62				STY	str_ph		; save string pointer high byte
.c1aa	a0 ff			ldy #$ff			LDY	#$FF			; set length to -1
.c1ac									LAB_20BE
.c1ac	c8				iny					INY				; increment length
.c1ad	b1 6c			lda ($6c),y			LDA	(ssptr_l),Y		; get byte from string
.c1af	f0 0c			beq $c1bd			BEQ	LAB_20CF		; exit loop if null byte [EOS]
.c1b1	c5 0d			cmp $0d				CMP	Srchc			; compare with search character (terminator 1)
.c1b3	f0 04			beq $c1b9			BEQ	LAB_20CB		; branch if terminator
.c1b5	c5 0e			cmp $0e				CMP	Asrch			; compare with terminator 2
.c1b7	d0 f3			bne $c1ac			BNE	LAB_20BE		; loop if not terminator 2
.c1b9									LAB_20CB
.c1b9	c9 22			cmp #$22			CMP	#$22			; compare with "
.c1bb	f0 01			beq $c1be			BEQ	LAB_20D0		; branch if " (carry set if = !)
.c1bd									LAB_20CF
.c1bd	18				clc					CLC				; clear carry for add (only if [EOL] terminated string)
.c1be									LAB_20D0
.c1be	84 60			sty $60				STY	str_ln		; save length in FAC1 exponent
.c1c0	98				tya					TYA				; copy length to A
.c1c1	65 6c			adc $6c				ADC	ssptr_l		; add string start low byte
.c1c3	85 6e			sta $6e				STA	Sendl			; save string end low byte
.c1c5	a6 6d			ldx $6d				LDX	ssptr_h		; get string start high byte
.c1c7	90 01			bcc $c1ca			BCC	LAB_20DC		; branch if no low byte overflow
.c1c9	e8				inx					INX				; else increment high byte
.c1ca									LAB_20DC
.c1ca	86 6f			stx $6f				STX	Sendh			; save string end high byte
.c1cc	a5 6d			lda $6d				LDA	ssptr_h		; get string start high byte
.c1ce	f0 04			beq $c1d4		      BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
.c1d0	c9 02			cmp #$02		      CMP   #>Ibuffs          ; compare with location of input buffer page
.c1d2	d0 0b			bne $c1df		      BNE   LAB_RTST          ; branch if not in utility area
.c1d4									LAB_MVST
.c1d4	98				tya					TYA				; copy length to A
.c1d5	20 8a c1		jsr $c18a			JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
.c1d8	a6 6c			ldx $6c				LDX	ssptr_l		; get string start low byte
.c1da	a4 6d			ldy $6d				LDY	ssptr_h		; get string start high byte
.c1dc	20 79 c3		jsr $c379			JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
.c1df									LAB_RTST
.c1df	a6 18			ldx $18				LDX	next_s		; get string stack pointer
.c1e1	e0 24			cpx #$24			CPX	#des_sk+$09		; compare with max+1
.c1e3	d0 05			bne $c1ea			BNE	LAB_20F8		; branch if space on string stack
.c1e5	a2 1c			ldx #$1c			LDX	#$1C			; error code $1C ("String too complex" error)
.c1e7									LAB_20F5
.c1e7	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; do error #X, then warm start
.c1ea									LAB_20F8
.c1ea	a5 60			lda $60				LDA	str_ln		; get string length
.c1ec	95 00			sta $00,x			STA	PLUS_0,X		; put on string stack
.c1ee	a5 61			lda $61				LDA	str_pl		; get string pointer low byte
.c1f0	95 01			sta $01,x			STA	PLUS_1,X		; put on string stack
.c1f2	a5 62			lda $62				LDA	str_ph		; get string pointer high byte
.c1f4	95 02			sta $02,x			STA	PLUS_2,X		; put on string stack
.c1f6	a0 00			ldy #$00			LDY	#$00			; clear Y
.c1f8	86 62			stx $62				STX	des_pl		; save string descriptor pointer low byte
.c1fa	84 63			sty $63				STY	des_ph		; save string descriptor pointer high byte (always $00)
.c1fc	88				dey					DEY				; Y = $FF
.c1fd	84 11			sty $11				STY	Dtypef		; save data type flag, $FF=string
.c1ff	86 19			stx $19				STX	last_sl		; save old stack pointer (current top item)
.c201	e8				inx					INX				; update stack pointer
.c202	e8				inx					INX				; update stack pointer
.c203	e8				inx					INX				; update stack pointer
.c204	86 18			stx $18				STX	next_s		; save new top item value
.c206	60				rts					RTS
.c207									LAB_2115
.c207	46 13			lsr $13				LSR	Gclctd		; clear garbage collected flag (b7)
.c209									LAB_2117
.c209	48				pha					PHA				; save string length
.c20a	49 ff			eor #$ff			EOR	#$FF			; complement it
.c20c	38				sec					SEC				; set carry for subtract (twos comp add)
.c20d	65 35			adc $35				ADC	Sstorl		; add bottom of string space low byte (subtract length)
.c20f	a4 36			ldy $36				LDY	Sstorh		; get bottom of string space high byte
.c211	b0 01			bcs $c214			BCS	LAB_2122		; skip decrement if no underflow
.c213	88				dey					DEY				; decrement bottom of string space high byte
.c214									LAB_2122
.c214	c4 34			cpy $34				CPY	Earryh		; compare with array mem end high byte
.c216	90 11			bcc $c229			BCC	LAB_2137		; do out of memory error if less
.c218	d0 04			bne $c21e			BNE	LAB_212C		; if not = skip next test
.c21a	c5 33			cmp $33				CMP	Earryl		; compare with array mem end low byte
.c21c	90 0b			bcc $c229			BCC	LAB_2137		; do out of memory error if less
.c21e									LAB_212C
.c21e	85 35			sta $35				STA	Sstorl		; save bottom of string space low byte
.c220	84 36			sty $36				STY	Sstorh		; save bottom of string space high byte
.c222	85 37			sta $37				STA	Sutill		; save string utility ptr low byte
.c224	84 38			sty $38				STY	Sutilh		; save string utility ptr high byte
.c226	aa				tax					TAX				; copy low byte to X
.c227	68				pla					PLA				; get string length back
.c228	60				rts					RTS
.c229									LAB_2137
.c229	a2 0c			ldx #$0c			LDX	#$0C			; error code $0C ("Out of memory" error)
.c22b	a5 13			lda $13				LDA	Gclctd		; get garbage collected flag
.c22d	30 b8			bmi $c1e7			BMI	LAB_20F5		; if set then do error code X
.c22f	20 39 c2		jsr $c239			JSR	LAB_GARB		; else go do garbage collection
.c232	a9 80			lda #$80			LDA	#$80			; flag for garbage collected
.c234	85 13			sta $13				STA	Gclctd		; set garbage collected flag
.c236	68				pla					PLA				; pull length
.c237	d0 d0			bne $c209			BNE	LAB_2117		; go try again (loop always, length should never be = $00)
.c239									LAB_GARB
.c239	a6 39			ldx $39				LDX	Ememl			; get end of mem low byte
.c23b	a5 3a			lda $3a				LDA	Ememh			; get end of mem high byte
.c23d									LAB_214B
.c23d	86 35			stx $35				STX	Sstorl		; set string storage low byte
.c23f	85 36			sta $36				STA	Sstorh		; set string storage high byte
.c241	a0 00			ldy #$00			LDY	#$00			; clear index
.c243	84 51			sty $51				STY	garb_h		; clear working pointer high byte (flag no strings to move)
.c245	a5 33			lda $33				LDA	Earryl		; get array mem end low byte
.c247	a6 34			ldx $34				LDX	Earryh		; get array mem end high byte
.c249	85 5e			sta $5e				STA	Histrl		; save as highest string low byte
.c24b	86 5f			stx $5f				STX	Histrh		; save as highest string high byte
.c24d	a9 1b			lda #$1b			LDA	#des_sk		; set descriptor stack pointer
.c24f	85 25			sta $25				STA	ut1_pl		; save descriptor stack pointer low byte
.c251	84 26			sty $26				STY	ut1_ph		; save descriptor stack pointer high byte ($00)
.c253									LAB_2161
.c253	c5 18			cmp $18				CMP	next_s		; compare with descriptor stack pointer
.c255	f0 05			beq $c25c			BEQ	LAB_216A		; branch if =
.c257	20 bd c2		jsr $c2bd			JSR	LAB_21D7		; go garbage collect descriptor stack
.c25a	f0 f7			beq $c253			BEQ	LAB_2161		; loop always
.c25c									LAB_216A
.c25c	06 54			asl $54				ASL	g_step		; set step size = $06
.c25e	a5 2f			lda $2f				LDA	Svarl			; get start of vars low byte
.c260	a6 30			ldx $30				LDX	Svarh			; get start of vars high byte
.c262	85 25			sta $25				STA	ut1_pl		; save as pointer low byte
.c264	86 26			stx $26				STX	ut1_ph		; save as pointer high byte
.c266									LAB_2176
.c266	e4 32			cpx $32				CPX	Sarryh		; compare start of arrays high byte
.c268	d0 04			bne $c26e			BNE	LAB_217E		; branch if no high byte match
.c26a	c5 31			cmp $31				CMP	Sarryl		; else compare start of arrays low byte
.c26c	f0 05			beq $c273			BEQ	LAB_2183		; branch if = var mem end
.c26e									LAB_217E
.c26e	20 b7 c2		jsr $c2b7			JSR	LAB_21D1		; go garbage collect strings
.c271	f0 f3			beq $c266			BEQ	LAB_2176		; loop always
.c273									LAB_2183
.c273	85 59			sta $59				STA	Nbendl		; save start of arrays low byte as working pointer
.c275	86 5a			stx $5a				STX	Nbendh		; save start of arrays high byte as working pointer
.c277	a9 04			lda #$04			LDA	#$04			; set step size
.c279	85 54			sta $54				STA	g_step		; save step size
.c27b									LAB_218B
.c27b	a5 59			lda $59				LDA	Nbendl		; get pointer low byte
.c27d	a6 5a			ldx $5a				LDX	Nbendh		; get pointer high byte
.c27f									LAB_218F
.c27f	e4 34			cpx $34				CPX	Earryh		; compare with array mem end high byte
.c281	d0 04			bne $c287			BNE	LAB_219A		; branch if not at end
.c283	c5 33			cmp $33				CMP	Earryl		; else compare with array mem end low byte
.c285	f0 75			beq $c2fc			BEQ	LAB_2216		; tidy up and exit if at end
.c287									LAB_219A
.c287	85 25			sta $25				STA	ut1_pl		; save pointer low byte
.c289	86 26			stx $26				STX	ut1_ph		; save pointer high byte
.c28b	a0 02			ldy #$02			LDY	#$02			; set index
.c28d	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get array size low byte
.c28f	65 59			adc $59				ADC	Nbendl		; add start of this array low byte
.c291	85 59			sta $59				STA	Nbendl		; save start of next array low byte
.c293	c8				iny					INY				; increment index
.c294	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get array size high byte
.c296	65 5a			adc $5a				ADC	Nbendh		; add start of this array high byte
.c298	85 5a			sta $5a				STA	Nbendh		; save start of next array high byte
.c29a	a0 01			ldy #$01			LDY	#$01			; set index
.c29c	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get name second byte
.c29e	10 db			bpl $c27b			BPL	LAB_218B		; skip if not string array
.c2a0	a0 04			ldy #$04			LDY	#$04			; set index
.c2a2	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get # of dimensions
.c2a4	0a				asl a				ASL				; *2
.c2a5	69 05			adc #$05			ADC	#$05			; +5 (array header size)
.c2a7	20 ef c2		jsr $c2ef			JSR	LAB_2208		; go set up for first element
.c2aa									LAB_21C4
.c2aa	e4 5a			cpx $5a				CPX	Nbendh		; compare with start of next array high byte
.c2ac	d0 04			bne $c2b2			BNE	LAB_21CC		; branch if <> (go do this array)
.c2ae	c5 59			cmp $59				CMP	Nbendl		; else compare element pointer low byte with next array
.c2b0	f0 cd			beq $c27f			BEQ	LAB_218F		; if equal then go do next array
.c2b2									LAB_21CC
.c2b2	20 bd c2		jsr $c2bd			JSR	LAB_21D7		; go defrag array strings
.c2b5	f0 f3			beq $c2aa			BEQ	LAB_21C4		; go do next array string (loop always)
.c2b7									LAB_21D1
.c2b7	c8				iny					INY				; increment index (Y was $00)
.c2b8	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get var name byte 2
.c2ba	10 30			bpl $c2ec			BPL	LAB_2206		; if not string, step pointer to next var and return
.c2bc	c8				iny					INY				; else increment index
.c2bd									LAB_21D7
.c2bd	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get string length
.c2bf	f0 2b			beq $c2ec			BEQ	LAB_2206		; if null, step pointer to next string and return
.c2c1	c8				iny					INY				; else increment index
.c2c2	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get string pointer low byte
.c2c4	aa				tax					TAX				; copy to X
.c2c5	c8				iny					INY				; increment index
.c2c6	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get string pointer high byte
.c2c8	c5 36			cmp $36				CMP	Sstorh		; compare bottom of string space high byte
.c2ca	90 06			bcc $c2d2			BCC	LAB_21EC		; branch if less
.c2cc	d0 1e			bne $c2ec			BNE	LAB_2206		; if greater, step pointer to next string and return
.c2ce	e4 35			cpx $35				CPX	Sstorl		; compare bottom of string space low byte
.c2d0	b0 1a			bcs $c2ec			BCS	LAB_2206		; if >=, step pointer to next string and return
.c2d2									LAB_21EC
.c2d2	c5 5f			cmp $5f				CMP	Histrh		; compare to highest string high byte
.c2d4	90 17			bcc $c2ed			BCC	LAB_2207		; if <, step pointer to next string and return
.c2d6	d0 04			bne $c2dc			BNE	LAB_21F6		; if > update pointers, step to next and return
.c2d8	e4 5e			cpx $5e				CPX	Histrl		; compare to highest string low byte
.c2da	90 11			bcc $c2ed			BCC	LAB_2207		; if <, step pointer to next string and return
.c2dc									LAB_21F6
.c2dc	86 5e			stx $5e				STX	Histrl		; save as new highest string low byte
.c2de	85 5f			sta $5f				STA	Histrh		; save as new highest string high byte
.c2e0	a5 25			lda $25				LDA	ut1_pl		; get start of vars(descriptors) low byte
.c2e2	a6 26			ldx $26				LDX	ut1_ph		; get start of vars(descriptors) high byte
.c2e4	85 50			sta $50				STA	garb_l		; save as working pointer low byte
.c2e6	86 51			stx $51				STX	garb_h		; save as working pointer high byte
.c2e8	88				dey					DEY				; decrement index DIFFERS
.c2e9	88				dey					DEY				; decrement index (should point to descriptor start)
.c2ea	84 56			sty $56				STY	g_indx		; save index pointer
.c2ec									LAB_2206
.c2ec	18				clc					CLC				; clear carry for add
.c2ed									LAB_2207
.c2ed	a5 54			lda $54				LDA	g_step		; get step size
.c2ef									LAB_2208
.c2ef	65 25			adc $25				ADC	ut1_pl		; add pointer low byte
.c2f1	85 25			sta $25				STA	ut1_pl		; save pointer low byte
.c2f3	90 02			bcc $c2f7			BCC	LAB_2211		; branch if no overflow
.c2f5	e6 26			inc $26				INC	ut1_ph		; else increment high byte
.c2f7									LAB_2211
.c2f7	a6 26			ldx $26				LDX	ut1_ph		; get pointer high byte
.c2f9	a0 00			ldy #$00			LDY	#$00			; clear Y
.c2fb	60				rts					RTS
.c2fc									LAB_2216
.c2fc	c6 54			dec $54				DEC	g_step		; decrement step size (now $03 for descriptor stack)
.c2fe	a6 51			ldx $51				LDX	garb_h		; get string to move high byte
.c300	f0 f5			beq $c2f7			BEQ	LAB_2211		; exit if nothing to move
.c302	a4 56			ldy $56				LDY	g_indx		; get index byte back (points to descriptor)
.c304	18				clc					CLC				; clear carry for add
.c305	b1 50			lda ($50),y			LDA	(garb_l),Y		; get string length
.c307	65 5e			adc $5e				ADC	Histrl		; add highest string low byte
.c309	85 5b			sta $5b				STA	Obendl		; save old block end low pointer
.c30b	a5 5f			lda $5f				LDA	Histrh		; get highest string high byte
.c30d	69 00			adc #$00			ADC	#$00			; add any carry
.c30f	85 5c			sta $5c				STA	Obendh		; save old block end high byte
.c311	a5 35			lda $35				LDA	Sstorl		; get bottom of string space low byte
.c313	a6 36			ldx $36				LDX	Sstorh		; get bottom of string space high byte
.c315	85 59			sta $59				STA	Nbendl		; save new block end low byte
.c317	86 5a			stx $5a				STX	Nbendh		; save new block end high byte
.c319	20 1b b1		jsr $b11b			JSR	LAB_11D6		; open up space in memory, don't set array end
.c31c	a4 56			ldy $56				LDY	g_indx		; get index byte
.c31e	c8				iny					INY				; point to descriptor low byte
.c31f	a5 59			lda $59				LDA	Nbendl		; get string pointer low byte
.c321	91 50			sta ($50),y			STA	(garb_l),Y		; save new string pointer low byte
.c323	aa				tax					TAX				; copy string pointer low byte
.c324	e6 5a			inc $5a				INC	Nbendh		; correct high byte (move sets high byte -1)
.c326	a5 5a			lda $5a				LDA	Nbendh		; get new string pointer high byte
.c328	c8				iny					INY				; point to descriptor high byte
.c329	91 50			sta ($50),y			STA	(garb_l),Y		; save new string pointer high byte
.c32b	4c 3d c2		jmp $c23d			JMP	LAB_214B		; re-run routine from last ending
.c32e									LAB_224D
.c32e	a5 63			lda $63				LDA	des_ph		; get descriptor pointer high byte
.c330	48				pha					PHA				; put on stack
.c331	a5 62			lda $62				LDA	des_pl		; get descriptor pointer low byte
.c333	48				pha					PHA				; put on stack
.c334	20 15 bc		jsr $bc15			JSR	LAB_GVAL		; get value from line
.c337	20 1a bb		jsr $bb1a			JSR	LAB_CTST		; check if source is string, else do type mismatch
.c33a	68				pla					PLA				; get descriptor pointer low byte back
.c33b	85 6c			sta $6c				STA	ssptr_l		; set pointer low byte
.c33d	68				pla					PLA				; get descriptor pointer high byte back
.c33e	85 6d			sta $6d				STA	ssptr_h		; set pointer high byte
.c340	a0 00			ldy #$00			LDY	#$00			; clear index
.c342	b1 6c			lda ($6c),y			LDA	(ssptr_l),Y		; get length_1 from descriptor
.c344	18				clc					CLC				; clear carry for add
.c345	71 62			adc ($62),y			ADC	(des_pl),Y		; add length_2
.c347	90 05			bcc $c34e			BCC	LAB_226D		; branch if no overflow
.c349	a2 1a			ldx #$1a			LDX	#$1A			; else set error code $1A ("String too long" error)
.c34b	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; do error #X, then warm start
.c34e									LAB_226D
.c34e	20 8a c1		jsr $c18a			JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
.c351	20 6b c3		jsr $c36b			JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
.c354	a5 52			lda $52				LDA	des_2l		; get descriptor pointer low byte
.c356	a4 53			ldy $53				LDY	des_2h		; get descriptor pointer high byte
.c358	20 9c c3		jsr $c39c			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.c35b	20 7d c3		jsr $c37d			JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
.c35e	a5 6c			lda $6c				LDA	ssptr_l		;.set descriptor pointer low byte
.c360	a4 6d			ldy $6d				LDY	ssptr_h		;.set descriptor pointer high byte
.c362	20 9c c3		jsr $c39c			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.c365	20 df c1		jsr $c1df			JSR	LAB_RTST		; check for space on descriptor stack then put string
.c368	4c 40 bb		jmp $bb40			JMP	LAB_1ADB		;.continue evaluation
.c36b									LAB_228A
.c36b	a0 00			ldy #$00			LDY	#$00			; clear index
.c36d	b1 6c			lda ($6c),y			LDA	(sdescr),Y		; get string length
.c36f	48				pha					PHA				; save on stack
.c370	c8				iny					INY				; increment index
.c371	b1 6c			lda ($6c),y			LDA	(sdescr),Y		; get source string pointer low byte
.c373	aa				tax					TAX				; copy to X
.c374	c8				iny					INY				; increment index
.c375	b1 6c			lda ($6c),y			LDA	(sdescr),Y		; get source string pointer high byte
.c377	a8				tay					TAY				; copy to Y
.c378	68				pla					PLA				; get length back
.c379									LAB_2298
.c379	86 25			stx $25				STX	ut1_pl		; save source string pointer low byte
.c37b	84 26			sty $26				STY	ut1_ph		; save source string pointer high byte
.c37d									LAB_229C
.c37d	aa				tax					TAX				; copy length to index (don't count with Y)
.c37e	f0 14			beq $c394			BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
.c380	a0 00			ldy #$00			LDY	#$00			; zero pointer (copy forward)
.c382									LAB_22A0
.c382	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get source byte
.c384	91 37			sta ($37),y			STA	(Sutill),Y		; save destination byte
.c386	c8				iny					INY				; increment index
.c387	ca				dex					DEX				; decrement counter
.c388	d0 f8			bne $c382			BNE	LAB_22A0		; loop while <> 0
.c38a	98				tya					TYA				; restore length from Y
.c38b									LAB_22A9
.c38b	18				clc					CLC				; clear carry for add
.c38c	65 37			adc $37				ADC	Sutill		; add string utility ptr low byte
.c38e	85 37			sta $37				STA	Sutill		; save string utility ptr low byte
.c390	90 02			bcc $c394			BCC	LAB_22B2		; branch if no carry
.c392	e6 38			inc $38				INC	Sutilh		; else increment string utility ptr high byte
.c394									LAB_22B2
.c394	60				rts					RTS
.c395									LAB_EVST
.c395	20 1a bb		jsr $bb1a			JSR	LAB_CTST		; check if source is string, else do type mismatch
.c398									LAB_22B6
.c398	a5 62			lda $62				LDA	des_pl		; get descriptor pointer low byte
.c39a	a4 63			ldy $63				LDY	des_ph		; get descriptor pointer high byte
.c39c									LAB_22BA
.c39c	85 25			sta $25				STA	ut1_pl		; save descriptor pointer low byte
.c39e	84 26			sty $26				STY	ut1_ph		; save descriptor pointer high byte
.c3a0	20 cd c3		jsr $c3cd			JSR	LAB_22EB		; clean descriptor stack, YA = pointer
.c3a3	08				php					PHP				; save status flags
.c3a4	a0 00			ldy #$00			LDY	#$00			; clear index
.c3a6	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get length from string descriptor
.c3a8	48				pha					PHA				; put on stack
.c3a9	c8				iny					INY				; increment index
.c3aa	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
.c3ac	aa				tax					TAX				; copy to X
.c3ad	c8				iny					INY				; increment index
.c3ae	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
.c3b0	a8				tay					TAY				; copy to Y
.c3b1	68				pla					PLA				; get string length back
.c3b2	28				plp					PLP				; restore status
.c3b3	d0 13			bne $c3c8			BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
.c3b5	c4 36			cpy $36				CPY	Sstorh		; compare bottom of string space high byte
.c3b7	d0 0f			bne $c3c8			BNE	LAB_22E6		; branch if <>
.c3b9	e4 35			cpx $35				CPX	Sstorl		; else compare bottom of string space low byte
.c3bb	d0 0b			bne $c3c8			BNE	LAB_22E6		; branch if <>
.c3bd	48				pha					PHA				; save string length
.c3be	18				clc					CLC				; clear carry for add
.c3bf	65 35			adc $35				ADC	Sstorl		; add bottom of string space low byte
.c3c1	85 35			sta $35				STA	Sstorl		; save bottom of string space low byte
.c3c3	90 02			bcc $c3c7			BCC	LAB_22E5		; skip increment if no overflow
.c3c5	e6 36			inc $36				INC	Sstorh		; increment bottom of string space high byte
.c3c7									LAB_22E5
.c3c7	68				pla					PLA				; restore string length
.c3c8									LAB_22E6
.c3c8	86 25			stx $25				STX	ut1_pl		; save string pointer low byte
.c3ca	84 26			sty $26				STY	ut1_ph		; save string pointer high byte
.c3cc	60				rts					RTS
.c3cd									LAB_22EB
.c3cd	c4 1a			cpy $1a				CPY	last_sh		; compare pointer high byte
.c3cf	d0 0c			bne $c3dd			BNE	LAB_22FB		; exit if <>
.c3d1	c5 19			cmp $19				CMP	last_sl		; compare pointer low byte
.c3d3	d0 08			bne $c3dd			BNE	LAB_22FB		; exit if <>
.c3d5	85 18			sta $18				STA	next_s		; save descriptor stack pointer
.c3d7	e9 03			sbc #$03			SBC	#$03			; -3
.c3d9	85 19			sta $19				STA	last_sl		; save low byte -3
.c3db	a0 00			ldy #$00			LDY	#$00			; clear high byte
.c3dd									LAB_22FB
.c3dd	60				rts					RTS
.c3de									LAB_CHRS
.c3de	20 e9 c4		jsr $c4e9			JSR	LAB_EVBY		; evaluate byte expression, result in X
.c3e1	8a				txa					TXA				; copy to A
.c3e2	48				pha					PHA				; save character
.c3e3	a9 01			lda #$01			LDA	#$01			; string is single byte
.c3e5	20 92 c1		jsr $c192			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.c3e8	68				pla					PLA				; get character back
.c3e9	a0 00			ldy #$00			LDY	#$00			; clear index
.c3eb	91 61			sta ($61),y			STA	(str_pl),Y		; save byte in string (byte IS string!)
.c3ed	4c df c1		jmp $c1df			JMP	LAB_RTST		; check for space on descriptor stack then put string
.c3f0									LAB_LEFT
.c3f0	48				pha					PHA				; push byte parameter
.c3f1	20 51 c4		jsr $c451			JSR	LAB_236F		; pull string data and byte parameter from stack
.c3f4	d1 52			cmp ($52),y			CMP	(des_2l),Y		; compare byte parameter with string length
.c3f6	98				tya					TYA				; clear A
.c3f7	f0 09			beq $c402			BEQ	LAB_2316		; go do string copy (branch always)
.c3f9									LAB_RIGHT
.c3f9	48				pha					PHA				; push byte parameter
.c3fa	20 51 c4		jsr $c451			JSR	LAB_236F		; pull string data and byte parameter from stack
.c3fd	18				clc					CLC				; clear carry for add-1
.c3fe	f1 52			sbc ($52),y			SBC	(des_2l),Y		; subtract string length
.c400	49 ff			eor #$ff			EOR	#$FF			; invert it (A=LEN(expression$)-l)
.c402									LAB_2316
.c402	90 04			bcc $c408			BCC	LAB_231C		; branch if string length > byte parameter
.c404	b1 52			lda ($52),y			LDA	(des_2l),Y		; else make parameter = length
.c406	aa				tax					TAX				; copy to byte parameter copy
.c407	98				tya					TYA				; clear string start offset
.c408									LAB_231C
.c408	48				pha					PHA				; save string start offset
.c409									LAB_231D
.c409	8a				txa					TXA				; copy byte parameter (or string length if <)
.c40a									LAB_231E
.c40a	48				pha					PHA				; save string length
.c40b	20 92 c1		jsr $c192			JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.c40e	a5 52			lda $52				LDA	des_2l		; get descriptor pointer low byte
.c410	a4 53			ldy $53				LDY	des_2h		; get descriptor pointer high byte
.c412	20 9c c3		jsr $c39c			JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.c415	68				pla					PLA				; get string length back
.c416	a8				tay					TAY				; copy length to Y
.c417	68				pla					PLA				; get string start offset back
.c418	18				clc					CLC				; clear carry for add
.c419	65 25			adc $25				ADC	ut1_pl		; add start offset to string start pointer low byte
.c41b	85 25			sta $25				STA	ut1_pl		; save string start pointer low byte
.c41d	90 02			bcc $c421			BCC	LAB_2335		; branch if no overflow
.c41f	e6 26			inc $26				INC	ut1_ph		; else increment string start pointer high byte
.c421									LAB_2335
.c421	98				tya					TYA				; copy length to A
.c422	20 7d c3		jsr $c37d			JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
.c425	4c df c1		jmp $c1df			JMP	LAB_RTST		; check for space on descriptor stack then put string
.c428									LAB_MIDS
.c428	48				pha					PHA				; push byte parameter
.c429	a9 ff			lda #$ff			LDA	#$FF			; set default length = 255
.c42b	85 63			sta $63				STA	mids_l		; save default length
.c42d	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.c430	c9 29			cmp #$29			CMP	#')'			; compare with ")"
.c432	f0 06			beq $c43a			BEQ	LAB_2358		; branch if = ")" (skip second byte get)
.c434	20 46 bc		jsr $bc46			JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.c437	20 e6 c4		jsr $c4e6			JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
.c43a									LAB_2358
.c43a	20 51 c4		jsr $c451			JSR	LAB_236F		; pull string data and byte parameter from stack
.c43d	ca				dex					DEX				; decrement start index
.c43e	8a				txa					TXA				; copy to A
.c43f	48				pha					PHA				; save string start offset
.c440	18				clc					CLC				; clear carry for sub-1
.c441	a2 00			ldx #$00			LDX	#$00			; clear output string length
.c443	f1 52			sbc ($52),y			SBC	(des_2l),Y		; subtract string length
.c445	b0 c2			bcs $c409			BCS	LAB_231D		; if start>string length go do null string
.c447	49 ff			eor #$ff			EOR	#$FF			; complement -length
.c449	c5 63			cmp $63				CMP	mids_l		; compare byte parameter
.c44b	90 bd			bcc $c40a			BCC	LAB_231E		; if length>remaining string go do RIGHT$
.c44d	a5 63			lda $63				LDA	mids_l		; get length byte
.c44f	b0 b9			bcs $c40a			BCS	LAB_231E		; go do string copy (branch always)
.c451									LAB_236F
.c451	20 37 bc		jsr $bc37			JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.c454	68				pla					PLA				; pull return address low byte (return address)
.c455	85 56			sta $56				STA	Fnxjpl		; save functions jump vector low byte
.c457	68				pla					PLA				; pull return address high byte (return address)
.c458	85 57			sta $57				STA	Fnxjph		; save functions jump vector high byte
.c45a	68				pla					PLA				; pull byte parameter
.c45b	aa				tax					TAX				; copy byte parameter to X
.c45c	68				pla					PLA				; pull string pointer low byte
.c45d	85 52			sta $52				STA	des_2l		; save it
.c45f	68				pla					PLA				; pull string pointer high byte
.c460	85 53			sta $53				STA	des_2h		; save it
.c462	a0 00			ldy #$00			LDY	#$00			; clear index
.c464	8a				txa					TXA				; copy byte parameter
.c465	f0 79			beq $c4e0			BEQ	LAB_23A8		; if null do function call error then warm start
.c467	e6 56			inc $56				INC	Fnxjpl		; increment function jump vector low byte
.c469	6c 56 00		jmp ($0056)			JMP	(Fnxjpl)		; in effect, RTS
.c46c									LAB_LCASE
.c46c	20 95 c3		jsr $c395			JSR	LAB_EVST		; evaluate string
.c46f	85 60			sta $60				STA	str_ln		; set string length
.c471	a8				tay					TAY				; copy length to Y
.c472	f0 38			beq $c4ac			BEQ	NoString		; branch if null string
.c474	20 92 c1		jsr $c192			JSR	LAB_MSSP		; make string space A bytes long A=length,
.c477	86 61			stx $61				STX	str_pl		; save string pointer low byte
.c479	84 62			sty $62				STY	str_ph		; save string pointer high byte
.c47b	a8				tay					TAY				; get string length back
.c47c									LC_loop
.c47c	88				dey					DEY				; decrement index
.c47d	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get byte from string
.c47f	20 6c be		jsr $be6c			JSR	LAB_1D82		; is character "A" to "Z"
.c482	90 02			bcc $c486			BCC	NoUcase		; branch if not upper case alpha
.c484	09 20			ora #$20			ORA	#$20			; convert upper to lower case
.c486									NoUcase
.c486	91 37			sta ($37),y			STA	(Sutill),Y		; save byte back to string
.c488	98				tya					TYA				; test index
.c489	d0 f1			bne $c47c			BNE	LC_loop		; loop if not all done
.c48b	f0 1f			beq $c4ac			BEQ	NoString		; tidy up and exit, branch always
.c48d									LAB_UCASE
.c48d	20 95 c3		jsr $c395			JSR	LAB_EVST		; evaluate string
.c490	85 60			sta $60				STA	str_ln		; set string length
.c492	a8				tay					TAY				; copy length to Y
.c493	f0 17			beq $c4ac			BEQ	NoString		; branch if null string
.c495	20 92 c1		jsr $c192			JSR	LAB_MSSP		; make string space A bytes long A=length,
.c498	86 61			stx $61				STX	str_pl		; save string pointer low byte
.c49a	84 62			sty $62				STY	str_ph		; save string pointer high byte
.c49c	a8				tay					TAY				; get string length back
.c49d									UC_loop
.c49d	88				dey					DEY				; decrement index
.c49e	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get byte from string
.c4a0	20 68 be		jsr $be68			JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
.c4a3	90 02			bcc $c4a7			BCC	NoLcase		; branch if not alpha
.c4a5	29 df			and #$df			AND	#$DF			; convert lower to upper case
.c4a7									NoLcase
.c4a7	91 37			sta ($37),y			STA	(Sutill),Y		; save byte back to string
.c4a9	98				tya					TYA				; test index
.c4aa	d0 f1			bne $c49d			BNE	UC_loop		; loop if not all done
.c4ac									NoString
.c4ac	4c df c1		jmp $c1df			JMP	LAB_RTST		; check for space on descriptor stack then put string
.c4af									LAB_SADD
.c4af	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.c4b2	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get var address
.c4b5	20 37 bc		jsr $bc37			JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
.c4b8	20 1a bb		jsr $bb1a			JSR	LAB_CTST		; check if source is string, else do type mismatch
.c4bb	a0 02			ldy #$02			LDY	#$02			; index to string pointer high byte
.c4bd	b1 49			lda ($49),y			LDA	(Cvaral),Y		; get string pointer high byte
.c4bf	aa				tax					TAX				; copy string pointer high byte to X
.c4c0	88				dey					DEY				; index to string pointer low byte
.c4c1	b1 49			lda ($49),y			LDA	(Cvaral),Y		; get string pointer low byte
.c4c3	a8				tay					TAY				; copy string pointer low byte to Y
.c4c4	8a				txa					TXA				; copy string pointer high byte to A
.c4c5	4c a5 c0		jmp $c0a5			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.c4c8									LAB_LENS
.c4c8	20 ce c4		jsr $c4ce			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
.c4cb	4c be c0		jmp $c0be			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
.c4ce									LAB_ESGL
.c4ce	20 95 c3		jsr $c395			JSR	LAB_EVST		; evaluate string
.c4d1	a8				tay					TAY				; copy length to Y
.c4d2	60				rts					RTS
.c4d3									LAB_ASC
.c4d3	20 ce c4		jsr $c4ce			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
.c4d6	f0 08			beq $c4e0			BEQ	LAB_23A8		; if null do function call error then warm start
.c4d8	a0 00			ldy #$00			LDY	#$00			; set index to first character
.c4da	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get byte
.c4dc	a8				tay					TAY				; copy to Y
.c4dd	4c be c0		jmp $c0be			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
.c4e0									LAB_23A8
.c4e0	4c 73 bf		jmp $bf73			JMP	LAB_FCER		; do function call error then warm start
.c4e3									LAB_SGBY
.c4e3	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.c4e6									LAB_GTBY
.c4e6	20 15 bb		jsr $bb15			JSR	LAB_EVNM		; evaluate expression and check is numeric,
.c4e9									LAB_EVBY
.c4e9	20 ec be		jsr $beec			JSR	LAB_EVPI		; evaluate integer expression (no check)
.c4ec	a4 62			ldy $62				LDY	FAC1_2		; get FAC1 mantissa2
.c4ee	d0 f0			bne $c4e0			BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
.c4f0	a6 63			ldx $63				LDX	FAC1_3		; get FAC1 mantissa3
.c4f2	4c 76 00		jmp $0076			JMP	LAB_GBYT		; scan memory and return
.c4f5									LAB_VAL
.c4f5	20 ce c4		jsr $c4ce			JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
.c4f8	d0 03			bne $c4fd			BNE	LAB_23C5		; branch if not null string
.c4fa	4c aa c6		jmp $c6aa			JMP	LAB_24F1		; clear FAC1 exponent and sign and return
.c4fd									LAB_23C5
.c4fd	a6 77			ldx $77				LDX	Bpntrl		; get BASIC execute pointer low byte
.c4ff	a4 78			ldy $78				LDY	Bpntrh		; get BASIC execute pointer high byte
.c501	86 6e			stx $6e				STX	Btmpl			; save BASIC execute pointer low byte
.c503	84 6f			sty $6f				STY	Btmph			; save BASIC execute pointer high byte
.c505	a6 25			ldx $25				LDX	ut1_pl		; get string pointer low byte
.c507	86 77			stx $77				STX	Bpntrl		; save as BASIC execute pointer low byte
.c509	18				clc					CLC				; clear carry
.c50a	65 25			adc $25				ADC	ut1_pl		; add string length
.c50c	85 27			sta $27				STA	ut2_pl		; save string end low byte
.c50e	a5 26			lda $26				LDA	ut1_ph		; get string pointer high byte
.c510	85 78			sta $78				STA	Bpntrh		; save as BASIC execute pointer high byte
.c512	69 00			adc #$00			ADC	#$00			; add carry to high byte
.c514	85 28			sta $28				STA	ut2_ph		; save string end high byte
.c516	a0 00			ldy #$00			LDY	#$00			; set index to $00
.c518	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get string end +1 byte
.c51a	48				pha					PHA				; push it
.c51b	98				tya					TYA				; clear A
.c51c	91 27			sta ($27),y			STA	(ut2_pl),Y		; terminate string with $00
.c51e	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.c521	20 00 ca		jsr $ca00			JSR	LAB_2887		; get FAC1 from string
.c524	68				pla					PLA				; restore string end +1 byte
.c525	a0 00			ldy #$00			LDY	#$00			; set index to zero
.c527	91 27			sta ($27),y			STA	(ut2_pl),Y		; put string end byte back
.c529									LAB_23F3
.c529	a6 6e			ldx $6e				LDX	Btmpl			; get BASIC execute pointer low byte back
.c52b	a4 6f			ldy $6f				LDY	Btmph			; get BASIC execute pointer high byte back
.c52d	86 77			stx $77				STX	Bpntrl		; save BASIC execute pointer low byte
.c52f	84 78			sty $78				STY	Bpntrh		; save BASIC execute pointer high byte
.c531	60				rts					RTS
.c532									LAB_GADB
.c532	20 15 bb		jsr $bb15			JSR	LAB_EVNM		; evaluate expression and check is numeric,
.c535	20 4b c5		jsr $c54b			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.c538									LAB_SCGB
.c538	20 46 bc		jsr $bc46			JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.c53b	a5 0b			lda $0b				LDA	Itemph		; save temporary integer high byte
.c53d	48				pha					PHA				; on stack
.c53e	a5 0a			lda $0a				LDA	Itempl		; save temporary integer low byte
.c540	48				pha					PHA				; on stack
.c541	20 e6 c4		jsr $c4e6			JSR	LAB_GTBY		; get byte parameter
.c544	68				pla					PLA				; pull low byte
.c545	85 0a			sta $0a				STA	Itempl		; restore temporary integer low byte
.c547	68				pla					PLA				; pull high byte
.c548	85 0b			sta $0b				STA	Itemph		; restore temporary integer high byte
.c54a	60				rts					RTS
.c54b									LAB_F2FX
.c54b	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.c54d	c9 98			cmp #$98			CMP	#$98			; compare with exponent = 2^24
.c54f	b0 8f			bcs $c4e0			BCS	LAB_23A8		; if >= do function call error then warm start
.c551									LAB_F2FU
.c551	20 aa c9		jsr $c9aa			JSR	LAB_2831		; convert FAC1 floating-to-fixed
.c554	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.c556	a4 63			ldy $63				LDY	FAC1_3		; get FAC1 mantissa3
.c558	84 0a			sty $0a				STY	Itempl		; save temporary integer low byte
.c55a	85 0b			sta $0b				STA	Itemph		; save temporary integer high byte
.c55c	60				rts					RTS
.c55d									LAB_PEEK
.c55d	20 4b c5		jsr $c54b			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.c560	a2 00			ldx #$00			LDX	#$00			; clear index
.c562	a1 0a			lda ($0a,x)			LDA	(Itempl,X)		; get byte via temporary integer (addr)
.c564	a8				tay					TAY				; copy byte to Y
.c565	4c be c0		jmp $c0be			JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
.c568									LAB_POKE
.c568	20 32 c5		jsr $c532			JSR	LAB_GADB		; get two parameters for POKE or WAIT
.c56b	8a				txa					TXA				; copy byte argument to A
.c56c	a2 00			ldx #$00			LDX	#$00			; clear index
.c56e	81 0a			sta ($0a,x)			STA	(Itempl,X)		; save byte via temporary integer (addr)
.c570	60				rts					RTS
.c571									LAB_DEEK
.c571	20 4b c5		jsr $c54b			JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.c574	a2 00			ldx #$00			LDX	#$00			; clear index
.c576	a1 0a			lda ($0a,x)			LDA	(Itempl,X)		; PEEK low byte
.c578	a8				tay					TAY				; copy to Y
.c579	e6 0a			inc $0a				INC	Itempl		; increment pointer low byte
.c57b	d0 02			bne $c57f			BNE	Deekh			; skip high increment if no rollover
.c57d	e6 0b			inc $0b				INC	Itemph		; increment pointer high byte
.c57f									Deekh
.c57f	a1 0a			lda ($0a,x)			LDA	(Itempl,X)		; PEEK high byte
.c581	4c a5 c0		jmp $c0a5			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.c584									LAB_DOKE
.c584	20 15 bb		jsr $bb15			JSR	LAB_EVNM		; evaluate expression and check is numeric,
.c587	20 4b c5		jsr $c54b			JSR	LAB_F2FX		; convert floating-to-fixed
.c58a	84 4b			sty $4b				STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
.c58c	85 4c			sta $4c				STA	Frnxth		; save pointer high byte
.c58e	20 46 bc		jsr $bc46			JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.c591	20 15 bb		jsr $bb15			JSR	LAB_EVNM		; evaluate expression and check is numeric,
.c594	20 4b c5		jsr $c54b			JSR	LAB_F2FX		; convert floating-to-fixed
.c597	98				tya					TYA				; copy value low byte (float to fixed returns word in AY)
.c598	a2 00			ldx #$00			LDX	#$00			; clear index
.c59a	81 4b			sta ($4b,x)			STA	(Frnxtl,X)		; POKE low byte
.c59c	e6 4b			inc $4b				INC	Frnxtl		; increment pointer low byte
.c59e	d0 02			bne $c5a2			BNE	Dokeh			; skip high increment if no rollover
.c5a0	e6 4c			inc $4c				INC	Frnxth		; increment pointer high byte
.c5a2									Dokeh
.c5a2	a5 0b			lda $0b				LDA	Itemph		; get value high byte
.c5a4	81 4b			sta ($4b,x)			STA	(Frnxtl,X)		; POKE high byte
.c5a6	4c 76 00		jmp $0076			JMP	LAB_GBYT		; scan memory and return
.c5a9									LAB_SWAP
.c5a9	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get var1 address
.c5ac	85 4b			sta $4b				STA	Lvarpl		; save var1 address low byte
.c5ae	84 4c			sty $4c				STY	Lvarph		; save var1 address high byte
.c5b0	a5 11			lda $11				LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.c5b2	48				pha					PHA				; save data type flag
.c5b3	20 46 bc		jsr $bc46			JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.c5b6	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
.c5b9	68				pla					PLA				; pull var1 data type flag
.c5ba	45 11			eor $11				EOR	Dtypef		; compare with var2 data type
.c5bc	10 10			bpl $c5ce			BPL	SwapErr		; exit if not both the same type
.c5be	a0 03			ldy #$03			LDY	#$03			; four bytes to swap (either value or descriptor+1)
.c5c0									SwapLp
.c5c0	b1 4b			lda ($4b),y			LDA	(Lvarpl),Y		; get byte from var1
.c5c2	aa				tax					TAX				; save var1 byte
.c5c3	b1 49			lda ($49),y			LDA	(Cvaral),Y		; get byte from var2
.c5c5	91 4b			sta ($4b),y			STA	(Lvarpl),Y		; save byte to var1
.c5c7	8a				txa					TXA				; restore var1 byte
.c5c8	91 49			sta ($49),y			STA	(Cvaral),Y		; save byte to var2
.c5ca	88				dey					DEY				; decrement index
.c5cb	10 f3			bpl $c5c0			BPL	SwapLp		; loop until done
.c5cd	60				rts					RTS
.c5ce									SwapErr
.c5ce	4c 24 bb		jmp $bb24			JMP	LAB_1ABC		; do "Type mismatch" error then warm start
.c5d1									LAB_CALL
.c5d1	20 15 bb		jsr $bb15			JSR	LAB_EVNM		; evaluate expression and check is numeric,
.c5d4	20 4b c5		jsr $c54b			JSR	LAB_F2FX		; convert floating-to-fixed
.c5d7	a9 c5			lda #$c5			LDA	#>CallExit		; set return address high byte
.c5d9	48				pha					PHA				; put on stack
.c5da	a9 df			lda #$df			LDA	#<CallExit-1	; set return address low byte
.c5dc	48				pha					PHA				; put on stack
.c5dd	6c 0a 00		jmp ($000a)			JMP	(Itempl)		; do indirect jump to user routine
.c5e0									CallExit
.c5e0	4c 76 00		jmp $0076			JMP	LAB_GBYT		; scan memory and return
.c5e3									LAB_WAIT
.c5e3	20 32 c5		jsr $c532			JSR	LAB_GADB		; get two parameters for POKE or WAIT
.c5e6	86 4b			stx $4b				STX	Frnxtl		; save byte
.c5e8	a2 00			ldx #$00			LDX	#$00			; clear mask
.c5ea	20 76 00		jsr $0076			JSR	LAB_GBYT		; scan memory
.c5ed	f0 03			beq $c5f2			BEQ	LAB_2441		; skip if no third argument
.c5ef	20 38 c5		jsr $c538			JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
.c5f2									LAB_2441
.c5f2	86 4c			stx $4c				STX	Frnxth		; save EOR argument
.c5f4									LAB_2445
.c5f4	b1 0a			lda ($0a),y			LDA	(Itempl),Y		; get byte via temporary integer (addr)
.c5f6	45 4c			eor $4c				EOR	Frnxth		; EOR with second argument (mask)
.c5f8	25 4b			and $4b				AND	Frnxtl		; AND with first argument (byte)
.c5fa	f0 f8			beq $c5f4			BEQ	LAB_2445		; loop if result is zero
.c5fc									LAB_244D
.c5fc	60				rts					RTS
.c5fd									LAB_2455
.c5fd	20 e5 c7		jsr $c7e5			JSR	LAB_264D		; unpack memory (AY) into FAC2
.c600									LAB_SUBTRACT
.c600	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.c602	49 ff			eor #$ff			EOR	#$FF			; complement it
.c604	85 64			sta $64				STA	FAC1_s		; save FAC1 sign (b7)
.c606	45 6b			eor $6b				EOR	FAC2_s		; EOR with FAC2 sign (b7)
.c608	85 6c			sta $6c				STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.c60a	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.c60c	4c 1b c6		jmp $c61b			JMP	LAB_ADD		; go add FAC2 to FAC1
.c60f									LAB_2467
.c60f	20 34 c7		jsr $c734			JSR	LAB_257B		; shift FACX A times right (>8 shifts)
.c612	90 4d			bcc $c661			BCC	LAB_24A8		;.go subtract mantissas
.c614									LAB_244E
.c614	a9 41			lda #$41			LDA	#<LAB_2A96		; set 0.5 pointer low byte
.c616	a0 d2			ldy #$d2			LDY	#>LAB_2A96		; set 0.5 pointer high byte
.c618									LAB_246C
.c618	20 e5 c7		jsr $c7e5			JSR	LAB_264D		; unpack memory (AY) into FAC2
.c61b									LAB_ADD
.c61b	d0 10			bne $c62d			BNE	LAB_2474		; branch if FAC1 was not zero
.c61d									LAB_279B
.c61d	a5 6b			lda $6b				LDA	FAC2_s		; get FAC2 sign (b7)
.c61f									LAB_279D
.c61f	85 64			sta $64				STA	FAC1_s		; save FAC1 sign (b7)
.c621	a2 04			ldx #$04			LDX	#$04			; 4 bytes to copy
.c623									LAB_27A1
.c623	b5 66			lda $66,x			LDA	FAC1_o,X		; get byte from FAC2,X
.c625	95 5f			sta $5f,x			STA	FAC1_e-1,X		; save byte at FAC1,X
.c627	ca				dex					DEX				; decrement count
.c628	d0 f9			bne $c623			BNE	LAB_27A1		; loop if not all done
.c62a	86 6d			stx $6d				STX	FAC1_r		; clear FAC1 rounding byte
.c62c	60				rts					RTS
.c62d									LAB_2474
.c62d	a6 6d			ldx $6d				LDX	FAC1_r		; get FAC1 rounding byte
.c62f	86 58			stx $58				STX	FAC2_r		; save as FAC2 rounding byte
.c631	a2 67			ldx #$67			LDX	#FAC2_e		; set index to FAC2 exponent addr
.c633	a5 67			lda $67				LDA	FAC2_e		; get FAC2 exponent
.c635									LAB_247C
.c635	a8				tay					TAY				; copy exponent
.c636	f0 c4			beq $c5fc			BEQ	LAB_244D		; exit if zero
.c638	38				sec					SEC				; set carry for subtract
.c639	e5 60			sbc $60				SBC	FAC1_e		; subtract FAC1 exponent
.c63b	f0 24			beq $c661			BEQ	LAB_24A8		; branch if = (go add mantissa)
.c63d	90 12			bcc $c651			BCC	LAB_2498		; branch if <
.c63f	84 60			sty $60				STY	FAC1_e		; save FAC1 exponent
.c641	a4 6b			ldy $6b				LDY	FAC2_s		; get FAC2 sign (b7)
.c643	84 64			sty $64				STY	FAC1_s		; save FAC1 sign (b7)
.c645	49 ff			eor #$ff			EOR	#$FF			; complement A
.c647	69 00			adc #$00			ADC	#$00			; +1 (twos complement, carry is set)
.c649	a0 00			ldy #$00			LDY	#$00			; clear Y
.c64b	84 58			sty $58				STY	FAC2_r		; clear FAC2 rounding byte
.c64d	a2 60			ldx #$60			LDX	#FAC1_e		; set index to FAC1 exponent addr
.c64f	d0 04			bne $c655			BNE	LAB_249C		; branch always
.c651									LAB_2498
.c651	a0 00			ldy #$00			LDY	#$00			; clear Y
.c653	84 6d			sty $6d				STY	FAC1_r		; clear FAC1 rounding byte
.c655									LAB_249C
.c655	c9 f9			cmp #$f9			CMP	#$F9			; compare exponent diff with $F9
.c657	30 b6			bmi $c60f			BMI	LAB_2467		; branch if range $79-$F8
.c659	a8				tay					TAY				; copy exponent difference to Y
.c65a	a5 6d			lda $6d				LDA	FAC1_r		; get FAC1 rounding byte
.c65c	56 01			lsr $01,x			LSR	PLUS_1,X		; shift FAC? mantissa1
.c65e	20 4b c7		jsr $c74b			JSR	LAB_2592		; shift FACX Y times right
.c661									LAB_24A8
.c661	24 6c			bit $6c				BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
.c663	10 4c			bpl $c6b1			BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
.c665	a0 60			ldy #$60			LDY	#FAC1_e		; set index to FAC1 exponent addr
.c667	e0 67			cpx #$67			CPX	#FAC2_e		; compare X to FAC2 exponent addr
.c669	f0 02			beq $c66d			BEQ	LAB_24B4		; branch if =
.c66b	a0 67			ldy #$67			LDY	#FAC2_e		; else set index to FAC2 exponent addr
.c66d									LAB_24B4
.c66d	38				sec					SEC				; set carry for subtract
.c66e	49 ff			eor #$ff			EOR	#$FF			; ones complement A
.c670	65 58			adc $58				ADC	FAC2_r		; add FAC2 rounding byte
.c672	85 6d			sta $6d				STA	FAC1_r		; save FAC1 rounding byte
.c674	b9 03 00		lda $0003,y			LDA	PLUS_3,Y		; get FACY mantissa3
.c677	f5 03			sbc $03,x			SBC	PLUS_3,X		; subtract FACX mantissa3
.c679	85 63			sta $63				STA	FAC1_3		; save FAC1 mantissa3
.c67b	b9 02 00		lda $0002,y			LDA	PLUS_2,Y		; get FACY mantissa2
.c67e	f5 02			sbc $02,x			SBC	PLUS_2,X		; subtract FACX mantissa2
.c680	85 62			sta $62				STA	FAC1_2		; save FAC1 mantissa2
.c682	b9 01 00		lda $0001,y			LDA	PLUS_1,Y		; get FACY mantissa1
.c685	f5 01			sbc $01,x			SBC	PLUS_1,X		; subtract FACX mantissa1
.c687	85 61			sta $61				STA	FAC1_1		; save FAC1 mantissa1
.c689									LAB_24D0
.c689	b0 03			bcs $c68e			BCS	LAB_24D5		; branch if number is +ve
.c68b	20 f0 c6		jsr $c6f0			JSR	LAB_2537		; negate FAC1
.c68e									LAB_24D5
.c68e	a0 00			ldy #$00			LDY	#$00			; clear Y
.c690	98				tya					TYA				; clear A
.c691	18				clc					CLC				; clear carry for add
.c692									LAB_24D9
.c692	a6 61			ldx $61				LDX	FAC1_1		; get FAC1 mantissa1
.c694	d0 3e			bne $c6d4			BNE	LAB_251B		; if not zero normalise FAC1
.c696	a6 62			ldx $62				LDX	FAC1_2		; get FAC1 mantissa2
.c698	86 61			stx $61				STX	FAC1_1		; save FAC1 mantissa1
.c69a	a6 63			ldx $63				LDX	FAC1_3		; get FAC1 mantissa3
.c69c	86 62			stx $62				STX	FAC1_2		; save FAC1 mantissa2
.c69e	a6 6d			ldx $6d				LDX	FAC1_r		; get FAC1 rounding byte
.c6a0	86 63			stx $63				STX	FAC1_3		; save FAC1 mantissa3
.c6a2	84 6d			sty $6d				STY	FAC1_r		; clear FAC1 rounding byte
.c6a4	69 08			adc #$08			ADC	#$08			; add x to exponent offset
.c6a6	c9 18			cmp #$18			CMP	#$18			; compare with $18 (max offset, all bits would be =0)
.c6a8	d0 e8			bne $c692			BNE	LAB_24D9		; loop if not max
.c6aa									LAB_24F1
.c6aa	a9 00			lda #$00			LDA	#$00			; clear A
.c6ac									LAB_24F3
.c6ac	85 60			sta $60				STA	FAC1_e		; set FAC1 exponent
.c6ae									LAB_24F5
.c6ae	85 64			sta $64				STA	FAC1_s		; save FAC1 sign (b7)
.c6b0	60				rts					RTS
.c6b1									LAB_24F8
.c6b1	65 58			adc $58				ADC	FAC2_r		; add FAC2 rounding byte
.c6b3	85 6d			sta $6d				STA	FAC1_r		; save FAC1 rounding byte
.c6b5	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.c6b7	65 6a			adc $6a				ADC	FAC2_3		; add FAC2 mantissa3
.c6b9	85 63			sta $63				STA	FAC1_3		; save FAC1 mantissa3
.c6bb	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.c6bd	65 69			adc $69				ADC	FAC2_2		; add FAC2 mantissa2
.c6bf	85 62			sta $62				STA	FAC1_2		; save FAC1 mantissa2
.c6c1	a5 61			lda $61				LDA	FAC1_1		; get FAC1 mantissa1
.c6c3	65 68			adc $68				ADC	FAC2_1		; add FAC2 mantissa1
.c6c5	85 61			sta $61				STA	FAC1_1		; save FAC1 mantissa1
.c6c7	b0 1a			bcs $c6e3			BCS	LAB_252A		; if carry then normalise FAC1 for C=1
.c6c9	60				rts					RTS				; else just exit
.c6ca									LAB_2511
.c6ca	69 01			adc #$01			ADC	#$01			; add 1 to exponent offset
.c6cc	06 6d			asl $6d				ASL	FAC1_r		; shift FAC1 rounding byte
.c6ce	26 63			rol $63				ROL	FAC1_3		; shift FAC1 mantissa3
.c6d0	26 62			rol $62				ROL	FAC1_2		; shift FAC1 mantissa2
.c6d2	26 61			rol $61				ROL	FAC1_1		; shift FAC1 mantissa1
.c6d4									LAB_251B
.c6d4	10 f4			bpl $c6ca			BPL	LAB_2511		; loop if not normalised
.c6d6	38				sec					SEC				; set carry for subtract
.c6d7	e5 60			sbc $60				SBC	FAC1_e		; subtract FAC1 exponent
.c6d9	b0 cf			bcs $c6aa			BCS	LAB_24F1		; branch if underflow (set result = $0)
.c6db	49 ff			eor #$ff			EOR	#$FF			; complement exponent
.c6dd	69 01			adc #$01			ADC	#$01			; +1 (twos complement)
.c6df	85 60			sta $60				STA	FAC1_e		; save FAC1 exponent
.c6e1									LAB_2528
.c6e1	90 0c			bcc $c6ef			BCC	LAB_2536		; exit if no overflow
.c6e3									LAB_252A
.c6e3	e6 60			inc $60				INC	FAC1_e		; increment FAC1 exponent
.c6e5	f0 36			beq $c71d			BEQ	LAB_2564		; if zero do overflow error and warm start
.c6e7	66 61			ror $61				ROR	FAC1_1		; shift FAC1 mantissa1
.c6e9	66 62			ror $62				ROR	FAC1_2		; shift FAC1 mantissa2
.c6eb	66 63			ror $63				ROR	FAC1_3		; shift FAC1 mantissa3
.c6ed	66 6d			ror $6d				ROR	FAC1_r		; shift FAC1 rounding byte
.c6ef									LAB_2536
.c6ef	60				rts					RTS
.c6f0									LAB_2537
.c6f0	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.c6f2	49 ff			eor #$ff			EOR	#$FF			; complement it
.c6f4	85 64			sta $64				STA	FAC1_s		; save FAC1 sign (b7)
.c6f6									LAB_253D
.c6f6	a5 61			lda $61				LDA	FAC1_1		; get FAC1 mantissa1
.c6f8	49 ff			eor #$ff			EOR	#$FF			; complement it
.c6fa	85 61			sta $61				STA	FAC1_1		; save FAC1 mantissa1
.c6fc	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.c6fe	49 ff			eor #$ff			EOR	#$FF			; complement it
.c700	85 62			sta $62				STA	FAC1_2		; save FAC1 mantissa2
.c702	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.c704	49 ff			eor #$ff			EOR	#$FF			; complement it
.c706	85 63			sta $63				STA	FAC1_3		; save FAC1 mantissa3
.c708	a5 6d			lda $6d				LDA	FAC1_r		; get FAC1 rounding byte
.c70a	49 ff			eor #$ff			EOR	#$FF			; complement it
.c70c	85 6d			sta $6d				STA	FAC1_r		; save FAC1 rounding byte
.c70e	e6 6d			inc $6d				INC	FAC1_r		; increment FAC1 rounding byte
.c710	d0 0a			bne $c71c			BNE	LAB_2563		; exit if no overflow
.c712									LAB_2559
.c712	e6 63			inc $63				INC	FAC1_3		; increment FAC1 mantissa3
.c714	d0 06			bne $c71c			BNE	LAB_2563		; finished if no rollover
.c716	e6 62			inc $62				INC	FAC1_2		; increment FAC1 mantissa2
.c718	d0 02			bne $c71c			BNE	LAB_2563		; finished if no rollover
.c71a	e6 61			inc $61				INC	FAC1_1		; increment FAC1 mantissa1
.c71c									LAB_2563
.c71c	60				rts					RTS
.c71d									LAB_2564
.c71d	a2 0a			ldx #$0a			LDX	#$0A			; error code $0A ("Overflow" error)
.c71f	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; do error #X, then warm start
.c722									LAB_2569
.c722	a2 28			ldx #$28			LDX	#FACt_1-1		; set offset to FACtemp
.c724									LAB_256B
.c724	b4 03			ldy $03,x			LDY	PLUS_3,X		; get FACX mantissa3
.c726	84 6d			sty $6d				STY	FAC1_r		; save as FAC1 rounding byte
.c728	b4 02			ldy $02,x			LDY	PLUS_2,X		; get FACX mantissa2
.c72a	94 03			sty $03,x			STY	PLUS_3,X		; save FACX mantissa3
.c72c	b4 01			ldy $01,x			LDY	PLUS_1,X		; get FACX mantissa1
.c72e	94 02			sty $02,x			STY	PLUS_2,X		; save FACX mantissa2
.c730	a4 66			ldy $66				LDY	FAC1_o		; get FAC1 overflow byte
.c732	94 01			sty $01,x			STY	PLUS_1,X		; save FACX mantissa1
.c734									LAB_257B
.c734	69 08			adc #$08			ADC	#$08			; add 8 to shift count
.c736	30 ec			bmi $c724			BMI	LAB_256B		; go do 8 shift if still -ve
.c738	f0 ea			beq $c724			BEQ	LAB_256B		; go do 8 shift if zero
.c73a	e9 08			sbc #$08			SBC	#$08			; else subtract 8 again
.c73c	a8				tay					TAY				; save count to Y
.c73d	a5 6d			lda $6d				LDA	FAC1_r		; get FAC1 rounding byte
.c73f	b0 12			bcs $c753			BCS	LAB_259A		;.
.c741									LAB_2588
.c741	16 01			asl $01,x			ASL	PLUS_1,X		; shift FACX mantissa1
.c743	90 02			bcc $c747			BCC	LAB_258E		; branch if +ve
.c745	f6 01			inc $01,x			INC	PLUS_1,X		; this sets b7 eventually
.c747									LAB_258E
.c747	76 01			ror $01,x			ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
.c749	76 01			ror $01,x			ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
.c74b									LAB_2592
.c74b	76 02			ror $02,x			ROR	PLUS_2,X		; shift FACX mantissa2
.c74d	76 03			ror $03,x			ROR	PLUS_3,X		; shift FACX mantissa3
.c74f	6a				ror a				ROR				; shift FACX rounding byte
.c750	c8				iny					INY				; increment exponent diff
.c751	d0 ee			bne $c741			BNE	LAB_2588		; branch if range adjust not complete
.c753									LAB_259A
.c753	18				clc					CLC				; just clear it
.c754	60				rts					RTS
.c755									LAB_LOG
.c755	20 43 c9		jsr $c943			JSR	LAB_27CA		; test sign and zero
.c758	f0 02			beq $c75c			BEQ	LAB_25C4		; if zero do function call error then warm start
.c75a	10 03			bpl $c75f			BPL	LAB_25C7		; skip error if +ve
.c75c									LAB_25C4
.c75c	4c 73 bf		jmp $bf73			JMP	LAB_FCER		; do function call error then warm start (-ve)
.c75f									LAB_25C7
.c75f	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.c761	e9 7f			sbc #$7f			SBC	#$7F			; normalise it
.c763	48				pha					PHA				; save it
.c764	a9 80			lda #$80			LDA	#$80			; set exponent to zero
.c766	85 60			sta $60				STA	FAC1_e		; save FAC1 exponent
.c768	a9 c1			lda #$c1			LDA	#<LAB_25AD		; set 1/root2 pointer low byte
.c76a	a0 d1			ldy #$d1			LDY	#>LAB_25AD		; set 1/root2 pointer high byte
.c76c	20 18 c6		jsr $c618			JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
.c76f	a9 c5			lda #$c5			LDA	#<LAB_25B1		; set root2 pointer low byte
.c771	a0 d1			ldy #$d1			LDY	#>LAB_25B1		; set root2 pointer high byte
.c773	20 5b c8		jsr $c85b			JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
.c776	a9 38			lda #$38			LDA	#<LAB_259C		; set 1 pointer low byte
.c778	a0 d2			ldy #$d2			LDY	#>LAB_259C		; set 1 pointer high byte
.c77a	20 fd c5		jsr $c5fd			JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
.c77d	a9 b4			lda #$b4			LDA	#<LAB_25A0		; set pointer low byte to counter
.c77f	a0 d1			ldy #$d1			LDY	#>LAB_25A0		; set pointer high byte to counter
.c781	20 ab cc		jsr $ccab			JSR	LAB_2B6E		; ^2 then series evaluation
.c784	a9 c9			lda #$c9			LDA	#<LAB_25B5		; set -0.5 pointer low byte
.c786	a0 d1			ldy #$d1			LDY	#>LAB_25B5		; set -0.5 pointer high byte
.c788	20 18 c6		jsr $c618			JSR	LAB_246C		; add (AY) to FAC1
.c78b	68				pla					PLA				; restore FAC1 exponent
.c78c	20 9f ca		jsr $ca9f			JSR	LAB_2912		; evaluate new ASCII digit
.c78f	a9 cd			lda #$cd			LDA	#<LAB_25B9		; set LOG(2) pointer low byte
.c791	a0 d1			ldy #$d1			LDY	#>LAB_25B9		; set LOG(2) pointer high byte
.c793									LAB_25FB
.c793	20 e5 c7		jsr $c7e5			JSR	LAB_264D		; unpack memory (AY) into FAC2
.c796									LAB_MULTIPLY
.c796	f0 4c			beq $c7e4			BEQ	LAB_264C		; exit if zero
.c798	20 0b c8		jsr $c80b			JSR	LAB_2673		; test and adjust accumulators
.c79b	a9 00			lda #$00			LDA	#$00			; clear A
.c79d	85 29			sta $29				STA	FACt_1		; clear temp mantissa1
.c79f	85 2a			sta $2a				STA	FACt_2		; clear temp mantissa2
.c7a1	85 2b			sta $2b				STA	FACt_3		; clear temp mantissa3
.c7a3	a5 6d			lda $6d				LDA	FAC1_r		; get FAC1 rounding byte
.c7a5	20 ba c7		jsr $c7ba			JSR	LAB_2622		; go do shift/add FAC2
.c7a8	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.c7aa	20 ba c7		jsr $c7ba			JSR	LAB_2622		; go do shift/add FAC2
.c7ad	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.c7af	20 ba c7		jsr $c7ba			JSR	LAB_2622		; go do shift/add FAC2
.c7b2	a5 61			lda $61				LDA	FAC1_1		; get FAC1 mantissa1
.c7b4	20 bf c7		jsr $c7bf			JSR	LAB_2627		; go do shift/add FAC2
.c7b7	4c c8 c8		jmp $c8c8			JMP	LAB_273C		; copy temp to FAC1, normalise and return
.c7ba									LAB_2622
.c7ba	d0 03			bne $c7bf			BNE	LAB_2627		; branch if byte <> zero
.c7bc	4c 22 c7		jmp $c722			JMP	LAB_2569		; shift FCAtemp << A+8 times
.c7bf									LAB_2627
.c7bf	4a				lsr a				LSR				; shift byte
.c7c0	09 80			ora #$80			ORA	#$80			; set top bit (mark for 8 times)
.c7c2									LAB_262A
.c7c2	a8				tay					TAY				; copy result
.c7c3	90 13			bcc $c7d8			BCC	LAB_2640		; skip next if bit was zero
.c7c5	18				clc					CLC				; clear carry for add
.c7c6	a5 2b			lda $2b				LDA	FACt_3		; get temp mantissa3
.c7c8	65 6a			adc $6a				ADC	FAC2_3		; add FAC2 mantissa3
.c7ca	85 2b			sta $2b				STA	FACt_3		; save temp mantissa3
.c7cc	a5 2a			lda $2a				LDA	FACt_2		; get temp mantissa2
.c7ce	65 69			adc $69				ADC	FAC2_2		; add FAC2 mantissa2
.c7d0	85 2a			sta $2a				STA	FACt_2		; save temp mantissa2
.c7d2	a5 29			lda $29				LDA	FACt_1		; get temp mantissa1
.c7d4	65 68			adc $68				ADC	FAC2_1		; add FAC2 mantissa1
.c7d6	85 29			sta $29				STA	FACt_1		; save temp mantissa1
.c7d8									LAB_2640
.c7d8	66 29			ror $29				ROR	FACt_1		; shift temp mantissa1
.c7da	66 2a			ror $2a				ROR	FACt_2		; shift temp mantissa2
.c7dc	66 2b			ror $2b				ROR	FACt_3		; shift temp mantissa3
.c7de	66 6d			ror $6d				ROR	FAC1_r		; shift temp rounding byte
.c7e0	98				tya					TYA				; get byte back
.c7e1	4a				lsr a				LSR				; shift byte
.c7e2	d0 de			bne $c7c2			BNE	LAB_262A		; loop if all bits not done
.c7e4									LAB_264C
.c7e4	60				rts					RTS
.c7e5									LAB_264D
.c7e5	85 25			sta $25				STA	ut1_pl		; save pointer low byte
.c7e7	84 26			sty $26				STY	ut1_ph		; save pointer high byte
.c7e9	a0 03			ldy #$03			LDY	#$03			; 4 bytes to get (0-3)
.c7eb	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get mantissa3
.c7ed	85 6a			sta $6a				STA	FAC2_3		; save FAC2 mantissa3
.c7ef	88				dey					DEY				; decrement index
.c7f0	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get mantissa2
.c7f2	85 69			sta $69				STA	FAC2_2		; save FAC2 mantissa2
.c7f4	88				dey					DEY				; decrement index
.c7f5	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get mantissa1+sign
.c7f7	85 6b			sta $6b				STA	FAC2_s		; save FAC2 sign (b7)
.c7f9	45 64			eor $64				EOR	FAC1_s		; EOR with FAC1 sign (b7)
.c7fb	85 6c			sta $6c				STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.c7fd	a5 6b			lda $6b				LDA	FAC2_s		; recover FAC2 sign (b7)
.c7ff	09 80			ora #$80			ORA	#$80			; set 1xxx xxx (set normal bit)
.c801	85 68			sta $68				STA	FAC2_1		; save FAC2 mantissa1
.c803	88				dey					DEY				; decrement index
.c804	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get exponent byte
.c806	85 67			sta $67				STA	FAC2_e		; save FAC2 exponent
.c808	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.c80a	60				rts					RTS
.c80b									LAB_2673
.c80b	a5 67			lda $67				LDA	FAC2_e		; get FAC2 exponent
.c80d									LAB_2675
.c80d	f0 1d			beq $c82c			BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
.c80f	18				clc					CLC				; clear carry for add
.c810	65 60			adc $60				ADC	FAC1_e		; add FAC1 exponent
.c812	90 04			bcc $c818			BCC	LAB_2680		; branch if sum of exponents <$0100
.c814	30 31			bmi $c847			BMI	LAB_269B		; do overflow error
.c816	18				clc					CLC				; clear carry for the add
>c817	2c									.byte	$2C			; makes next line BIT $1410
.c818									LAB_2680
.c818	10 12			bpl $c82c			BPL	LAB_2696		; if +ve go handle underflow
.c81a	69 80			adc #$80			ADC	#$80			; adjust exponent
.c81c	85 60			sta $60				STA	FAC1_e		; save FAC1 exponent
.c81e	d0 03			bne $c823			BNE	LAB_268B		; branch if not zero
.c820	4c ae c6		jmp $c6ae			JMP	LAB_24F5		; save FAC1 sign and return
.c823									LAB_268B
.c823	a5 6c			lda $6c				LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
.c825	85 64			sta $64				STA	FAC1_s		; save FAC1 sign (b7)
.c827									LAB_268F
.c827	60				rts					RTS
.c828									LAB_2690
.c828	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.c82a	10 1b			bpl $c847			BPL	LAB_269B		; do overflow error
.c82c									LAB_2696
.c82c	68				pla					PLA				; pop return address low byte
.c82d	68				pla					PLA				; pop return address high byte
.c82e	4c aa c6		jmp $c6aa			JMP	LAB_24F1		; clear FAC1 exponent and sign and return
.c831									LAB_269E
.c831	20 24 c9		jsr $c924			JSR	LAB_27AB		; round and copy FAC1 to FAC2
.c834	aa				tax					TAX				; copy exponent (set the flags)
.c835	f0 f0			beq $c827			BEQ	LAB_268F		; exit if zero
.c837	18				clc					CLC				; clear carry for add
.c838	69 02			adc #$02			ADC	#$02			; add two to exponent (*4)
.c83a	b0 0b			bcs $c847			BCS	LAB_269B		; do overflow error if > $FF
.c83c	a2 00			ldx #$00			LDX	#$00			; clear byte
.c83e	86 6c			stx $6c				STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.c840	20 35 c6		jsr $c635			JSR	LAB_247C		; add FAC2 to FAC1 (*5)
.c843	e6 60			inc $60				INC	FAC1_e		; increment FAC1 exponent (*10)
.c845	d0 e0			bne $c827			BNE	LAB_268F		; if non zero just do RTS
.c847									LAB_269B
.c847	4c 1d c7		jmp $c71d			JMP	LAB_2564		; do overflow error and warm start
.c84a									LAB_26B9
.c84a	20 24 c9		jsr $c924			JSR	LAB_27AB		; round and copy FAC1 to FAC2
.c84d	a9 49			lda #$49			LDA	#<LAB_26B5		; set pointer to 10d low addr
.c84f	a0 d2			ldy #$d2			LDY	#>LAB_26B5		; set pointer to 10d high addr
.c851	a2 00			ldx #$00			LDX	#$00			; clear sign
.c853									LAB_26C2
.c853	86 6c			stx $6c				STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.c855	20 d7 c8		jsr $c8d7			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.c858	4c 5e c8		jmp $c85e			JMP	LAB_DIVIDE		; do FAC2/FAC1
.c85b									LAB_26CA
.c85b	20 e5 c7		jsr $c7e5			JSR	LAB_264D		; unpack memory (AY) into FAC2
.c85e									LAB_DIVIDE
.c85e	f0 63			beq $c8c3			BEQ	LAB_2737		; if zero go do /0 error
.c860	20 33 c9		jsr $c933			JSR	LAB_27BA		; round FAC1
.c863	a9 00			lda #$00			LDA	#$00			; clear A
.c865	38				sec					SEC				; set carry for subtract
.c866	e5 60			sbc $60				SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
.c868	85 60			sta $60				STA	FAC1_e		; save FAC1 exponent
.c86a	20 0b c8		jsr $c80b			JSR	LAB_2673		; test and adjust accumulators
.c86d	e6 60			inc $60				INC	FAC1_e		; increment FAC1 exponent
.c86f	f0 d6			beq $c847			BEQ	LAB_269B		; if zero do overflow error
.c871	a2 ff			ldx #$ff			LDX	#$FF			; set index for pre increment
.c873	a9 01			lda #$01			LDA	#$01			; set bit to flag byte save
.c875									LAB_26E4
.c875	a4 68			ldy $68				LDY	FAC2_1		; get FAC2 mantissa1
.c877	c4 61			cpy $61				CPY	FAC1_1		; compare FAC1 mantissa1
.c879	d0 0a			bne $c885			BNE	LAB_26F4		; branch if <>
.c87b	a4 69			ldy $69				LDY	FAC2_2		; get FAC2 mantissa2
.c87d	c4 62			cpy $62				CPY	FAC1_2		; compare FAC1 mantissa2
.c87f	d0 04			bne $c885			BNE	LAB_26F4		; branch if <>
.c881	a4 6a			ldy $6a				LDY	FAC2_3		; get FAC2 mantissa3
.c883	c4 63			cpy $63				CPY	FAC1_3		; compare FAC1 mantissa3
.c885									LAB_26F4
.c885	08				php					PHP				; save FAC2-FAC1 compare status
.c886	2a				rol a				ROL				; shift the result byte
.c887	90 0e			bcc $c897			BCC	LAB_2702		; if no carry skip the byte save
.c889	a0 01			ldy #$01			LDY	#$01			; set bit to flag byte save
.c88b	e8				inx					INX				; else increment the index to FACt
.c88c	e0 02			cpx #$02			CPX	#$02			; compare with the index to FACt_3
.c88e	30 04			bmi $c894			BMI	LAB_2701		; if not last byte just go save it
.c890	d0 28			bne $c8ba			BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
.c892	a0 40			ldy #$40			LDY	#$40			; set bit to flag byte save for the rounding byte
.c894									LAB_2701
.c894	95 29			sta $29,x			STA	FACt_1,X		; write result byte to FACt_1 + index
.c896	98				tya					TYA				; copy the next save byte flag
.c897									LAB_2702
.c897	28				plp					PLP				; restore FAC2-FAC1 compare status
.c898	90 14			bcc $c8ae			BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
.c89a	a8				tay					TAY				; save FAC2-FAC1 compare status
.c89b	a5 6a			lda $6a				LDA	FAC2_3		; get FAC2 mantissa3
.c89d	e5 63			sbc $63				SBC	FAC1_3		; subtract FAC1 mantissa3
.c89f	85 6a			sta $6a				STA	FAC2_3		; save FAC2 mantissa3
.c8a1	a5 69			lda $69				LDA	FAC2_2		; get FAC2 mantissa2
.c8a3	e5 62			sbc $62				SBC	FAC1_2		; subtract FAC1 mantissa2
.c8a5	85 69			sta $69				STA	FAC2_2		; save FAC2 mantissa2
.c8a7	a5 68			lda $68				LDA	FAC2_1		; get FAC2 mantissa1
.c8a9	e5 61			sbc $61				SBC	FAC1_1		; subtract FAC1 mantissa1
.c8ab	85 68			sta $68				STA	FAC2_1		; save FAC2 mantissa1
.c8ad	98				tya					TYA				; restore FAC2-FAC1 compare status
.c8ae									LAB_2704
.c8ae	06 6a			asl $6a				ASL	FAC2_3		; shift FAC2 mantissa3
.c8b0	26 69			rol $69				ROL	FAC2_2		; shift FAC2 mantissa2
.c8b2	26 68			rol $68				ROL	FAC2_1		; shift FAC2 mantissa1
.c8b4	b0 cf			bcs $c885			BCS	LAB_26F4		; loop with no compare
.c8b6	30 bd			bmi $c875			BMI	LAB_26E4		; loop with compare
.c8b8	10 cb			bpl $c885			BPL	LAB_26F4		; loop always with no compare
.c8ba									LAB_272B
.c8ba	4a				lsr a				LSR				; shift b1 - b0 ..
.c8bb	6a				ror a				ROR				; ..
.c8bc	6a				ror a				ROR				; .. to b7 - b6
.c8bd	85 6d			sta $6d				STA	FAC1_r		; save FAC1 rounding byte
.c8bf	28				plp					PLP				; dump FAC2-FAC1 compare status
.c8c0	4c c8 c8		jmp $c8c8			JMP	LAB_273C		; copy temp to FAC1, normalise and return
.c8c3									LAB_2737
.c8c3	a2 14			ldx #$14			LDX	#$14			; error code $14 ("Divide by zero" error)
.c8c5	4c 8f b1		jmp $b18f			JMP	LAB_XERR		; do error #X, then warm start
.c8c8									LAB_273C
.c8c8	a5 29			lda $29				LDA	FACt_1		; get temp mantissa1
.c8ca	85 61			sta $61				STA	FAC1_1		; save FAC1 mantissa1
.c8cc	a5 2a			lda $2a				LDA	FACt_2		; get temp mantissa2
.c8ce	85 62			sta $62				STA	FAC1_2		; save FAC1 mantissa2
.c8d0	a5 2b			lda $2b				LDA	FACt_3		; get temp mantissa3
.c8d2	85 63			sta $63				STA	FAC1_3		; save FAC1 mantissa3
.c8d4	4c 8e c6		jmp $c68e			JMP	LAB_24D5		; normalise FAC1 and return
.c8d7									LAB_UFAC
.c8d7	85 25			sta $25				STA	ut1_pl		; save pointer low byte
.c8d9	84 26			sty $26				STY	ut1_ph		; save pointer high byte
.c8db	a0 03			ldy #$03			LDY	#$03			; 4 bytes to do
.c8dd	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get last byte
.c8df	85 63			sta $63				STA	FAC1_3		; save FAC1 mantissa3
.c8e1	88				dey					DEY				; decrement index
.c8e2	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get last-1 byte
.c8e4	85 62			sta $62				STA	FAC1_2		; save FAC1 mantissa2
.c8e6	88				dey					DEY				; decrement index
.c8e7	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get second byte
.c8e9	85 64			sta $64				STA	FAC1_s		; save FAC1 sign (b7)
.c8eb	09 80			ora #$80			ORA	#$80			; set 1xxx xxxx (add normal bit)
.c8ed	85 61			sta $61				STA	FAC1_1		; save FAC1 mantissa1
.c8ef	88				dey					DEY				; decrement index
.c8f0	b1 25			lda ($25),y			LDA	(ut1_pl),Y		; get first byte (exponent)
.c8f2	85 60			sta $60				STA	FAC1_e		; save FAC1 exponent
.c8f4	84 6d			sty $6d				STY	FAC1_r		; clear FAC1 rounding byte
.c8f6	60				rts					RTS
.c8f7									LAB_276E
.c8f7	a2 59			ldx #$59			LDX	#<Adatal		; set pointer low byte
.c8f9									LAB_2770
.c8f9	a0 00			ldy #$00			LDY	#>Adatal		; set pointer high byte
.c8fb	f0 04			beq $c901			BEQ	LAB_2778		; pack FAC1 into (XY) and return
.c8fd									LAB_PFAC
.c8fd	a6 4b			ldx $4b				LDX	Lvarpl		; get destination pointer low byte
.c8ff	a4 4c			ldy $4c				LDY	Lvarph		; get destination pointer high byte
.c901									LAB_2778
.c901	20 33 c9		jsr $c933			JSR	LAB_27BA		; round FAC1
.c904	86 25			stx $25				STX	ut1_pl		; save pointer low byte
.c906	84 26			sty $26				STY	ut1_ph		; save pointer high byte
.c908	a0 03			ldy #$03			LDY	#$03			; set index
.c90a	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.c90c	91 25			sta ($25),y			STA	(ut1_pl),Y		; store in destination
.c90e	88				dey					DEY				; decrement index
.c90f	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.c911	91 25			sta ($25),y			STA	(ut1_pl),Y		; store in destination
.c913	88				dey					DEY				; decrement index
.c914	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.c916	09 7f			ora #$7f			ORA	#$7F			; set bits x111 1111
.c918	25 61			and $61				AND	FAC1_1		; AND in FAC1 mantissa1
.c91a	91 25			sta ($25),y			STA	(ut1_pl),Y		; store in destination
.c91c	88				dey					DEY				; decrement index
.c91d	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.c91f	91 25			sta ($25),y			STA	(ut1_pl),Y		; store in destination
.c921	84 6d			sty $6d				STY	FAC1_r		; clear FAC1 rounding byte
.c923	60				rts					RTS
.c924									LAB_27AB
.c924	20 33 c9		jsr $c933			JSR	LAB_27BA		; round FAC1
.c927									LAB_27AE
.c927	a2 05			ldx #$05			LDX	#$05			; 5 bytes to copy
.c929									LAB_27B0
.c929	b5 5f			lda $5f,x			LDA	FAC1_e-1,X		; get byte from FAC1,X
.c92b	95 66			sta $66,x			STA	FAC1_o,X		; save byte at FAC2,X
.c92d	ca				dex					DEX				; decrement count
.c92e	d0 f9			bne $c929			BNE	LAB_27B0		; loop if not all done
.c930	86 6d			stx $6d				STX	FAC1_r		; clear FAC1 rounding byte
.c932									LAB_27B9
.c932	60				rts					RTS
.c933									LAB_27BA
.c933	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.c935	f0 fb			beq $c932			BEQ	LAB_27B9		; exit if zero
.c937	06 6d			asl $6d				ASL	FAC1_r		; shift FAC1 rounding byte
.c939	90 f7			bcc $c932			BCC	LAB_27B9		; exit if no overflow
.c93b									LAB_27C2
.c93b	20 12 c7		jsr $c712			JSR	LAB_2559		; increment FAC1 mantissa
.c93e	d0 f2			bne $c932			BNE	LAB_27B9		; branch if no overflow
.c940	4c e3 c6		jmp $c6e3			JMP	LAB_252A		; normalise FAC1 for C=1 and return
.c943									LAB_27CA
.c943	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.c945	f0 09			beq $c950			BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
.c947									LAB_27CE
.c947	a5 64			lda $64				LDA	FAC1_s		; else get FAC1 sign (b7)
.c949									LAB_27D0
.c949	2a				rol a				ROL				; move sign bit to carry
.c94a	a9 ff			lda #$ff			LDA	#$FF			; set byte for -ve result
.c94c	b0 02			bcs $c950			BCS	LAB_27D7		; return if sign was set (-ve)
.c94e	a9 01			lda #$01			LDA	#$01			; else set byte for +ve result
.c950									LAB_27D7
.c950	60				rts					RTS
.c951									LAB_SGN
.c951	20 43 c9		jsr $c943			JSR	LAB_27CA		; get FAC1 sign
.c954									LAB_27DB
.c954	85 61			sta $61				STA	FAC1_1		; save FAC1 mantissa1
.c956	a9 00			lda #$00			LDA	#$00			; clear A
.c958	85 62			sta $62				STA	FAC1_2		; clear FAC1 mantissa2
.c95a	a2 88			ldx #$88			LDX	#$88			; set exponent
.c95c									LAB_27E3
.c95c	a5 61			lda $61				LDA	FAC1_1		; get FAC1 mantissa1
.c95e	49 ff			eor #$ff			EOR	#$FF			; complement it
.c960	2a				rol a				ROL				; sign bit into carry
.c961									LAB_STFA
.c961	a9 00			lda #$00			LDA	#$00			; clear A
.c963	85 63			sta $63				STA	FAC1_3		; clear FAC1 mantissa3
.c965	86 60			stx $60				STX	FAC1_e		; set FAC1 exponent
.c967	85 6d			sta $6d				STA	FAC1_r		; clear FAC1 rounding byte
.c969	85 64			sta $64				STA	FAC1_s		; clear FAC1 sign (b7)
.c96b	4c 89 c6		jmp $c689			JMP	LAB_24D0		; do ABS and normalise FAC1
.c96e									LAB_ABS
.c96e	46 64			lsr $64				LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
.c970	60				rts					RTS
.c971									LAB_27F8
.c971	85 27			sta $27				STA	ut2_pl		; save pointer low byte
.c973									LAB_27FA
.c973	84 28			sty $28				STY	ut2_ph		; save pointer high byte
.c975	a0 00			ldy #$00			LDY	#$00			; clear index
.c977	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get exponent
.c979	c8				iny					INY				; increment index
.c97a	aa				tax					TAX				; copy (AY) exponent to X
.c97b	f0 c6			beq $c943			BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
.c97d	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
.c97f	45 64			eor $64				EOR	FAC1_s		; EOR FAC1 sign (b7)
.c981	30 c4			bmi $c947			BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
.c983	e4 60			cpx $60				CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
.c985	d0 1a			bne $c9a1			BNE	LAB_2828		; branch if different
.c987	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
.c989	09 80			ora #$80			ORA	#$80			; normalise top bit
.c98b	c5 61			cmp $61				CMP	FAC1_1		; compare with FAC1 mantissa1
.c98d	d0 12			bne $c9a1			BNE	LAB_2828		; branch if different
.c98f	c8				iny					INY				; increment index
.c990	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get mantissa2
.c992	c5 62			cmp $62				CMP	FAC1_2		; compare with FAC1 mantissa2
.c994	d0 0b			bne $c9a1			BNE	LAB_2828		; branch if different
.c996	c8				iny					INY				; increment index
.c997	a9 7f			lda #$7f			LDA	#$7F			; set for 1/2 value rounding byte
.c999	c5 6d			cmp $6d				CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
.c99b	b1 27			lda ($27),y			LDA	(ut2_pl),Y		; get mantissa3
.c99d	e5 63			sbc $63				SBC	FAC1_3		; subtract FAC1 mantissa3
.c99f	f0 28			beq $c9c9			BEQ	LAB_2850		; exit if mantissa3 equal
.c9a1									LAB_2828
.c9a1	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.c9a3	90 02			bcc $c9a7			BCC	LAB_282E		; branch if FAC1 > (AY)
.c9a5	49 ff			eor #$ff			EOR	#$FF			; else toggle FAC1 sign
.c9a7									LAB_282E
.c9a7	4c 49 c9		jmp $c949			JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
.c9aa									LAB_2831
.c9aa	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.c9ac	f0 4a			beq $c9f8			BEQ	LAB_287F		; if zero go clear FAC1 and return
.c9ae	38				sec					SEC				; set carry for subtract
.c9af	e9 98			sbc #$98			SBC	#$98			; subtract maximum integer range exponent
.c9b1	24 64			bit $64				BIT	FAC1_s		; test FAC1 sign (b7)
.c9b3	10 09			bpl $c9be			BPL	LAB_2845		; branch if FAC1 +ve
.c9b5	aa				tax					TAX				; copy subtracted exponent
.c9b6	a9 ff			lda #$ff			LDA	#$FF			; overflow for -ve number
.c9b8	85 66			sta $66				STA	FAC1_o		; set FAC1 overflow byte
.c9ba	20 f6 c6		jsr $c6f6			JSR	LAB_253D		; twos complement FAC1 mantissa
.c9bd	8a				txa					TXA				; restore subtracted exponent
.c9be									LAB_2845
.c9be	a2 60			ldx #$60			LDX	#FAC1_e		; set index to FAC1
.c9c0	c9 f9			cmp #$f9			CMP	#$F9			; compare exponent result
.c9c2	10 06			bpl $c9ca			BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
.c9c4	20 34 c7		jsr $c734			JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
.c9c7	84 66			sty $66				STY	FAC1_o		; clear FAC1 overflow byte
.c9c9									LAB_2850
.c9c9	60				rts					RTS
.c9ca									LAB_2851
.c9ca	a8				tay					TAY				; copy shift count
.c9cb	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.c9cd	29 80			and #$80			AND	#$80			; mask sign bit only (x000 0000)
.c9cf	46 61			lsr $61				LSR	FAC1_1		; shift FAC1 mantissa1
.c9d1	05 61			ora $61				ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
.c9d3	85 61			sta $61				STA	FAC1_1		; save FAC1 mantissa1
.c9d5	20 4b c7		jsr $c74b			JSR	LAB_2592		; shift FAC1 Y times right
.c9d8	84 66			sty $66				STY	FAC1_o		; clear FAC1 overflow byte
.c9da	60				rts					RTS
.c9db									LAB_INT
.c9db	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.c9dd	c9 98			cmp #$98			CMP	#$98			; compare with max int
.c9df	b0 1e			bcs $c9ff			BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
.c9e1	20 aa c9		jsr $c9aa			JSR	LAB_2831		; convert FAC1 floating-to-fixed
.c9e4	84 6d			sty $6d				STY	FAC1_r		; save FAC1 rounding byte
.c9e6	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.c9e8	84 64			sty $64				STY	FAC1_s		; save FAC1 sign (b7)
.c9ea	49 80			eor #$80			EOR	#$80			; toggle FAC1 sign
.c9ec	2a				rol a				ROL				; shift into carry
.c9ed	a9 98			lda #$98			LDA	#$98			; set new exponent
.c9ef	85 60			sta $60				STA	FAC1_e		; save FAC1 exponent
.c9f1	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.c9f3	85 0d			sta $0d				STA	Temp3			; save for EXP() function
.c9f5	4c 89 c6		jmp $c689			JMP	LAB_24D0		; do ABS and normalise FAC1
.c9f8									LAB_287F
.c9f8	85 61			sta $61				STA	FAC1_1		; clear FAC1 mantissa1
.c9fa	85 62			sta $62				STA	FAC1_2		; clear FAC1 mantissa2
.c9fc	85 63			sta $63				STA	FAC1_3		; clear FAC1 mantissa3
.c9fe	a8				tay					TAY				; clear Y
.c9ff									LAB_2886
.c9ff	60				rts					RTS
.ca00									LAB_2887
.ca00	a0 00			ldy #$00			LDY	#$00			; clear Y
.ca02	84 11			sty $11				STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
.ca04	a2 09			ldx #$09			LDX	#$09			; set index
.ca06									LAB_288B
.ca06	94 5c			sty $5c,x			STY	numexp,X		; clear byte
.ca08	ca				dex					DEX				; decrement index
.ca09	10 fb			bpl $ca06			BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
.ca0b	90 7f			bcc $ca8c			BCC	LAB_28FE		; branch if 1st character numeric
.ca0d	c9 2d			cmp #$2d			CMP	#'-'			; else compare with "-"
.ca0f	d0 04			bne $ca15			BNE	LAB_289A		; branch if not "-"
.ca11	86 65			stx $65				STX	negnum		; set flag for -ve number (X = $FF)
.ca13	f0 04			beq $ca19			BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
.ca15									LAB_289A
.ca15	c9 2b			cmp #$2b			CMP	#'+'			; else compare with "+"
.ca17	d0 05			bne $ca1e			BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
.ca19									LAB_289C
.ca19	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.ca1c	90 6e			bcc $ca8c			BCC	LAB_28FE		; branch if numeric character
.ca1e									LAB_289D
.ca1e	c9 24			cmp #$24			CMP	#'$'			; else compare with "$"
.ca20	d0 03			bne $ca25			BNE	LAB_NHEX		; branch if not "$"
.ca22	4c c8 ce		jmp $cec8			JMP	LAB_CHEX		; branch if "$"
.ca25									LAB_NHEX
.ca25	c9 25			cmp #$25			CMP	#'%'			; else compare with "%"
.ca27	d0 08			bne $ca31			BNE	LAB_28A3		; branch if not "%" (continue original code)
.ca29	4c f6 ce		jmp $cef6			JMP	LAB_CBIN		; branch if "%"
.ca2c									LAB_289E
.ca2c	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
.ca2f									LAB_28A1
.ca2f	90 5b			bcc $ca8c			BCC	LAB_28FE		; branch if numeric character
.ca31									LAB_28A3
.ca31	c9 2e			cmp #$2e			CMP	#'.'			; else compare with "."
.ca33	f0 2e			beq $ca63			BEQ	LAB_28D5		; branch if "."
.ca35	c9 45			cmp #$45			CMP	#'E'			; else compare with "E"
.ca37	d0 30			bne $ca69			BNE	LAB_28DB		; branch if not "E"
.ca39	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.ca3c	90 17			bcc $ca55			BCC	LAB_28C7		; branch if numeric character
.ca3e	c9 b8			cmp #$b8			CMP	#TK_MINUS		; else compare with token for -
.ca40	f0 0e			beq $ca50			BEQ	LAB_28C2		; branch if token for -
.ca42	c9 2d			cmp #$2d			CMP	#'-'			; else compare with "-"
.ca44	f0 0a			beq $ca50			BEQ	LAB_28C2		; branch if "-"
.ca46	c9 b7			cmp #$b7			CMP	#TK_PLUS		; else compare with token for +
.ca48	f0 08			beq $ca52			BEQ	LAB_28C4		; branch if token for +
.ca4a	c9 2b			cmp #$2b			CMP	#'+'			; else compare with "+"
.ca4c	f0 04			beq $ca52			BEQ	LAB_28C4		; branch if "+"
.ca4e	d0 07			bne $ca57			BNE	LAB_28C9		; branch always
.ca50									LAB_28C2
.ca50	66 5f			ror $5f				ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
.ca52									LAB_28C4
.ca52	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.ca55									LAB_28C7
.ca55	90 5b			bcc $cab2			BCC	LAB_2925		; branch if numeric character
.ca57									LAB_28C9
.ca57	24 5f			bit $5f				BIT	expneg		; test exponent -ve flag
.ca59	10 0e			bpl $ca69			BPL	LAB_28DB		; if +ve go evaluate exponent
.ca5b	a9 00			lda #$00			LDA	#$00			; clear result
.ca5d	38				sec					SEC				; set carry for subtract
.ca5e	e5 5d			sbc $5d				SBC	expcnt		; subtract exponent byte
.ca60	4c 6b ca		jmp $ca6b			JMP	LAB_28DD		; go evaluate exponent
.ca63									LAB_28D5
.ca63	66 5e			ror $5e				ROR	numdpf		; set decimal point flag
.ca65	24 5e			bit $5e				BIT	numdpf		; test decimal point flag
.ca67	50 c3			bvc $ca2c			BVC	LAB_289E		; branch if only one decimal point so far
.ca69									LAB_28DB
.ca69	a5 5d			lda $5d				LDA	expcnt		; get exponent count byte
.ca6b									LAB_28DD
.ca6b	38				sec					SEC				; set carry for subtract
.ca6c	e5 5c			sbc $5c				SBC	numexp		; subtract numerator exponent
.ca6e	85 5d			sta $5d				STA	expcnt		; save exponent count byte
.ca70	f0 12			beq $ca84			BEQ	LAB_28F6		; branch if no adjustment
.ca72	10 09			bpl $ca7d			BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
.ca74									LAB_28E6
.ca74	20 4a c8		jsr $c84a			JSR	LAB_26B9		; divide by 10
.ca77	e6 5d			inc $5d				INC	expcnt		; increment exponent count byte
.ca79	d0 f9			bne $ca74			BNE	LAB_28E6		; loop until all done
.ca7b	f0 07			beq $ca84			BEQ	LAB_28F6		; branch always
.ca7d									LAB_28EF
.ca7d	20 31 c8		jsr $c831			JSR	LAB_269E		; multiply by 10
.ca80	c6 5d			dec $5d				DEC	expcnt		; decrement exponent count byte
.ca82	d0 f9			bne $ca7d			BNE	LAB_28EF		; loop until all done
.ca84									LAB_28F6
.ca84	a5 65			lda $65				LDA	negnum		; get -ve flag
.ca86	30 01			bmi $ca89			BMI	LAB_28FB		; if -ve do - FAC1 and return
.ca88	60				rts					RTS
.ca89									LAB_28FB
.ca89	4c 4e cc		jmp $cc4e			JMP	LAB_GTHAN		; do - FAC1 and return
.ca8c									LAB_28FE
.ca8c	48				pha					PHA				; save character
.ca8d	24 5e			bit $5e				BIT	numdpf		; test decimal point flag
.ca8f	10 02			bpl $ca93			BPL	LAB_2905		; skip exponent increment if not set
.ca91	e6 5c			inc $5c				INC	numexp		; else increment number exponent
.ca93									LAB_2905
.ca93	20 31 c8		jsr $c831			JSR	LAB_269E		; multiply FAC1 by 10
.ca96	68				pla					PLA				; restore character
.ca97	29 0f			and #$0f			AND	#$0F			; convert to binary
.ca99	20 9f ca		jsr $ca9f			JSR	LAB_2912		; evaluate new ASCII digit
.ca9c	4c 2c ca		jmp $ca2c			JMP	LAB_289E		; go do next character
.ca9f									LAB_2912
.ca9f	48				pha					PHA				; save digit
.caa0	20 24 c9		jsr $c924			JSR	LAB_27AB		; round and copy FAC1 to FAC2
.caa3	68				pla					PLA				; restore digit
.caa4	20 54 c9		jsr $c954			JSR	LAB_27DB		; save A as integer byte
.caa7	a5 6b			lda $6b				LDA	FAC2_s		; get FAC2 sign (b7)
.caa9	45 64			eor $64				EOR	FAC1_s		; toggle with FAC1 sign (b7)
.caab	85 6c			sta $6c				STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.caad	a6 60			ldx $60				LDX	FAC1_e		; get FAC1 exponent
.caaf	4c 1b c6		jmp $c61b			JMP	LAB_ADD		; add FAC2 to FAC1 and return
.cab2									LAB_2925
.cab2	a5 5d			lda $5d				LDA	expcnt		; get exponent count byte
.cab4	c9 0a			cmp #$0a			CMP	#$0A			; compare with 10 decimal
.cab6	90 09			bcc $cac1			BCC	LAB_2934		; branch if less
.cab8	a9 64			lda #$64			LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
.caba	24 5f			bit $5f				BIT	expneg		; test exponent -ve flag
.cabc	30 0e			bmi $cacc			BMI	LAB_2942		; branch if -ve
.cabe	4c 1d c7		jmp $c71d			JMP	LAB_2564		; else do overflow error
.cac1									LAB_2934
.cac1	0a				asl a				ASL				; * 2
.cac2	0a				asl a				ASL				; * 4
.cac3	65 5d			adc $5d				ADC	expcnt		; * 5
.cac5	0a				asl a				ASL				; * 10
.cac6	a0 00			ldy #$00			LDY	#$00			; set index
.cac8	71 77			adc ($77),y			ADC	(Bpntrl),Y		; add character (will be $30 too much!)
.caca	e9 2f			sbc #$2f			SBC	#'0'-1		; convert character to binary
.cacc									LAB_2942
.cacc	85 5d			sta $5d				STA	expcnt		; save exponent count byte
.cace	4c 52 ca		jmp $ca52			JMP	LAB_28C4		; go get next character
.cad1									LAB_2953
.cad1	a9 4e			lda #$4e			LDA	#<LAB_LMSG		; point to " in line " message low byte
.cad3	a0 d8			ldy #$d8			LDY	#>LAB_LMSG		; point to " in line " message high byte
.cad5	20 1c b9		jsr $b91c			JSR	LAB_18C3		; print null terminated string from memory
.cad8	a5 3c			lda $3c				LDA	Clineh		; get current line high byte
.cada	a6 3b			ldx $3b				LDX	Clinel		; get current line low byte
.cadc									LAB_295E
.cadc	85 61			sta $61				STA	FAC1_1		; save low byte as FAC1 mantissa1
.cade	86 62			stx $62				STX	FAC1_2		; save high byte as FAC1 mantissa2
.cae0	a2 90			ldx #$90			LDX	#$90			; set exponent to 16d bits
.cae2	38				sec					SEC				; set integer is +ve flag
.cae3	20 61 c9		jsr $c961			JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
.cae6	a0 00			ldy #$00			LDY	#$00			; clear index
.cae8	98				tya					TYA				; clear A
.cae9	20 fc ca		jsr $cafc			JSR	LAB_297B		; convert FAC1 to string, skip sign character save
.caec	4c 1c b9		jmp $b91c			JMP	LAB_18C3		; print null terminated string from memory and return
.caef									LAB_296E
.caef	a0 01			ldy #$01			LDY	#$01			; set index = 1
.caf1	a9 20			lda #$20			LDA	#$20			; character = " " (assume +ve)
.caf3	24 64			bit $64				BIT	FAC1_s		; test FAC1 sign (b7)
.caf5	10 02			bpl $caf9			BPL	LAB_2978		; branch if +ve
.caf7	a9 2d			lda #$2d			LDA	#$2D			; else character = "-"
.caf9									LAB_2978
.caf9	99 96 00		sta $0096,y			STA	Decss,Y		; save leading character (" " or "-")
.cafc									LAB_297B
.cafc	85 64			sta $64				STA	FAC1_s		; clear FAC1 sign (b7)
.cafe	84 6e			sty $6e				STY	Sendl			; save index
.cb00	c8				iny					INY				; increment index
.cb01	a6 60			ldx $60				LDX	FAC1_e		; get FAC1 exponent
.cb03	d0 05			bne $cb0a			BNE	LAB_2989		; branch if FAC1<>0
.cb05	a9 30			lda #$30			LDA	#'0'			; set character = "0"
.cb07	4c 08 cc		jmp $cc08			JMP	LAB_2A89		; save last character, [EOT] and exit
.cb0a									LAB_2989
.cb0a	a9 00			lda #$00			LDA	#$00			; clear (number exponent count)
.cb0c	e0 81			cpx #$81			CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
.cb0e	b0 09			bcs $cb19			BCS	LAB_299A		; branch if FAC1=>1
.cb10	a9 d9			lda #$d9			LDA	#<LAB_294F		; set pointer low byte to 1,000,000
.cb12	a0 d1			ldy #$d1			LDY	#>LAB_294F		; set pointer high byte to 1,000,000
.cb14	20 93 c7		jsr $c793			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.cb17	a9 fa			lda #$fa			LDA	#$FA			; set number exponent count (-6)
.cb19									LAB_299A
.cb19	85 5c			sta $5c				STA	numexp		; save number exponent count
.cb1b									LAB_299C
.cb1b	a9 d5			lda #$d5			LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
.cb1d	a0 d1			ldy #$d1			LDY	#>LAB_294B		; set pointer high byte to 999999.4375
.cb1f	20 71 c9		jsr $c971			JSR	LAB_27F8		; compare FAC1 with (AY)
.cb22	f0 1e			beq $cb42			BEQ	LAB_29C3		; exit if FAC1 = (AY)
.cb24	10 12			bpl $cb38			BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
.cb26									LAB_29A7
.cb26	a9 d1			lda #$d1			LDA	#<LAB_2947		; set pointer low byte to 99999.9375
.cb28	a0 d1			ldy #$d1			LDY	#>LAB_2947		; set pointer high byte to 99999.9375
.cb2a	20 71 c9		jsr $c971			JSR	LAB_27F8		; compare FAC1 with (AY)
.cb2d	f0 02			beq $cb31			BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
.cb2f	10 0e			bpl $cb3f			BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
.cb31									LAB_29B2
.cb31	20 31 c8		jsr $c831			JSR	LAB_269E		; multiply by 10
.cb34	c6 5c			dec $5c				DEC	numexp		; decrement number exponent count
.cb36	d0 ee			bne $cb26			BNE	LAB_29A7		; go test again (branch always)
.cb38									LAB_29B9
.cb38	20 4a c8		jsr $c84a			JSR	LAB_26B9		; divide by 10
.cb3b	e6 5c			inc $5c				INC	numexp		; increment number exponent count
.cb3d	d0 dc			bne $cb1b			BNE	LAB_299C		; go test again (branch always)
.cb3f									LAB_29C0
.cb3f	20 14 c6		jsr $c614			JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
.cb42									LAB_29C3
.cb42	20 aa c9		jsr $c9aa			JSR	LAB_2831		; convert FAC1 floating-to-fixed
.cb45	a2 01			ldx #$01			LDX	#$01			; set default digits before dp = 1
.cb47	a5 5c			lda $5c				LDA	numexp		; get number exponent count
.cb49	18				clc					CLC				; clear carry for add
.cb4a	69 07			adc #$07			ADC	#$07			; up to 6 digits before point
.cb4c	30 09			bmi $cb57			BMI	LAB_29D8		; if -ve then 1 digit before dp
.cb4e	c9 08			cmp #$08			CMP	#$08			; A>=8 if n>=1E6
.cb50	b0 06			bcs $cb58			BCS	LAB_29D9		; branch if >= $08
.cb52	69 ff			adc #$ff			ADC	#$FF			; take 1 from digit count
.cb54	aa				tax					TAX				; copy to A
.cb55	a9 02			lda #$02			LDA	#$02			;.set exponent adjust
.cb57									LAB_29D8
.cb57	38				sec					SEC				; set carry for subtract
.cb58									LAB_29D9
.cb58	e9 02			sbc #$02			SBC	#$02			; -2
.cb5a	85 5d			sta $5d				STA	expcnt		;.save exponent adjust
.cb5c	86 5c			stx $5c				STX	numexp		; save digits before dp count
.cb5e	8a				txa					TXA				; copy to A
.cb5f	f0 02			beq $cb63			BEQ	LAB_29E4		; branch if no digits before dp
.cb61	10 13			bpl $cb76			BPL	LAB_29F7		; branch if digits before dp
.cb63									LAB_29E4
.cb63	a4 6e			ldy $6e				LDY	Sendl			; get output string index
.cb65	a9 2e			lda #$2e			LDA	#$2E			; character "."
.cb67	c8				iny					INY				; increment index
.cb68	99 96 00		sta $0096,y			STA	Decss,Y		; save to output string
.cb6b	8a				txa					TXA				;.
.cb6c	f0 06			beq $cb74			BEQ	LAB_29F5		;.
.cb6e	a9 30			lda #$30			LDA	#'0'			; character "0"
.cb70	c8				iny					INY				; increment index
.cb71	99 96 00		sta $0096,y			STA	Decss,Y		; save to output string
.cb74									LAB_29F5
.cb74	84 6e			sty $6e				STY	Sendl			; save output string index
.cb76									LAB_29F7
.cb76	a0 00			ldy #$00			LDY	#$00			; clear index (point to 100,000)
.cb78	a2 80			ldx #$80			LDX	#$80			;
.cb7a									LAB_29FB
.cb7a	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.cb7c	18				clc					CLC				; clear carry for add
.cb7d	79 4f d2		adc $d24f,y			ADC	LAB_2A9C,Y		; add -ve LSB
.cb80	85 63			sta $63				STA	FAC1_3		; save FAC1 mantissa3
.cb82	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.cb84	79 4e d2		adc $d24e,y			ADC	LAB_2A9B,Y		; add -ve NMSB
.cb87	85 62			sta $62				STA	FAC1_2		; save FAC1 mantissa2
.cb89	a5 61			lda $61				LDA	FAC1_1		; get FAC1 mantissa1
.cb8b	79 4d d2		adc $d24d,y			ADC	LAB_2A9A,Y		; add -ve MSB
.cb8e	85 61			sta $61				STA	FAC1_1		; save FAC1 mantissa1
.cb90	e8				inx					INX				;
.cb91	b0 04			bcs $cb97			BCS	LAB_2A18		;
.cb93	10 e5			bpl $cb7a			BPL	LAB_29FB		; not -ve so try again
.cb95	30 02			bmi $cb99			BMI	LAB_2A1A		;
.cb97									LAB_2A18
.cb97	30 e1			bmi $cb7a			BMI	LAB_29FB		;
.cb99									LAB_2A1A
.cb99	8a				txa					TXA				;
.cb9a	90 04			bcc $cba0			BCC	LAB_2A21		;
.cb9c	49 ff			eor #$ff			EOR	#$FF			;
.cb9e	69 0a			adc #$0a			ADC	#$0A			;
.cba0									LAB_2A21
.cba0	69 2f			adc #$2f			ADC	#'0'-1		; add "0"-1 to result
.cba2	c8				iny					INY				; increment index ..
.cba3	c8				iny					INY				; .. to next less ..
.cba4	c8				iny					INY				; .. power of ten
.cba5	84 49			sty $49				STY	Cvaral		; save as current var address low byte
.cba7	a4 6e			ldy $6e				LDY	Sendl			; get output string index
.cba9	c8				iny					INY				; increment output string index
.cbaa	aa				tax					TAX				; copy character to X
.cbab	29 7f			and #$7f			AND	#$7F			; mask out top bit
.cbad	99 96 00		sta $0096,y			STA	Decss,Y		; save to output string
.cbb0	c6 5c			dec $5c				DEC	numexp		; decrement # of characters before the dp
.cbb2	d0 06			bne $cbba			BNE	LAB_2A3B		; branch if still characters to do
.cbb4	a9 2e			lda #$2e			LDA	#$2E			; character "."
.cbb6	c8				iny					INY				; increment output string index
.cbb7	99 96 00		sta $0096,y			STA	Decss,Y		; save to output string
.cbba									LAB_2A3B
.cbba	84 6e			sty $6e				STY	Sendl			; save output string index
.cbbc	a4 49			ldy $49				LDY	Cvaral		; get current var address low byte
.cbbe	8a				txa					TXA				; get character back
.cbbf	49 ff			eor #$ff			EOR	#$FF			;
.cbc1	29 80			and #$80			AND	#$80			;
.cbc3	aa				tax					TAX				;
.cbc4	c0 12			cpy #$12			CPY	#$12			; compare index with max
.cbc6	d0 b2			bne $cb7a			BNE	LAB_29FB		; loop if not max
.cbc8	a4 6e			ldy $6e				LDY	Sendl			; get output string index
.cbca									LAB_2A4B
.cbca	b9 96 00		lda $0096,y			LDA	Decss,Y		; get character from output string
.cbcd	88				dey					DEY				; decrement output string index
.cbce	c9 30			cmp #$30			CMP	#'0'			; compare with "0"
.cbd0	f0 f8			beq $cbca			BEQ	LAB_2A4B		; loop until non "0" character found
.cbd2	c9 2e			cmp #$2e			CMP	#'.'			; compare with "."
.cbd4	f0 01			beq $cbd7			BEQ	LAB_2A58		; branch if was dp
.cbd6	c8				iny					INY				; increment output string index
.cbd7									LAB_2A58
.cbd7	a9 2b			lda #$2b			LDA	#$2B			; character "+"
.cbd9	a6 5d			ldx $5d				LDX	expcnt		; get exponent count
.cbdb	f0 2e			beq $cc0b			BEQ	LAB_2A8C		; if zero go set null terminator and exit
.cbdd	10 08			bpl $cbe7			BPL	LAB_2A68		; branch if exponent count +ve
.cbdf	a9 00			lda #$00			LDA	#$00			; clear A
.cbe1	38				sec					SEC				; set carry for subtract
.cbe2	e5 5d			sbc $5d				SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
.cbe4	aa				tax					TAX				; copy exponent count to X
.cbe5	a9 2d			lda #$2d			LDA	#'-'			; character "-"
.cbe7									LAB_2A68
.cbe7	99 98 00		sta $0098,y			STA	Decss+2,Y		; save to output string
.cbea	a9 45			lda #$45			LDA	#$45			; character "E"
.cbec	99 97 00		sta $0097,y			STA	Decss+1,Y		; save exponent sign to output string
.cbef	8a				txa					TXA				; get exponent count back
.cbf0	a2 2f			ldx #$2f			LDX	#'0'-1		; one less than "0" character
.cbf2	38				sec					SEC				; set carry for subtract
.cbf3									LAB_2A74
.cbf3	e8				inx					INX				; increment 10's character
.cbf4	e9 0a			sbc #$0a			SBC	#$0A			;.subtract 10 from exponent count
.cbf6	b0 fb			bcs $cbf3			BCS	LAB_2A74		; loop while still >= 0
.cbf8	69 3a			adc #$3a			ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
.cbfa	99 9a 00		sta $009a,y			STA	Decss+4,Y		; save to output string
.cbfd	8a				txa					TXA				; copy 10's character
.cbfe	99 99 00		sta $0099,y			STA	Decss+3,Y		; save to output string
.cc01	a9 00			lda #$00			LDA	#$00			; set null terminator
.cc03	99 9b 00		sta $009b,y			STA	Decss+5,Y		; save to output string
.cc06	f0 08			beq $cc10			BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
.cc08									LAB_2A89
.cc08	99 96 00		sta $0096,y			STA	Decss,Y		; save last character to output string
.cc0b									LAB_2A8C
.cc0b	a9 00			lda #$00			LDA	#$00			; set null terminator
.cc0d	99 97 00		sta $0097,y			STA	Decss+1,Y		; save after last character
.cc10									LAB_2A91
.cc10	a9 97			lda #$97			LDA	#<Decssp1		; set result string low pointer
.cc12	a0 00			ldy #$00			LDY	#>Decssp1		; set result string high pointer
.cc14	60				rts					RTS
.cc15									LAB_POWER
.cc15	f0 42			beq $cc59			BEQ	LAB_EXP		; go do  EXP()
.cc17	a5 67			lda $67				LDA	FAC2_e		; get FAC2 exponent
.cc19	d0 03			bne $cc1e			BNE	LAB_2ABF		; branch if FAC2<>0
.cc1b	4c ac c6		jmp $c6ac			JMP	LAB_24F3		; clear FAC1 exponent and sign and return
.cc1e									LAB_2ABF
.cc1e	a2 50			ldx #$50			LDX	#<func_l		; set destination pointer low byte
.cc20	a0 00			ldy #$00			LDY	#>func_l		; set destination pointer high byte
.cc22	20 01 c9		jsr $c901			JSR	LAB_2778		; pack FAC1 into (XY)
.cc25	a5 6b			lda $6b				LDA	FAC2_s		; get FAC2 sign (b7)
.cc27	10 0f			bpl $cc38			BPL	LAB_2AD9		; branch if FAC2>0
.cc29	20 db c9		jsr $c9db			JSR	LAB_INT		; perform INT
.cc2c	a9 50			lda #$50			LDA	#<func_l		; set source pointer low byte
.cc2e	a0 00			ldy #$00			LDY	#>func_l		; set source pointer high byte
.cc30	20 71 c9		jsr $c971			JSR	LAB_27F8		; compare FAC1 with (AY)
.cc33	d0 03			bne $cc38			BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
.cc35	98				tya					TYA				; clear sign b7
.cc36	a4 0d			ldy $0d				LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
.cc38									LAB_2AD9
.cc38	20 1f c6		jsr $c61f			JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
.cc3b	98				tya					TYA				; copy sign back ..
.cc3c	48				pha					PHA				; .. and save it
.cc3d	20 55 c7		jsr $c755			JSR	LAB_LOG		; do LOG(n)
.cc40	a9 50			lda #$50			LDA	#<garb_l		; set pointer low byte
.cc42	a0 00			ldy #$00			LDY	#>garb_l		; set pointer high byte
.cc44	20 93 c7		jsr $c793			JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
.cc47	20 59 cc		jsr $cc59			JSR	LAB_EXP		; go do EXP(n)
.cc4a	68				pla					PLA				; pull sign from stack
.cc4b	4a				lsr a				LSR				; b0 is to be tested, shift to Cb
.cc4c	90 0a			bcc $cc58			BCC	LAB_2AF9		; if no bit then exit
.cc4e									LAB_GTHAN
.cc4e	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.cc50	f0 06			beq $cc58			BEQ	LAB_2AF9		; exit if FAC1_e = $00
.cc52	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.cc54	49 ff			eor #$ff			EOR	#$FF			; complement it
.cc56	85 64			sta $64				STA	FAC1_s		; save FAC1 sign (b7)
.cc58									LAB_2AF9
.cc58	60				rts					RTS
.cc59									LAB_EXP
.cc59	a9 dd			lda #$dd			LDA	#<LAB_2AFA		; set 1.443 pointer low byte
.cc5b	a0 d1			ldy #$d1			LDY	#>LAB_2AFA		; set 1.443 pointer high byte
.cc5d	20 93 c7		jsr $c793			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.cc60	a5 6d			lda $6d				LDA	FAC1_r		; get FAC1 rounding byte
.cc62	69 50			adc #$50			ADC	#$50			; +$50/$100
.cc64	90 03			bcc $cc69			BCC	LAB_2B2B		; skip rounding if no carry
.cc66	20 3b c9		jsr $c93b			JSR	LAB_27C2		; round FAC1 (no check)
.cc69									LAB_2B2B
.cc69	85 58			sta $58				STA	FAC2_r		; save FAC2 rounding byte
.cc6b	20 27 c9		jsr $c927			JSR	LAB_27AE		; copy FAC1 to FAC2
.cc6e	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.cc70	c9 88			cmp #$88			CMP	#$88			; compare with EXP limit (256d)
.cc72	90 03			bcc $cc77			BCC	LAB_2B39		; branch if less
.cc74									LAB_2B36
.cc74	20 28 c8		jsr $c828			JSR	LAB_2690		; handle overflow and underflow
.cc77									LAB_2B39
.cc77	20 db c9		jsr $c9db			JSR	LAB_INT		; perform INT
.cc7a	a5 0d			lda $0d				LDA	Temp3			; get mantissa 3 from INT() function
.cc7c	18				clc					CLC				; clear carry for add
.cc7d	69 81			adc #$81			ADC	#$81			; normalise +1
.cc7f	f0 f3			beq $cc74			BEQ	LAB_2B36		; if $00 go handle overflow
.cc81	38				sec					SEC				; set carry for subtract
.cc82	e9 01			sbc #$01			SBC	#$01			; now correct for exponent
.cc84	48				pha					PHA				; save FAC2 exponent
.cc85	a2 04			ldx #$04			LDX	#$04			; 4 bytes to do
.cc87									LAB_2B49
.cc87	b5 67			lda $67,x			LDA	FAC2_e,X		; get FAC2,X
.cc89	b4 60			ldy $60,x			LDY	FAC1_e,X		; get FAC1,X
.cc8b	95 60			sta $60,x			STA	FAC1_e,X		; save FAC1,X
.cc8d	94 67			sty $67,x			STY	FAC2_e,X		; save FAC2,X
.cc8f	ca				dex					DEX				; decrement count/index
.cc90	10 f5			bpl $cc87			BPL	LAB_2B49		; loop if not all done
.cc92	a5 58			lda $58				LDA	FAC2_r		; get FAC2 rounding byte
.cc94	85 6d			sta $6d				STA	FAC1_r		; save as FAC1 rounding byte
.cc96	20 00 c6		jsr $c600			JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
.cc99	20 4e cc		jsr $cc4e			JSR	LAB_GTHAN		; do - FAC1
.cc9c	a9 e1			lda #$e1			LDA	#<LAB_2AFE		; set counter pointer low byte
.cc9e	a0 d1			ldy #$d1			LDY	#>LAB_2AFE		; set counter pointer high byte
.cca0	20 c1 cc		jsr $ccc1			JSR	LAB_2B84		; go do series evaluation
.cca3	a9 00			lda #$00			LDA	#$00			; clear A
.cca5	85 6c			sta $6c				STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.cca7	68				pla					PLA				;.get saved FAC2 exponent
.cca8	4c 0d c8		jmp $c80d			JMP	LAB_2675		; test and adjust accumulators and return
.ccab									LAB_2B6E
.ccab	85 6e			sta $6e				STA	Cptrl			; save count pointer low byte
.ccad	84 6f			sty $6f				STY	Cptrh			; save count pointer high byte
.ccaf	20 f7 c8		jsr $c8f7			JSR	LAB_276E		; pack FAC1 into Adatal
.ccb2	a9 59			lda #$59			LDA	#<Adatal		; set pointer low byte (Y already $00)
.ccb4	20 93 c7		jsr $c793			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.ccb7	20 c5 cc		jsr $ccc5			JSR	LAB_2B88		; go do series evaluation
.ccba	a9 59			lda #$59			LDA	#<Adatal		; pointer to original # low byte
.ccbc	a0 00			ldy #$00			LDY	#>Adatal		; pointer to original # high byte
.ccbe	4c 93 c7		jmp $c793			JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
.ccc1									LAB_2B84
.ccc1	85 6e			sta $6e				STA	Cptrl			; save count pointer low byte
.ccc3	84 6f			sty $6f				STY	Cptrh			; save count pointer high byte
.ccc5									LAB_2B88
.ccc5	a2 5c			ldx #$5c			LDX	#<numexp		; set pointer low byte
.ccc7	20 f9 c8		jsr $c8f9			JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
.ccca	b1 6e			lda ($6e),y			LDA	(Cptrl),Y		; get constants count
.cccc	85 65			sta $65				STA	numcon		; save constants count
.ccce	a4 6e			ldy $6e				LDY	Cptrl			; get count pointer low byte
.ccd0	c8				iny					INY				; increment it (now constants pointer)
.ccd1	98				tya					TYA				; copy it
.ccd2	d0 02			bne $ccd6			BNE	LAB_2B97		; skip next if no overflow
.ccd4	e6 6f			inc $6f				INC	Cptrh			; else increment high byte
.ccd6									LAB_2B97
.ccd6	85 6e			sta $6e				STA	Cptrl			; save low byte
.ccd8	a4 6f			ldy $6f				LDY	Cptrh			; get high byte
.ccda									LAB_2B9B
.ccda	20 93 c7		jsr $c793			JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.ccdd	a5 6e			lda $6e				LDA	Cptrl			; get constants pointer low byte
.ccdf	a4 6f			ldy $6f				LDY	Cptrh			; get constants pointer high byte
.cce1	18				clc					CLC				; clear carry for add
.cce2	69 04			adc #$04			ADC	#$04			; +4 to  low pointer (4 bytes per constant)
.cce4	90 01			bcc $cce7			BCC	LAB_2BA8		; skip next if no overflow
.cce6	c8				iny					INY				; increment high byte
.cce7									LAB_2BA8
.cce7	85 6e			sta $6e				STA	Cptrl			; save pointer low byte
.cce9	84 6f			sty $6f				STY	Cptrh			; save pointer high byte
.cceb	20 18 c6		jsr $c618			JSR	LAB_246C		; add (AY) to FAC1
.ccee	a9 5c			lda #$5c			LDA	#<numexp		; set pointer low byte to partial @ numexp
.ccf0	a0 00			ldy #$00			LDY	#>numexp		; set pointer high byte to partial @ numexp
.ccf2	c6 65			dec $65				DEC	numcon		; decrement constants count
.ccf4	d0 e4			bne $ccda			BNE	LAB_2B9B		; loop until all done
.ccf6	60				rts					RTS
.ccf7									LAB_RND
.ccf7	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.ccf9	f0 07			beq $cd02			BEQ	NextPRN		; do next random # if zero
.ccfb	a2 8c			ldx #$8c			LDX	#Rbyte4		; set PRNG pointer low byte
.ccfd	a0 00			ldy #$00			LDY	#$00			; set PRNG pointer high byte
.ccff	20 01 c9		jsr $c901			JSR	LAB_2778		; pack FAC1 into (XY)
.cd02									NextPRN
.cd02	a2 af			ldx #$af			LDX	#$AF			; set EOR byte
.cd04	a0 13			ldy #$13			LDY	#$13			; do this nineteen times
.cd06									LoopPRN
.cd06	06 8d			asl $8d				ASL	Rbyte1		; shift PRNG most significant byte
.cd08	26 8e			rol $8e				ROL	Rbyte2		; shift PRNG middle byte
.cd0a	26 8f			rol $8f				ROL	Rbyte3		; shift PRNG least significant byte
.cd0c	26 8c			rol $8c				ROL	Rbyte4		; shift PRNG extra byte
.cd0e	90 05			bcc $cd15			BCC	Ninc1			; branch if bit 32 clear
.cd10	8a				txa					TXA				; set EOR byte
.cd11	45 8d			eor $8d				EOR	Rbyte1		; EOR PRNG extra byte
.cd13	85 8d			sta $8d				STA	Rbyte1		; save new PRNG extra byte
.cd15									Ninc1
.cd15	88				dey					DEY				; decrement loop count
.cd16	d0 ee			bne $cd06			BNE	LoopPRN		; loop if not all done
.cd18	a2 02			ldx #$02			LDX	#$02			; three bytes to copy
.cd1a									CopyPRNG
.cd1a	b5 8d			lda $8d,x			LDA	Rbyte1,X		; get PRNG byte
.cd1c	95 61			sta $61,x			STA	FAC1_1,X		; save FAC1 byte
.cd1e	ca				dex					DEX
.cd1f	10 f9			bpl $cd1a			BPL	CopyPRNG		; loop if not complete
.cd21	a9 80			lda #$80			LDA	#$80			; set the exponent
.cd23	85 60			sta $60				STA	FAC1_e		; save FAC1 exponent
.cd25	0a				asl a				ASL				; clear A
.cd26	85 64			sta $64				STA	FAC1_s		; save FAC1 sign
.cd28	4c 8e c6		jmp $c68e			JMP	LAB_24D5		; normalise FAC1 and return
.cd2b									LAB_COS
.cd2b	a9 fe			lda #$fe			LDA	#<LAB_2C78		; set (pi/2) pointer low byte
.cd2d	a0 d1			ldy #$d1			LDY	#>LAB_2C78		; set (pi/2) pointer high byte
.cd2f	20 18 c6		jsr $c618			JSR	LAB_246C		; add (AY) to FAC1
.cd32									LAB_SIN
.cd32	20 24 c9		jsr $c924			JSR	LAB_27AB		; round and copy FAC1 to FAC2
.cd35	a9 13			lda #$13			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.cd37	a0 d2			ldy #$d2			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.cd39	a6 6b			ldx $6b				LDX	FAC2_s		; get FAC2 sign (b7)
.cd3b	20 53 c8		jsr $c853			JSR	LAB_26C2		; divide by (AY) (X=sign)
.cd3e	20 24 c9		jsr $c924			JSR	LAB_27AB		; round and copy FAC1 to FAC2
.cd41	20 db c9		jsr $c9db			JSR	LAB_INT		; perform INT
.cd44	a9 00			lda #$00			LDA	#$00			; clear byte
.cd46	85 6c			sta $6c				STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.cd48	20 00 c6		jsr $c600			JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
.cd4b	a9 45			lda #$45			LDA	#<LAB_2C80		; set 0.25 pointer low byte
.cd4d	a0 d2			ldy #$d2			LDY	#>LAB_2C80		; set 0.25 pointer high byte
.cd4f	20 fd c5		jsr $c5fd			JSR	LAB_2455		; perform subtraction, (AY) from FAC1
.cd52	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.cd54	48				pha					PHA				; save FAC1 sign
.cd55	10 0d			bpl $cd64			BPL	LAB_2C35		; branch if +ve
.cd57	20 14 c6		jsr $c614			JSR	LAB_244E		; add 0.5 to FAC1
.cd5a	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.cd5c	30 09			bmi $cd67			BMI	LAB_2C38		; branch if -ve
.cd5e	a5 16			lda $16				LDA	Cflag			; get comparison evaluation flag
.cd60	49 ff			eor #$ff			EOR	#$FF			; toggle flag
.cd62	85 16			sta $16				STA	Cflag			; save comparison evaluation flag
.cd64									LAB_2C35
.cd64	20 4e cc		jsr $cc4e			JSR	LAB_GTHAN		; do - FAC1
.cd67									LAB_2C38
.cd67	a9 45			lda #$45			LDA	#<LAB_2C80		; set 0.25 pointer low byte
.cd69	a0 d2			ldy #$d2			LDY	#>LAB_2C80		; set 0.25 pointer high byte
.cd6b	20 18 c6		jsr $c618			JSR	LAB_246C		; add (AY) to FAC1
.cd6e	68				pla					PLA				; restore FAC1 sign
.cd6f	10 03			bpl $cd74			BPL	LAB_2C45		; branch if was +ve
.cd71	20 4e cc		jsr $cc4e			JSR	LAB_GTHAN		; do - FAC1
.cd74									LAB_2C45
.cd74	a9 02			lda #$02			LDA	#<LAB_2C84		; set pointer low byte to counter
.cd76	a0 d2			ldy #$d2			LDY	#>LAB_2C84		; set pointer high byte to counter
.cd78	4c ab cc		jmp $ccab			JMP	LAB_2B6E		; ^2 then series evaluation and return
.cd7b									LAB_TAN
.cd7b	20 f7 c8		jsr $c8f7			JSR	LAB_276E		; pack FAC1 into Adatal
.cd7e	a9 00			lda #$00			LDA	#$00			; clear byte
.cd80	85 16			sta $16				STA	Cflag			; clear comparison evaluation flag
.cd82	20 32 cd		jsr $cd32			JSR	LAB_SIN		; go do SIN(n)
.cd85	a2 50			ldx #$50			LDX	#<func_l		; set sin(n) pointer low byte
.cd87	a0 00			ldy #$00			LDY	#>func_l		; set sin(n) pointer high byte
.cd89	20 01 c9		jsr $c901			JSR	LAB_2778		; pack FAC1 into (XY)
.cd8c	a9 59			lda #$59			LDA	#<Adatal		; set n pointer low addr
.cd8e	a0 00			ldy #$00			LDY	#>Adatal		; set n pointer high addr
.cd90	20 d7 c8		jsr $c8d7			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.cd93	a9 00			lda #$00			LDA	#$00			; clear byte
.cd95	85 64			sta $64				STA	FAC1_s		; clear FAC1 sign (b7)
.cd97	a5 16			lda $16				LDA	Cflag			; get comparison evaluation flag
.cd99	20 a3 cd		jsr $cda3			JSR	LAB_2C74		; save flag and go do series evaluation
.cd9c	a9 50			lda #$50			LDA	#<func_l		; set sin(n) pointer low byte
.cd9e	a0 00			ldy #$00			LDY	#>func_l		; set sin(n) pointer high byte
.cda0	4c 5b c8		jmp $c85b			JMP	LAB_26CA		; convert AY and do (AY)/FAC1
.cda3									LAB_2C74
.cda3	48				pha					PHA				; save comparison evaluation flag
.cda4	4c 64 cd		jmp $cd64			JMP	LAB_2C35		; go do series evaluation
.cda7									LAB_USR
.cda7	20 03 00		jsr $0003			JSR	Usrjmp		; call user code
.cdaa	4c 37 bc		jmp $bc37			JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
.cdad									LAB_ATN
.cdad	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign (b7)
.cdaf	48				pha					PHA				; save sign
.cdb0	10 03			bpl $cdb5			BPL	LAB_2CA1		; branch if +ve
.cdb2	20 4e cc		jsr $cc4e			JSR	LAB_GTHAN		; else do - FAC1
.cdb5									LAB_2CA1
.cdb5	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.cdb7	48				pha					PHA				; push exponent
.cdb8	c9 81			cmp #$81			CMP	#$81			; compare with 1
.cdba	90 07			bcc $cdc3			BCC	LAB_2CAF		; branch if FAC1<1
.cdbc	a9 38			lda #$38			LDA	#<LAB_259C		; set 1 pointer low byte
.cdbe	a0 d2			ldy #$d2			LDY	#>LAB_259C		; set 1 pointer high byte
.cdc0	20 5b c8		jsr $c85b			JSR	LAB_26CA		; convert AY and do (AY)/FAC1
.cdc3									LAB_2CAF
.cdc3	a9 17			lda #$17			LDA	#<LAB_2CC9		; set pointer low byte to counter
.cdc5	a0 d2			ldy #$d2			LDY	#>LAB_2CC9		; set pointer high byte to counter
.cdc7	20 ab cc		jsr $ccab			JSR	LAB_2B6E		; ^2 then series evaluation
.cdca	68				pla					PLA				; restore old FAC1 exponent
.cdcb	c9 81			cmp #$81			CMP	#$81			; compare with 1
.cdcd	90 07			bcc $cdd6			BCC	LAB_2CC2		; branch if FAC1<1
.cdcf	a9 fe			lda #$fe			LDA	#<LAB_2C78		; set (pi/2) pointer low byte
.cdd1	a0 d1			ldy #$d1			LDY	#>LAB_2C78		; set (pi/2) pointer high byte
.cdd3	20 fd c5		jsr $c5fd			JSR	LAB_2455		; perform subtraction, (AY) from FAC1
.cdd6									LAB_2CC2
.cdd6	68				pla					PLA				; restore FAC1 sign
.cdd7	10 16			bpl $cdef			BPL	LAB_2D04		; exit if was +ve
.cdd9	4c 4e cc		jmp $cc4e			JMP	LAB_GTHAN		; else do - FAC1 and return
.cddc									LAB_BITSET
.cddc	20 32 c5		jsr $c532			JSR	LAB_GADB		; get two parameters for POKE or WAIT
.cddf	e0 08			cpx #$08			CPX	#$08			; only 0 to 7 are allowed
.cde1	b0 20			bcs $ce03			BCS	FCError		; branch if > 7
.cde3	a9 00			lda #$00			LDA	#$00			; clear A
.cde5	38				sec					SEC				; set the carry
.cde6									S_Bits
.cde6	2a				rol a				ROL				; shift bit
.cde7	ca				dex					DEX				; decrement bit number
.cde8	10 fc			bpl $cde6			BPL	S_Bits		; loop if still +ve
.cdea	e8				inx					INX				; make X = $00
.cdeb	01 0a			ora ($0a,x)			ORA	(Itempl,X)		; or with byte via temporary integer (addr)
.cded	81 0a			sta ($0a,x)			STA	(Itempl,X)		; save byte via temporary integer (addr)
.cdef									LAB_2D04
.cdef	60				rts					RTS
.cdf0									LAB_BITCLR
.cdf0	20 32 c5		jsr $c532			JSR	LAB_GADB		; get two parameters for POKE or WAIT
.cdf3	e0 08			cpx #$08			CPX	#$08			; only 0 to 7 are allowed
.cdf5	b0 0c			bcs $ce03			BCS	FCError		; branch if > 7
.cdf7	a9 ff			lda #$ff			LDA	#$FF			; set A
.cdf9									S_Bitc
.cdf9	2a				rol a				ROL				; shift bit
.cdfa	ca				dex					DEX				; decrement bit number
.cdfb	10 fc			bpl $cdf9			BPL	S_Bitc		; loop if still +ve
.cdfd	e8				inx					INX				; make X = $00
.cdfe	21 0a			and ($0a,x)			AND	(Itempl,X)		; and with byte via temporary integer (addr)
.ce00	81 0a			sta ($0a,x)			STA	(Itempl,X)		; save byte via temporary integer (addr)
.ce02	60				rts					RTS
.ce03									FCError
.ce03	4c 73 bf		jmp $bf73			JMP	LAB_FCER		; do function call error then warm start
.ce06									LAB_BTST
.ce06	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment BASIC pointer
.ce09	20 32 c5		jsr $c532			JSR	LAB_GADB		; get two parameters for POKE or WAIT
.ce0c	e0 08			cpx #$08			CPX	#$08			; only 0 to 7 are allowed
.ce0e	b0 f3			bcs $ce03			BCS	FCError		; branch if > 7
.ce10	20 76 00		jsr $0076			JSR	LAB_GBYT		; get next BASIC byte
.ce13	c9 29			cmp #$29			CMP	#')'			; is next character ")"
.ce15	f0 03			beq $ce1a			BEQ	TST_OK		; if ")" go do rest of function
.ce17	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; do syntax error then warm start
.ce1a									TST_OK
.ce1a	20 70 00		jsr $0070			JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
.ce1d	a9 00			lda #$00			LDA	#$00			; clear A
.ce1f	38				sec					SEC				; set the carry
.ce20									T_Bits
.ce20	2a				rol a				ROL				; shift bit
.ce21	ca				dex					DEX				; decrement bit number
.ce22	10 fc			bpl $ce20			BPL	T_Bits		; loop if still +ve
.ce24	e8				inx					INX				; make X = $00
.ce25	21 0a			and ($0a,x)			AND	(Itempl,X)		; AND with byte via temporary integer (addr)
.ce27	f0 02			beq $ce2b			BEQ	LAB_NOTT		; branch if zero (already correct)
.ce29	a9 ff			lda #$ff			LDA	#$FF			; set for -1 result
.ce2b									LAB_NOTT
.ce2b	4c 54 c9		jmp $c954			JMP	LAB_27DB		; go do SGN tail
.ce2e									LAB_BINS
.ce2e	e0 19			cpx #$19			CPX	#$19			; max + 1
.ce30	b0 48			bcs $ce7a			BCS	BinFErr		; exit if too big ( > or = )
.ce32	86 2c			stx $2c				STX	TempB			; save # of characters ($00 = leading zero remove)
.ce34	a9 18			lda #$18			LDA	#$18			; need A byte long space
.ce36	20 92 c1		jsr $c192			JSR	LAB_MSSP		; make string space A bytes long
.ce39	a0 17			ldy #$17			LDY	#$17			; set index
.ce3b	a2 18			ldx #$18			LDX	#$18			; character count
.ce3d									NextB1
.ce3d	46 0a			lsr $0a				LSR	nums_1		; shift highest byte
.ce3f	66 0b			ror $0b				ROR	nums_2		; shift middle byte
.ce41	66 0c			ror $0c				ROR	nums_3		; shift lowest byte bit 0 to carry
.ce43	8a				txa					TXA				; load with "0"/2
.ce44	2a				rol a				ROL				; shift in carry
.ce45	91 61			sta ($61),y			STA	(str_pl),Y		; save to temp string + index
.ce47	88				dey					DEY				; decrement index
.ce48	10 f3			bpl $ce3d			BPL	NextB1		; loop if not done
.ce4a	a5 2c			lda $2c				LDA	TempB			; get # of characters
.ce4c	f0 0a			beq $ce58			BEQ	EndBHS		; branch if truncate
.ce4e	aa				tax					TAX				; copy length to X
.ce4f	38				sec					SEC				; set carry for add !
.ce50	49 ff			eor #$ff			EOR	#$FF			; 1's complement
.ce52	69 18			adc #$18			ADC	#$18			; add 24d
.ce54	f0 1c			beq $ce72			BEQ	GoPr2			; if zero print whole string
.ce56	d0 0f			bne $ce67			BNE	GoPr1			; else go make output string
.ce58									EndBHS
.ce58	a8				tay					TAY				; clear index (A=0, X=length here)
.ce59									NextB2
.ce59	b1 61			lda ($61),y			LDA	(str_pl),Y		; get character from string
.ce5b	c9 30			cmp #$30			CMP	#'0'			; compare with "0"
.ce5d	d0 07			bne $ce66			BNE	GoPr			; if not "0" then go print string from here
.ce5f	ca				dex					DEX				; decrement character count
.ce60	f0 03			beq $ce65			BEQ	GoPr3			; if zero then end of string so go print it
.ce62	c8				iny					INY				; else increment index
.ce63	10 f4			bpl $ce59			BPL	NextB2		; loop always
.ce65									GoPr3
.ce65	e8				inx					INX				; need at least 1 character
.ce66									GoPr
.ce66	98				tya					TYA				; copy result
.ce67									GoPr1
.ce67	18				clc					CLC				; clear carry for add
.ce68	65 61			adc $61				ADC	str_pl		; add low address
.ce6a	85 61			sta $61				STA	str_pl		; save low address
.ce6c	a9 00			lda #$00			LDA	#$00			; do high byte
.ce6e	65 62			adc $62				ADC	str_ph		; add high address
.ce70	85 62			sta $62				STA	str_ph		; save high address
.ce72									GoPr2
.ce72	86 60			stx $60				STX	str_ln		; X holds string length
.ce74	20 70 00		jsr $0070			JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
.ce77	4c df c1		jmp $c1df			JMP	LAB_RTST		; check for space on descriptor stack then put address
.ce7a									BinFErr
.ce7a	4c 73 bf		jmp $bf73			JMP	LAB_FCER		; do function call error then warm start
.ce7d									LAB_HEXS
.ce7d	e0 07			cpx #$07			CPX	#$07			; max + 1
.ce7f	b0 f9			bcs $ce7a			BCS	BinFErr		; exit if too big ( > or = )
.ce81	86 2c			stx $2c				STX	TempB			; save # of characters
.ce83	a9 06			lda #$06			LDA	#$06			; need 6 bytes for string
.ce85	20 92 c1		jsr $c192			JSR	LAB_MSSP		; make string space A bytes long
.ce88	a0 05			ldy #$05			LDY	#$05			; set string index
.ce8a	f8				sed					SED				; need decimal mode for nibble convert
.ce8b	a5 0c			lda $0c				LDA	nums_3		; get lowest byte
.ce8d	20 ab ce		jsr $ceab			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
.ce90	a5 0b			lda $0b				LDA	nums_2		; get middle byte
.ce92	20 ab ce		jsr $ceab			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
.ce95	a5 0a			lda $0a				LDA	nums_1		; get highest byte
.ce97	20 ab ce		jsr $ceab			JSR	LAB_A2HX		; convert A to ASCII hex byte and output
.ce9a	d8				cld					CLD				; back to binary
.ce9b	a2 06			ldx #$06			LDX	#$06			; character count
.ce9d	a5 2c			lda $2c				LDA	TempB			; get # of characters
.ce9f	f0 b7			beq $ce58			BEQ	EndBHS		; branch if truncate
.cea1	aa				tax					TAX				; copy length to X
.cea2	38				sec					SEC				; set carry for add !
.cea3	49 ff			eor #$ff			EOR	#$FF			; 1's complement
.cea5	69 06			adc #$06			ADC	#$06			; add 6d
.cea7	f0 c9			beq $ce72			BEQ	GoPr2			; if zero print whole string
.cea9	d0 bc			bne $ce67			BNE	GoPr1			; else go make output string (branch always)
.ceab									LAB_A2HX
.ceab	aa				tax					TAX				; save byte
.ceac	29 0f			and #$0f			AND	#$0F			; mask off top bits
.ceae	20 b6 ce		jsr $ceb6			JSR	LAB_AL2X		; convert low nibble to ASCII and output
.ceb1	8a				txa					TXA				; get byte back
.ceb2	4a				lsr a				LSR				; /2	shift high nibble to low nibble
.ceb3	4a				lsr a				LSR				; /4
.ceb4	4a				lsr a				LSR				; /8
.ceb5	4a				lsr a				LSR				; /16
.ceb6									LAB_AL2X
.ceb6	c9 0a			cmp #$0a			CMP	#$0A			; set carry for +1 if >9
.ceb8	69 30			adc #$30			ADC	#'0'			; add ASCII "0"
.ceba	91 61			sta ($61),y			STA	(str_pl),Y		; save to temp string
.cebc	88				dey					DEY				; decrement counter
.cebd	60				rts					RTS
.cebe									LAB_NLTO
.cebe	85 60			sta $60				STA	FAC1_e		; save FAC1 exponent
.cec0	a9 00			lda #$00			LDA	#$00			; clear sign compare
.cec2									LAB_MLTE
.cec2	85 6c			sta $6c				STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.cec4	8a				txa					TXA				; restore character
.cec5	20 9f ca		jsr $ca9f			JSR	LAB_2912		; evaluate new ASCII digit
.cec8									LAB_CHEX
.cec8	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.cecb	90 0a			bcc $ced7			BCC	LAB_ISHN		; branch if numeric character
.cecd	09 20			ora #$20			ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
.cecf	e9 61			sbc #$61			SBC	#'a'			; subtract "a" (carry set here)
.ced1	c9 06			cmp #$06			CMP	#$06			; compare normalised with $06 (max+1)
.ced3	b0 2a			bcs $ceff			BCS	LAB_EXCH		; exit if >"f" or <"0"
.ced5	69 0a			adc #$0a			ADC	#$0A			; convert to nibble
.ced7									LAB_ISHN
.ced7	29 0f			and #$0f			AND	#$0F			; convert to binary
.ced9	aa				tax					TAX				; save nibble
.ceda	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.cedc	f0 e4			beq $cec2			BEQ	LAB_MLTE		; skip multiply if zero
.cede	69 04			adc #$04			ADC	#$04			; add four to exponent (*16 - carry clear here)
.cee0	90 dc			bcc $cebe			BCC	LAB_NLTO		; if no overflow do evaluate digit
.cee2									LAB_MLTO
.cee2	4c 1d c7		jmp $c71d			JMP	LAB_2564		; do overflow error and warm start
.cee5									LAB_NXCH
.cee5	aa				tax					TAX				; save bit
.cee6	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.cee8	f0 06			beq $cef0			BEQ	LAB_MLBT		; skip multiply if zero
.ceea	e6 60			inc $60				INC	FAC1_e		; increment FAC1 exponent (*2)
.ceec	f0 f4			beq $cee2			BEQ	LAB_MLTO		; do overflow error if = $00
.ceee	a9 00			lda #$00			LDA	#$00			; clear sign compare
.cef0									LAB_MLBT
.cef0	85 6c			sta $6c				STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.cef2	8a				txa					TXA				; restore bit
.cef3	20 9f ca		jsr $ca9f			JSR	LAB_2912		; evaluate new ASCII digit
.cef6									LAB_CBIN
.cef6	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.cef9	49 30			eor #$30			EOR	#'0'			; convert "0" to 0 etc.
.cefb	c9 02			cmp #$02			CMP	#$02			; compare with max+1
.cefd	90 e6			bcc $cee5			BCC	LAB_NXCH		; branch exit if < 2
.ceff									LAB_EXCH
.ceff	4c 84 ca		jmp $ca84			JMP	LAB_28F6		; evaluate -ve flag and return
.cf02									CTRLC
.cf02	ad 00 02		lda $0200			LDA	ccflag		; get [CTRL-C] check flag
.cf05	d0 18			bne $cf1f			BNE	LAB_FBA2		; exit if inhibited
.cf07	20 45 d1		jsr $d145			JSR	V_INPT		; scan input device
.cf0a	90 0b			bcc $cf17			BCC	LAB_FBA0		; exit if buffer empty
.cf0c	8d 01 02		sta $0201			STA	ccbyte		; save received byte
.cf0f	a2 20			ldx #$20			LDX	#$20			; "life" timer for bytes
.cf11	8e 02 02		stx $0202			STX	ccnull		; set countdown
.cf14	4c 66 b5		jmp $b566			JMP	LAB_1636		; return to BASIC
.cf17									LAB_FBA0
.cf17	ae 02 02		ldx $0202			LDX	ccnull		; get countdown byte
.cf1a	f0 03			beq $cf1f			BEQ	LAB_FBA2		; exit if finished
.cf1c	ce 02 02		dec $0202			DEC	ccnull		; else decrement countdown
.cf1f									LAB_FBA2
.cf1f	a2 90			ldx #$90			LDX	#NmiBase		; set pointer to NMI values
.cf21	20 2a cf		jsr $cf2a			JSR	LAB_CKIN		; go check interrupt
.cf24	a2 93			ldx #$93			LDX	#IrqBase		; set pointer to IRQ values
.cf26	20 2a cf		jsr $cf2a			JSR	LAB_CKIN		; go check interrupt
.cf29									LAB_CRTS
.cf29	60				rts					RTS
.cf2a									LAB_CKIN
.cf2a	b5 00			lda $00,x			LDA	PLUS_0,X		; get interrupt flag byte
.cf2c	10 fb			bpl $cf29			BPL	LAB_CRTS		; branch if interrupt not enabled
.cf2e	0a				asl a				ASL				; move happened bit to setup bit
.cf2f	29 40			and #$40			AND	#$40			; mask happened bits
.cf31	f0 f6			beq $cf29			BEQ	LAB_CRTS		; if no interrupt then exit
.cf33	95 00			sta $00,x			STA	PLUS_0,X		; save interrupt flag byte
.cf35	8a				txa					TXA				; copy index ..
.cf36	a8				tay					TAY				; .. to Y
.cf37	68				pla					PLA				; dump return address low byte, call from CTRL-C
.cf38	68				pla					PLA				; dump return address high byte
.cf39	a9 05			lda #$05			LDA	#$05			; need 5 bytes for GOSUB
.cf3b	20 56 b1		jsr $b156			JSR	LAB_1212		; check room on stack for A bytes
.cf3e	a5 78			lda $78				LDA	Bpntrh		; get BASIC execute pointer high byte
.cf40	48				pha					PHA				; push on stack
.cf41	a5 77			lda $77				LDA	Bpntrl		; get BASIC execute pointer low byte
.cf43	48				pha					PHA				; push on stack
.cf44	a5 3c			lda $3c				LDA	Clineh		; get current line high byte
.cf46	48				pha					PHA				; push on stack
.cf47	a5 3b			lda $3b				LDA	Clinel		; get current line low byte
.cf49	48				pha					PHA				; push on stack
.cf4a	a9 8d			lda #$8d			LDA	#TK_GOSUB		; token for GOSUB
.cf4c	48				pha					PHA				; push on stack
.cf4d	b9 01 00		lda $0001,y			LDA	PLUS_1,Y		; get interrupt code pointer low byte
.cf50	85 77			sta $77				STA	Bpntrl		; save as BASIC execute pointer low byte
.cf52	b9 02 00		lda $0002,y			LDA	PLUS_2,Y		; get interrupt code pointer high byte
.cf55	85 78			sta $78				STA	Bpntrh		; save as BASIC execute pointer high byte
.cf57	4c 0d b5		jmp $b50d			JMP	LAB_15C2		; go do interpreter inner loop
.cf5a									INGET
.cf5a	20 45 d1		jsr $d145			JSR	V_INPT		; call scan input device
.cf5d	b0 09			bcs $cf68			BCS	LAB_FB95		; if byte go reset timer
.cf5f	ad 02 02		lda $0202			LDA	ccnull		; get countdown
.cf62	f0 09			beq $cf6d			BEQ	LAB_FB96		; exit if empty
.cf64	ad 01 02		lda $0201			LDA	ccbyte		; get last received byte
.cf67	38				sec					SEC				; flag we got a byte
.cf68									LAB_FB95
.cf68	a2 00			ldx #$00			LDX	#$00			; clear X
.cf6a	8e 02 02		stx $0202			STX	ccnull		; clear timer because we got a byte
.cf6d									LAB_FB96
.cf6d	60				rts					RTS
.cf6e									LAB_IRQ
.cf6e	a2 93			ldx #$93			LDX	#IrqBase		; set pointer to IRQ values
>cf70	2c									.byte	$2C			; make next line BIT abs.
.cf71									LAB_NMI
.cf71	a2 90			ldx #$90			LDX	#NmiBase		; set pointer to NMI values
.cf73	c9 93			cmp #$93			CMP	#TK_ON		; compare with token for ON
.cf75	f0 11			beq $cf88			BEQ	LAB_INON		; go turn on interrupt
.cf77	c9 b6			cmp #$b6			CMP	#TK_OFF		; compare with token for OFF
.cf79	f0 07			beq $cf82			BEQ	LAB_IOFF		; go turn off interrupt
.cf7b	49 a2			eor #$a2			EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
.cf7d	f0 0e			beq $cf8d			BEQ	LAB_INEX		; go clear interrupt flags and return
.cf7f	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; do syntax error then warm start
.cf82									LAB_IOFF
.cf82	a9 7f			lda #$7f			LDA	#$7F			; clear A
.cf84	35 00			and $00,x			AND	PLUS_0,X		; AND with interrupt setup flag
.cf86	10 05			bpl $cf8d			BPL	LAB_INEX		; go clear interrupt enabled flag and return
.cf88									LAB_INON
.cf88	b5 00			lda $00,x			LDA	PLUS_0,X		; get interrupt setup flag
.cf8a	0a				asl a				ASL				; Shift bit to enabled flag
.cf8b	15 00			ora $00,x			ORA	PLUS_0,X		; OR with flag byte
.cf8d									LAB_INEX
.cf8d	95 00			sta $00,x			STA	PLUS_0,X		; save interrupt flag byte
.cf8f	4c 70 00		jmp $0070			JMP	LAB_IGBY		; update BASIC execute pointer and return
.cf92									LAB_SIRQ
.cf92	58				cli					CLI				; enable interrupts
.cf93	a2 93			ldx #$93			LDX	#IrqBase		; set pointer to IRQ values
>cf95	2c									.byte	$2C			; make next line BIT abs.
.cf96									LAB_SNMI
.cf96	a2 90			ldx #$90			LDX	#NmiBase		; set pointer to NMI values
.cf98	86 2c			stx $2c				STX	TempB			; save interrupt pointer
.cf9a	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory (past token)
.cf9d	20 a3 b7		jsr $b7a3			JSR	LAB_GFPN		; get fixed-point number into temp integer
.cfa0	a5 2d			lda $2d				LDA	Smeml			; get start of mem low byte
.cfa2	a6 2e			ldx $2e				LDX	Smemh			; get start of mem high byte
.cfa4	20 7b b3		jsr $b37b			JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.cfa7	b0 03			bcs $cfac			BCS	LAB_LFND		; if carry set go set-up interrupt
.cfa9	4c bd b6		jmp $b6bd			JMP	LAB_16F7		; else go do "Undefined statement" error and warm start
.cfac									LAB_LFND
.cfac	a6 2c			ldx $2c				LDX	TempB			; get interrupt pointer
.cfae	a5 5e			lda $5e				LDA	Baslnl		; get pointer low byte
.cfb0	e9 01			sbc #$01			SBC	#$01			; -1 (carry already set for subtract)
.cfb2	95 01			sta $01,x			STA	PLUS_1,X		; save as interrupt pointer low byte
.cfb4	a5 5f			lda $5f				LDA	Baslnh		; get pointer high byte
.cfb6	e9 00			sbc #$00			SBC	#$00			; subtract carry
.cfb8	95 02			sta $02,x			STA	PLUS_2,X		; save as interrupt pointer high byte
.cfba	a9 c0			lda #$c0			LDA	#$C0			; set interrupt enabled/setup bits
.cfbc	95 00			sta $00,x			STA	PLUS_0,X		; set interrupt flags
.cfbe									LAB_IRTS
.cfbe	60				rts					RTS
.cfbf									LAB_RETIRQ
.cfbf	d0 fd			bne $cfbe			BNE	LAB_IRTS		; exit if following token (to allow syntax error)
.cfc1	a5 93			lda $93				LDA	IrqBase		; get interrupt flags
.cfc3	0a				asl a				ASL				; copy setup to enabled (b7)
.cfc4	05 93			ora $93				ORA	IrqBase		; OR in setup flag
.cfc6	85 93			sta $93				STA	IrqBase		; save enabled flag
.cfc8	4c c4 b6		jmp $b6c4			JMP	LAB_16E8		; go do rest of RETURN
.cfcb									LAB_RETNMI
.cfcb	d0 f1			bne $cfbe			BNE	LAB_IRTS		; exit if following token (to allow syntax error)
.cfcd	a5 90			lda $90				LDA	NmiBase		; get set-up flag
.cfcf	0a				asl a				ASL				; copy setup to enabled (b7)
.cfd0	05 90			ora $90				ORA	NmiBase		; OR in setup flag
.cfd2	85 90			sta $90				STA	NmiBase		; save enabled flag
.cfd4	4c c4 b6		jmp $b6c4			JMP	LAB_16E8		; go do rest of RETURN
.cfd7									LAB_EXIT
.cfd7	db				stp					HLT
.cfd8									LAB_MMPP
.cfd8	20 31 bb		jsr $bb31			JSR	LAB_EVEZ		; process expression
.cfdb	4c 18 bb		jmp $bb18			JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
.cfde									LAB_MAX
.cfde	20 0c d0		jsr $d00c			JSR	LAB_PHFA		; push FAC1, evaluate expression,
.cfe1	10 fb			bpl $cfde			BPL	LAB_MAX		; branch if no swap to do
.cfe3	a5 68			lda $68				LDA	FAC2_1		; get FAC2 mantissa1
.cfe5	09 80			ora #$80			ORA	#$80			; set top bit (clear sign from compare)
.cfe7	85 68			sta $68				STA	FAC2_1		; save FAC2 mantissa1
.cfe9	20 1d c6		jsr $c61d			JSR	LAB_279B		; copy FAC2 to FAC1
.cfec	f0 f0			beq $cfde			BEQ	LAB_MAX		; go do next (branch always)
.cfee									LAB_MIN
.cfee	20 0c d0		jsr $d00c			JSR	LAB_PHFA		; push FAC1, evaluate expression,
.cff1	30 fb			bmi $cfee			BMI	LAB_MIN		; branch if no swap to do
.cff3	f0 f9			beq $cfee			BEQ	LAB_MIN		; branch if no swap to do
.cff5	a5 68			lda $68				LDA	FAC2_1		; get FAC2 mantissa1
.cff7	09 80			ora #$80			ORA	#$80			; set top bit (clear sign from compare)
.cff9	85 68			sta $68				STA	FAC2_1		; save FAC2 mantissa1
.cffb	20 1d c6		jsr $c61d			JSR	LAB_279B		; copy FAC2 to FAC1
.cffe	f0 ee			beq $cfee			BEQ	LAB_MIN		; go do next (branch always)
.d000									LAB_MMEC
.d000	c9 29			cmp #$29			CMP	#')'			; is it end of function?
.d002	d0 05			bne $d009			BNE	LAB_MMSE		; if not do MAX MIN syntax error
.d004	68				pla					PLA				; dump return address low byte
.d005	68				pla					PLA				; dump return address high byte
.d006	4c 70 00		jmp $0070			JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
.d009									LAB_MMSE
.d009	4c 4a bc		jmp $bc4a			JMP	LAB_SNER		; do syntax error then warm start
.d00c									LAB_PHFA
.d00c	20 76 00		jsr $0076			JSR	LAB_GBYT		; get next BASIC byte
.d00f	c9 2c			cmp #$2c			CMP	#','			; is there more ?
.d011	d0 ed			bne $d000			BNE	LAB_MMEC		; if not go do end check
.d013	20 33 c9		jsr $c933			JSR	LAB_27BA		; round FAC1
.d016	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign
.d018	09 7f			ora #$7f			ORA	#$7F			; set all non sign bits
.d01a	25 61			and $61				AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
.d01c	48				pha					PHA				; push on stack
.d01d	a5 62			lda $62				LDA	FAC1_2		; get FAC1 mantissa2
.d01f	48				pha					PHA				; push on stack
.d020	a5 63			lda $63				LDA	FAC1_3		; get FAC1 mantissa3
.d022	48				pha					PHA				; push on stack
.d023	a5 60			lda $60				LDA	FAC1_e		; get FAC1 exponent
.d025	48				pha					PHA				; push on stack
.d026	20 70 00		jsr $0070			JSR	LAB_IGBY		; scan and get next BASIC byte (after ",")
.d029	20 15 bb		jsr $bb15			JSR	LAB_EVNM		; evaluate expression and check is numeric,
.d02c	68				pla					PLA				; pop exponent
.d02d	85 67			sta $67				STA	FAC2_e		; save FAC2 exponent
.d02f	68				pla					PLA				; pop mantissa3
.d030	85 6a			sta $6a				STA	FAC2_3		; save FAC2 mantissa3
.d032	68				pla					PLA				; pop mantissa1
.d033	85 69			sta $69				STA	FAC2_2		; save FAC2 mantissa2
.d035	68				pla					PLA				; pop sign/mantissa1
.d036	85 68			sta $68				STA	FAC2_1		; save FAC2 sign/mantissa1
.d038	85 6b			sta $6b				STA	FAC2_s		; save FAC2 sign
.d03a	a9 67			lda #$67			LDA	#<FAC2_e		; set pointer low byte to FAC2
.d03c	a0 00			ldy #$00			LDY	#>FAC2_e		; set pointer high byte to FAC2
.d03e	4c 71 c9		jmp $c971			JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
.d041									LAB_WDTH
.d041	c9 2c			cmp #$2c			CMP	#','			; is next byte ","
.d043	f0 1b			beq $d060			BEQ	LAB_TBSZ		; if so do tab size
.d045	20 e6 c4		jsr $c4e6			JSR	LAB_GTBY		; get byte parameter
.d048	8a				txa					TXA				; copy width to A
.d049	f0 0a			beq $d055			BEQ	LAB_NSTT		; branch if set for infinite line
.d04b	e0 10			cpx #$10			CPX	#$10			; else make min width = 16d
.d04d	90 45			bcc $d094			BCC	TabErr		; if less do function call error and exit
.d04f	e4 17			cpx $17				CPX	TabSiz		; compare with tab size
.d051	b0 02			bcs $d055			BCS	LAB_NSTT		; branch if >= tab size
.d053	86 17			stx $17				STX	TabSiz		; else make tab size = terminal width
.d055									LAB_NSTT
.d055	86 08			stx $08				STX	TWidth		; set the terminal width
.d057	20 76 00		jsr $0076			JSR	LAB_GBYT		; get BASIC byte back
.d05a	f0 1a			beq $d076			BEQ	WExit			; exit if no following
.d05c	c9 2c			cmp #$2c			CMP	#','			; else is it ","
.d05e	d0 a9			bne $d009			BNE	LAB_MMSE		; if not do syntax error
.d060									LAB_TBSZ
.d060	20 e3 c4		jsr $c4e3			JSR	LAB_SGBY		; scan and get byte parameter
.d063	8a				txa					TXA				; copy TAB size
.d064	30 2e			bmi $d094			BMI	TabErr		; if >127 do function call error and exit
.d066	e0 01			cpx #$01			CPX	#$01			; compare with min-1
.d068	90 2a			bcc $d094			BCC	TabErr		; if <=1 do function call error and exit
.d06a	a5 08			lda $08				LDA	TWidth		; set flags for width
.d06c	f0 06			beq $d074			BEQ	LAB_SVTB		; skip check if infinite line
.d06e	e4 08			cpx $08				CPX	TWidth		; compare TAB with width
.d070	f0 02			beq $d074			BEQ	LAB_SVTB		; ok if =
.d072	b0 20			bcs $d094			BCS	TabErr		; branch if too big
.d074									LAB_SVTB
.d074	86 17			stx $17				STX	TabSiz		; save TAB size
.d076									WExit
.d076	a5 08			lda $08				LDA	TWidth		; get width
.d078	f0 06			beq $d080			BEQ	LAB_SULP		; branch if infinite line
.d07a	c5 17			cmp $17				CMP	TabSiz		; compare with tab size
.d07c	b0 03			bcs $d081			BCS	LAB_WDLP		; branch if >= tab size
.d07e	85 17			sta $17				STA	TabSiz		; else make tab size = terminal width
.d080									LAB_SULP
.d080	38				sec					SEC				; set carry for subtract
.d081									LAB_WDLP
.d081	e5 17			sbc $17				SBC	TabSiz		; subtract tab size
.d083	b0 fc			bcs $d081			BCS	LAB_WDLP		; loop while no borrow
.d085	65 17			adc $17				ADC	TabSiz		; add tab size back
.d087	18				clc					CLC				; clear carry for add
.d088	65 17			adc $17				ADC	TabSiz		; add tab size back again
.d08a	85 09			sta $09				STA	Iclim			; save for now
.d08c	a5 08			lda $08				LDA	TWidth		; get width back
.d08e	38				sec					SEC				; set carry for subtract
.d08f	e5 09			sbc $09				SBC	Iclim			; subtract remainder
.d091	85 09			sta $09				STA	Iclim			; save tab column limit
.d093									LAB_NOSQ
.d093	60				rts					RTS
.d094									TabErr
.d094	4c 73 bf		jmp $bf73			JMP	LAB_FCER		; do function call error then warm start
.d097									LAB_SQR
.d097	a5 64			lda $64				LDA	FAC1_s		; get FAC1 sign
.d099	30 f9			bmi $d094			BMI	TabErr		; if -ve do function call error
.d09b	a5 60			lda $60				LDA	FAC1_e		; get exponent
.d09d	f0 f4			beq $d093			BEQ	LAB_NOSQ		; if zero just return
.d09f	20 24 c9		jsr $c924			JSR	LAB_27AB		; round and copy FAC1 to FAC2
.d0a2	a9 00			lda #$00			LDA	#$00			; clear A
.d0a4	85 2b			sta $2b				STA	FACt_3		; clear remainder
.d0a6	85 2a			sta $2a				STA	FACt_2		; ..
.d0a8	85 29			sta $29				STA	FACt_1		; ..
.d0aa	85 2c			sta $2c				STA	TempB			; ..
.d0ac	85 63			sta $63				STA	FAC1_3		; clear root
.d0ae	85 62			sta $62				STA	FAC1_2		; ..
.d0b0	85 61			sta $61				STA	FAC1_1		; ..
.d0b2	a2 18			ldx #$18			LDX	#$18			; 24 pairs of bits to do
.d0b4	a5 67			lda $67				LDA	FAC2_e		; get exponent
.d0b6	4a				lsr a				LSR				; check odd/even
.d0b7	b0 0e			bcs $d0c7			BCS	LAB_SQE2		; if odd only 1 shift first time
.d0b9									LAB_SQE1
.d0b9	06 6a			asl $6a				ASL	FAC2_3		; shift highest bit of number ..
.d0bb	26 69			rol $69				ROL	FAC2_2		; ..
.d0bd	26 68			rol $68				ROL	FAC2_1		; ..
.d0bf	26 2b			rol $2b				ROL	FACt_3		; .. into remainder
.d0c1	26 2a			rol $2a				ROL	FACt_2		; ..
.d0c3	26 29			rol $29				ROL	FACt_1		; ..
.d0c5	26 2c			rol $2c				ROL	TempB			; .. never overflows
.d0c7									LAB_SQE2
.d0c7	06 6a			asl $6a				ASL	FAC2_3		; shift highest bit of number ..
.d0c9	26 69			rol $69				ROL	FAC2_2		; ..
.d0cb	26 68			rol $68				ROL	FAC2_1		; ..
.d0cd	26 2b			rol $2b				ROL	FACt_3		; .. into remainder
.d0cf	26 2a			rol $2a				ROL	FACt_2		; ..
.d0d1	26 29			rol $29				ROL	FACt_1		; ..
.d0d3	26 2c			rol $2c				ROL	TempB			; .. never overflows
.d0d5	06 63			asl $63				ASL	FAC1_3		; root = root * 2
.d0d7	26 62			rol $62				ROL	FAC1_2		; ..
.d0d9	26 61			rol $61				ROL	FAC1_1		; .. never overflows
.d0db	a5 63			lda $63				LDA	FAC1_3		; get root low byte
.d0dd	2a				rol a				ROL				; *2
.d0de	85 0d			sta $0d				STA	Temp3			; save partial low byte
.d0e0	a5 62			lda $62				LDA	FAC1_2		; get root low mid byte
.d0e2	2a				rol a				ROL				; *2
.d0e3	85 0e			sta $0e				STA	Temp3+1		; save partial low mid byte
.d0e5	a5 61			lda $61				LDA	FAC1_1		; get root high mid byte
.d0e7	2a				rol a				ROL				; *2
.d0e8	85 0f			sta $0f				STA	Temp3+2		; save partial high mid byte
.d0ea	a9 00			lda #$00			LDA	#$00			; get root high byte (always $00)
.d0ec	2a				rol a				ROL				; *2
.d0ed	85 10			sta $10				STA	Temp3+3		; save partial high byte
.d0ef	a5 2b			lda $2b				LDA	FACt_3		; get remainder low byte
.d0f1	e5 0d			sbc $0d				SBC	Temp3			; subtract partial low byte
.d0f3	85 0d			sta $0d				STA	Temp3			; save partial low byte
.d0f5	a5 2a			lda $2a				LDA	FACt_2		; get remainder low mid byte
.d0f7	e5 0e			sbc $0e				SBC	Temp3+1		; subtract partial low mid byte
.d0f9	85 0e			sta $0e				STA	Temp3+1		; save partial low mid byte
.d0fb	a5 29			lda $29				LDA	FACt_1		; get remainder high mid byte
.d0fd	e5 0f			sbc $0f				SBC	Temp3+2		; subtract partial high mid byte
.d0ff	a8				tay					TAY				; copy partial high mid byte
.d100	a5 2c			lda $2c				LDA	TempB			; get remainder high byte
.d102	e5 10			sbc $10				SBC	Temp3+3		; subtract partial high byte
.d104	90 0e			bcc $d114			BCC	LAB_SQNS		; skip sub if remainder smaller
.d106	85 2c			sta $2c				STA	TempB			; save remainder high byte
.d108	84 29			sty $29				STY	FACt_1		; save remainder high mid byte
.d10a	a5 0e			lda $0e				LDA	Temp3+1		; get remainder low mid byte
.d10c	85 2a			sta $2a				STA	FACt_2		; save remainder low mid byte
.d10e	a5 0d			lda $0d				LDA	Temp3			; get partial low byte
.d110	85 2b			sta $2b				STA	FACt_3		; save remainder low byte
.d112	e6 63			inc $63				INC	FAC1_3		; increment root low byte (never any rollover)
.d114									LAB_SQNS
.d114	ca				dex					DEX				; decrement bit pair count
.d115	d0 a2			bne $d0b9			BNE	LAB_SQE1		; loop if not all done
.d117	38				sec					SEC				; set carry for subtract
.d118	a5 67			lda $67				LDA	FAC2_e		; get exponent
.d11a	e9 80			sbc #$80			SBC	#$80			; normalise
.d11c	6a				ror a				ROR				; /2 and re-bias to $80
.d11d	69 00			adc #$00			ADC	#$00			; add bit zero back in (allow for half shift)
.d11f	85 60			sta $60				STA	FAC1_e		; save it
.d121	4c 8e c6		jmp $c68e			JMP	LAB_24D5		; normalise FAC1 and return
.d124									LAB_VARPTR
.d124	20 70 00		jsr $0070			JSR	LAB_IGBY		; increment and scan memory
.d127	20 f4 bd		jsr $bdf4			JSR	LAB_GVAR		; get var address
.d12a	20 37 bc		jsr $bc37			JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.d12d	a4 49			ldy $49				LDY	Cvaral		; get var address low byte
.d12f	a5 4a			lda $4a				LDA	Cvarah		; get var address high byte
.d131	4c a5 c0		jmp $c0a5			JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.d134									LAB_PI
.d134	a9 13			lda #$13			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.d136	a0 d2			ldy #$d2			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.d138	20 d7 c8		jsr $c8d7			JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.d13b	c6 60			dec $60				DEC	FAC1_e		; make result = PI
.d13d	60				rts					RTS
.d13e									LAB_TWOPI
.d13e	a9 13			lda #$13			LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.d140	a0 d2			ldy #$d2			LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.d142	4c d7 c8		jmp $c8d7			JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
.d145									V_INPT
.d145	6c 05 02		jmp ($0205)			JMP	(VEC_IN)		; non halting scan input device
.d148									V_OUTP
.d148	6c 07 02		jmp ($0207)			JMP	(VEC_OUT)		; send byte to output device
.d14b									V_LOAD
.d14b	6c 09 02		jmp ($0209)			JMP	(VEC_LD)		; load BASIC program
.d14e									V_SAVE
.d14e	6c 0b 02		jmp ($020b)			JMP	(VEC_SV)		; save BASIC program
.d151									PG2_TABS
>d151	00									.byte	$00			; ctrl-c flag		-	$00 = enabled
>d152	00									.byte	$00			; ctrl-c byte		-	GET needs this
>d153	00									.byte	$00			; ctrl-c byte timeout	-	GET needs this
>d154	02 cf								.word	CTRLC			; ctrl c check vector
.d156									PG2_TABE
.d156									LAB_2CEE
.d156	e6 77			inc $77				INC	Bpntrl		; increment BASIC execute pointer low byte
.d158	d0 02			bne $d15c			BNE	LAB_2CF4		; branch if no carry
.d15a	e6 78			inc $78				INC	Bpntrh		; increment BASIC execute pointer high byte
.d15c									LAB_2CF4
.d15c	ad ff ff		lda $ffff			LDA	$FFFF			; get byte to scan (addr set by call routine)
.d15f	c9 ad			cmp #$ad			CMP	#TK_ELSE		; compare with the token for ELSE
.d161	f0 0e			beq $d171			BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
.d163	c9 3a			cmp #$3a			CMP	#':'			; compare with ":"
.d165	b0 0a			bcs $d171			BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
.d167	c9 20			cmp #$20			CMP	#' '			; compare with " "
.d169	f0 eb			beq $d156			BEQ	LAB_2CEE		; if " " go do next
.d16b	38				sec					SEC				; set carry for SBC
.d16c	e9 30			sbc #$30			SBC	#'0'			; subtract "0"
.d16e	38				sec					SEC				; set carry for SBC
.d16f	e9 d0			sbc #$d0			SBC	#$D0			; subtract -"0"
.d171									LAB_2D05
.d171	60				rts					RTS
.d172									StrTab
>d172	4c									.byte	$4C			; JMP opcode
>d173	5f b0								.word LAB_COLD		; initial warm start vector (cold start)
>d175	00									.byte	$00			; these bytes are not used by BASIC
>d176	00 00								.word	$0000			;
>d178	00 00								.word	$0000			;
>d17a	00 00								.word	$0000			;
>d17c	4c									.byte	$4C			; JMP opcode
>d17d	73 bf								.word	LAB_FCER		; initial user function vector ("Function call" error)
>d17f	00									.byte	$00			; default NULL count
>d180	00									.byte	$00			; clear terminal position
>d181	00									.byte	$00			; default terminal width byte
>d182	f2									.byte	$F2			; default limit for TAB = 14
>d183	00 03								.word	Ram_base		; start of user RAM
.d185									EndTab
.d185									LAB_MSZM
>d185	0a 4d 65 6d 6f 72 79 20				.text	$0A,"Memory size ",$00
>d18d	73 69 7a 65 20 00
.d193									LAB_SMSG
>d193	20 42 79 74 65 73 20 66				.text	" Bytes free",$0A; ,$0A
>d19b	72 65 65 0a
>d19f	45 6e 68 61 6e 63 65 64				.text	"Enhanced BASIC 2.22",$0A,$00
>d1a7	20 42 41 53 49 43 20 32 2e 32 32 0a 00
.d1b4									LAB_25A0
>d1b4	02									.byte	$02			; counter
>d1b5	80 19 56 62							.byte	$80,$19,$56,$62	; 0.59898
>d1b9	80 76 22 f3							.byte	$80,$76,$22,$F3	; 0.96147
>d1bd	82 38 aa 40							.byte	$82,$38,$AA,$40	; 2.88539
.d1c1									LAB_25AD
>d1c1	80 35 04 f3							.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
.d1c5									LAB_25B1
>d1c5	81 35 04 f3							.byte	$81,$35,$04,$F3	; 1.41421	root 2
.d1c9									LAB_25B5
>d1c9	80 80 00 00							.byte	$80,$80,$00,$00	; -0.5
.d1cd									LAB_25B9
>d1cd	80 31 72 18							.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
.d1d1									LAB_2947
>d1d1	91 43 4f f8							.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
.d1d5									LAB_294B
>d1d5	94 74 23 f7							.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
.d1d9									LAB_294F
>d1d9	94 74 24 00							.byte	$94,$74,$24,$00	; 1000000
.d1dd									LAB_2AFA
>d1dd	81 38 aa 3b							.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
.d1e1									LAB_2AFE
>d1e1	06									.byte	$06			; counter
>d1e2	74 63 90 8c							.byte	$74,$63,$90,$8C	; 2.17023e-4
>d1e6	77 23 0c ab							.byte	$77,$23,$0C,$AB	; 0.00124
>d1ea	7a 1e 94 00							.byte	$7A,$1E,$94,$00	; 0.00968
>d1ee	7c 63 42 80							.byte	$7C,$63,$42,$80	; 0.05548
>d1f2	7e 75 fe d0							.byte	$7E,$75,$FE,$D0	; 0.24023
>d1f6	80 31 72 15							.byte	$80,$31,$72,$15	; 0.69315
>d1fa	81 00 00 00							.byte	$81,$00,$00,$00	; 1.00000
.d1fe									LAB_2C78
>d1fe	81 49 0f db							.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
.d202									LAB_2C84
>d202	04									.byte	$04			; counter
>d203	86 1e d7 fb							.byte	$86,$1E,$D7,$FB	; 39.7109
>d207	87 99 26 65							.byte	$87,$99,$26,$65	;-76.575
>d20b	87 23 34 58							.byte	$87,$23,$34,$58	; 81.6022
>d20f	86 a5 5d e1							.byte	$86,$A5,$5D,$E1	;-41.3417
.d213									LAB_2C7C
>d213	83 49 0f db							.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
.d217									LAB_2CC9
>d217	08									.byte	$08			; counter
>d218	78 3a c5 37							.byte	$78,$3A,$C5,$37	; 0.00285
>d21c	7b 83 a2 5c							.byte	$7B,$83,$A2,$5C	;-0.0160686
>d220	7c 2e dd 4d							.byte	$7C,$2E,$DD,$4D	; 0.0426915
>d224	7d 99 b0 1e							.byte	$7D,$99,$B0,$1E	;-0.0750429
>d228	7d 59 ed 24							.byte	$7D,$59,$ED,$24	; 0.106409
>d22c	7e 91 72 00							.byte	$7E,$91,$72,$00	;-0.142036
>d230	7e 4c b9 73							.byte	$7E,$4C,$B9,$73	; 0.199926
>d234	7f aa aa 53							.byte	$7F,$AA,$AA,$53	;-0.333331
=$d239									LAB_1D96	= *+1			; $00,$00 used for undefined variables
.d238									LAB_259C
>d238	81 00 00 00							.byte	$81,$00,$00,$00	; 1.000000, used for INC
.d23c									LAB_2AFD
>d23c	81 80 00 00							.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
.d240									LAB_1DF7
>d240	90									.byte	$90			;-32768 (uses first three bytes from 0.5)
.d241									LAB_2A96
>d241	80 00 00 00							.byte	$80,$00,$00,$00	; 0.5
.d245									LAB_2C80
>d245	7f 00 00 00							.byte	$7F,$00,$00,$00	; 0.25
.d249									LAB_26B5
>d249	84 20 00 00							.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
.d24d									LAB_2A9A
=$d24e									LAB_2A9B = LAB_2A9A+1
=$d24f									LAB_2A9C = LAB_2A9B+1
>d24d	fe 79 60							.byte	$FE,$79,$60		; -100000
>d250	00 27 10							.byte	$00,$27,$10		; 10000
>d253	ff fc 18							.byte	$FF,$FC,$18		; -1000
>d256	00 00 64							.byte	$00,$00,$64		; 100
>d259	ff ff f6							.byte	$FF,$FF,$F6		; -10
>d25c	00 00 01							.byte	$00,$00,$01		; 1
.d25f									LAB_CTBL
>d25f	69 b5								.word	LAB_END-1		; END
>d261	a8 b4								.word	LAB_FOR-1		; FOR
>d263	ac ba								.word	LAB_NEXT-1		; NEXT
>d265	d6 b6								.word	LAB_DATA-1		; DATA
>d267	8f b9								.word	LAB_INPUT-1		; INPUT
>d269	a8 bd								.word	LAB_DIM-1		; DIM
>d26b	ae b9								.word	LAB_READ-1		; READ
>d26d	01 b8								.word	LAB_LET-1		; LET
>d26f	d3 b7								.word	LAB_DEC-1		; DEC			new command
>d271	35 b6								.word	LAB_GOTO-1		; GOTO
>d273	f4 b5								.word	LAB_RUN-1		; RUN
>d275	04 b7								.word	LAB_IF-1		; IF
>d277	8a b5								.word	LAB_RESTORE-1	; RESTORE		modified command
>d279	18 b6								.word	LAB_GOSUB-1		; GOSUB
>d27b	be cf								.word	LAB_RETIRQ-1	; RETIRQ		new command
>d27d	ca cf								.word	LAB_RETNMI-1	; RETNMI		new command
>d27f	c1 b6								.word	LAB_RETURN-1	; RETURN
>d281	6b b7								.word	LAB_REM-1		; REM
>d283	67 b5								.word	LAB_STOP-1		; STOP
>d285	74 b7								.word	LAB_ON-1		; ON			modified command
>d287	c8 b5								.word	LAB_NULL-1		; NULL		modified command
>d289	d6 b7								.word	LAB_INC-1		; INC			new command
>d28b	e2 c5								.word	LAB_WAIT-1		; WAIT
>d28d	4a d1								.word	V_LOAD-1		; LOAD
>d28f	4d d1								.word	V_SAVE-1		; SAVE
>d291	cb c0								.word	LAB_DEF-1		; DEF
>d293	67 c5								.word	LAB_POKE-1		; POKE
>d295	83 c5								.word	LAB_DOKE-1		; DOKE		new command
>d297	d0 c5								.word	LAB_CALL-1		; CALL		new command
>d299	fe b5								.word	LAB_DO-1		; DO			new command
>d29b	67 b6								.word	LAB_LOOP-1		; LOOP		new command
>d29d	a2 b8								.word	LAB_PRINT-1		; PRINT
>d29f	ce b5								.word	LAB_CONT-1		; CONT
>d2a1	f3 b3								.word	LAB_LIST-1		; LIST
>d2a3	f0 b3								.word	LAB_CLEAR-1		; CLEAR
>d2a5	a0 b3								.word	LAB_NEW-1		; NEW
>d2a7	40 d0								.word	LAB_WDTH-1		; WIDTH		new command
>d2a9	71 b8								.word	LAB_GET-1		; GET			new command
>d2ab	a8 c5								.word	LAB_SWAP-1		; SWAP		new command
>d2ad	db cd								.word	LAB_BITSET-1	; BITSET		new command
>d2af	ef cd								.word	LAB_BITCLR-1	; BITCLR		new command
>d2b1	6d cf								.word	LAB_IRQ-1		; IRQ			new command
>d2b3	70 cf								.word	LAB_NMI-1		; NMI			new command
>d2b5	d6 cf								.word	LAB_EXIT-1		; EXIT			new command
.d2b7									LAB_FTPL
=$d2b8									LAB_FTPM	= LAB_FTPL+$01
>d2b7	ae bc								.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
>d2b9	ae bc								.word	LAB_PPFN-1		; INT(n)		"
>d2bb	ae bc								.word	LAB_PPFN-1		; ABS(n)		"
>d2bd	30 bb								.word	LAB_EVEZ-1		; USR(x)	process any expression
>d2bf	33 bc								.word	LAB_1BF7-1		; FRE(x)		"
>d2c1	33 bc								.word	LAB_1BF7-1		; POS(x)		"
>d2c3	ae bc								.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
>d2c5	ae bc								.word	LAB_PPFN-1		; RND(n)		"
>d2c7	ae bc								.word	LAB_PPFN-1		; LOG(n)		"
>d2c9	ae bc								.word	LAB_PPFN-1		; EXP(n)		"
>d2cb	ae bc								.word	LAB_PPFN-1		; COS(n)		"
>d2cd	ae bc								.word	LAB_PPFN-1		; SIN(n)		"
>d2cf	ae bc								.word	LAB_PPFN-1		; TAN(n)		"
>d2d1	ae bc								.word	LAB_PPFN-1		; ATN(n)		"
>d2d3	ae bc								.word	LAB_PPFN-1		; PEEK(n)		"
>d2d5	ae bc								.word	LAB_PPFN-1		; DEEK(n)		"
>d2d7	00 00								.word	$0000			; SADD()	none
>d2d9	a8 bc								.word	LAB_PPFS-1		; LEN($)	process string expression in ()
>d2db	ae bc								.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
>d2dd	a8 bc								.word	LAB_PPFS-1		; VAL($)	process string expression in ()
>d2df	a8 bc								.word	LAB_PPFS-1		; ASC($)		"
>d2e1	a8 bc								.word	LAB_PPFS-1		; UCASE$($)		"
>d2e3	a8 bc								.word	LAB_PPFS-1		; LCASE$($)		"
>d2e5	ae bc								.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
>d2e7	d5 bc								.word	LAB_BHSS-1		; HEX$(n)		"
>d2e9	d5 bc								.word	LAB_BHSS-1		; BIN$(n)		"
>d2eb	00 00								.word	$0000			; BITTST()	none
>d2ed	d7 cf								.word	LAB_MMPP-1		; MAX()	process numeric expression
>d2ef	d7 cf								.word	LAB_MMPP-1		; MIN()		"
>d2f1	b4 bc								.word	LAB_PPBI-1		; PI		advance pointer
>d2f3	b4 bc								.word	LAB_PPBI-1		; TWOPI		"
>d2f5	00 00								.word	$0000			; VARPTR()	none
>d2f7	b9 bc								.word	LAB_LRMS-1		; LEFT$()	process string expression
>d2f9	b9 bc								.word	LAB_LRMS-1		; RIGHT$()		"
>d2fb	b9 bc								.word	LAB_LRMS-1		; MID$()		"
.d2fd									LAB_FTBL
=$d2fe									LAB_FTBM	= LAB_FTBL+$01
>d2fd	50 c9								.word	LAB_SGN-1		; SGN()
>d2ff	da c9								.word	LAB_INT-1		; INT()
>d301	6d c9								.word	LAB_ABS-1		; ABS()
>d303	a6 cd								.word	LAB_USR-1		; USR()
>d305	8e c0								.word	LAB_FRE-1		; FRE()
>d307	bb c0								.word	LAB_POS-1		; POS()
>d309	96 d0								.word	LAB_SQR-1		; SQR()
>d30b	f6 cc								.word	LAB_RND-1		; RND()		modified function
>d30d	54 c7								.word	LAB_LOG-1		; LOG()
>d30f	58 cc								.word	LAB_EXP-1		; EXP()
>d311	2a cd								.word	LAB_COS-1		; COS()
>d313	31 cd								.word	LAB_SIN-1		; SIN()
>d315	7a cd								.word	LAB_TAN-1		; TAN()
>d317	ac cd								.word	LAB_ATN-1		; ATN()
>d319	5c c5								.word	LAB_PEEK-1		; PEEK()
>d31b	70 c5								.word	LAB_DEEK-1		; DEEK()		new function
>d31d	ae c4								.word	LAB_SADD-1		; SADD()		new function
>d31f	c7 c4								.word	LAB_LENS-1		; LEN()
>d321	7d c1								.word	LAB_STRS-1		; STR$()
>d323	f4 c4								.word	LAB_VAL-1		; VAL()
>d325	d2 c4								.word	LAB_ASC-1		; ASC()
>d327	8c c4								.word	LAB_UCASE-1		; UCASE$()		new function
>d329	6b c4								.word	LAB_LCASE-1		; LCASE$()		new function
>d32b	dd c3								.word	LAB_CHRS-1		; CHR$()
>d32d	7c ce								.word	LAB_HEXS-1		; HEX$()		new function
>d32f	2d ce								.word	LAB_BINS-1		; BIN$()		new function
>d331	05 ce								.word	LAB_BTST-1		; BITTST()		new function
>d333	dd cf								.word	LAB_MAX-1		; MAX()		new function
>d335	ed cf								.word	LAB_MIN-1		; MIN()		new function
>d337	33 d1								.word	LAB_PI-1		; PI			new function
>d339	3d d1								.word	LAB_TWOPI-1		; TWOPI		new function
>d33b	23 d1								.word	LAB_VARPTR-1	; VARPTR()		new function
>d33d	ef c3								.word	LAB_LEFT-1		; LEFT$()
>d33f	f8 c3								.word	LAB_RIGHT-1		; RIGHT$()
>d341	27 c4								.word	LAB_MIDS-1		; MID$()
.d343									LAB_OPPT
>d343	79									.byte	$79			; +
>d344	1a c6								.word	LAB_ADD-1
>d346	79									.byte	$79			; -
>d347	ff c5								.word	LAB_SUBTRACT-1
>d349	7b									.byte	$7B			; *
>d34a	95 c7								.word	LAB_MULTIPLY-1
>d34c	7b									.byte	$7B			; /
>d34d	5d c8								.word	LAB_DIVIDE-1
>d34f	7f									.byte	$7F			; ^
>d350	14 cc								.word	LAB_POWER-1
>d352	50									.byte	$50			; AND
>d353	1e bd								.word	LAB_AND-1
>d355	46									.byte	$46			; EOR			new operator
>d356	04 bd								.word	LAB_EOR-1
>d358	46									.byte	$46			; OR
>d359	11 bd								.word	LAB_OR-1
>d35b	56									.byte	$56			; >>			new operator
>d35c	ca bd								.word	LAB_RSHIFT-1
>d35e	56									.byte	$56			; <<			new operator
>d35f	b2 bd								.word	LAB_LSHIFT-1
>d361	7d									.byte	$7D			; >
>d362	4d cc								.word	LAB_GTHAN-1
>d364	5a									.byte	$5A			; =
>d365	5e bc								.word	LAB_EQUAL-1
>d367	64									.byte	$64			; <
>d368	3f bd								.word	LAB_LTHAN-1
.d36a									TAB_1STC
>d36a	2a									.byte	"*"
>d36b	2b									.byte	"+"
>d36c	2d									.byte	"-"
>d36d	2f									.byte	"/"
>d36e	3c									.byte	"<"
>d36f	3d									.byte	"="
>d370	3e									.byte	">"
>d371	3f									.byte	"?"
>d372	41									.byte	"A"
>d373	42									.byte	"B"
>d374	43									.byte	"C"
>d375	44									.byte	"D"
>d376	45									.byte	"E"
>d377	46									.byte	"F"
>d378	47									.byte	"G"
>d379	48									.byte	"H"
>d37a	49									.byte	"I"
>d37b	4c									.byte	"L"
>d37c	4d									.byte	"M"
>d37d	4e									.byte	"N"
>d37e	4f									.byte	"O"
>d37f	50									.byte	"P"
>d380	52									.byte	"R"
>d381	53									.byte	"S"
>d382	54									.byte	"T"
>d383	55									.byte	"U"
>d384	56									.byte	"V"
>d385	57									.byte	"W"
>d386	5e									.byte	"^"
>d387	00									.byte	$00			; table terminator
.d388									TAB_CHRT
>d388	c2 d3								.word	TAB_STAR		; table for "*"
>d38a	c4 d3								.word	TAB_PLUS		; table for "+"
>d38c	c6 d3								.word	TAB_MNUS		; table for "-"
>d38e	c8 d3								.word	TAB_SLAS		; table for "/"
>d390	ca d3								.word	TAB_LESS		; table for "<"
>d392	ce d3								.word	TAB_EQUL		; table for "="
>d394	d0 d3								.word	TAB_MORE		; table for ">"
>d396	d4 d3								.word	TAB_QEST		; table for "?"
>d398	d6 d3								.word	TAB_ASCA		; table for "A"
>d39a	e6 d3								.word	TAB_ASCB		; table for "B"
>d39c	ff d3								.word	TAB_ASCC		; table for "C"
>d39e	16 d4								.word	TAB_ASCD		; table for "D"
>d3a0	2f d4								.word	TAB_ASCE		; table for "E"
>d3a2	42 d4								.word	TAB_ASCF		; table for "F"
>d3a4	4c d4								.word	TAB_ASCG		; table for "G"
>d3a6	59 d4								.word	TAB_ASCH		; table for "H"
>d3a8	5f d4								.word	TAB_ASCI		; table for "I"
>d3aa	71 d4								.word	TAB_ASCL		; table for "L"
>d3ac	96 d4								.word	TAB_ASCM		; table for "M"
>d3ae	a4 d4								.word	TAB_ASCN		; table for "N"
>d3b0	b6 d4								.word	TAB_ASCO		; table for "O"
>d3b2	be d4								.word	TAB_ASCP		; table for "P"
>d3b4	d3 d4								.word	TAB_ASCR		; table for "R"
>d3b6	02 d5								.word	TAB_ASCS		; table for "S"
>d3b8	2d d5								.word	TAB_ASCT		; table for "T"
>d3ba	41 d5								.word	TAB_ASCU		; table for "U"
>d3bc	52 d5								.word	TAB_ASCV		; table for "V"
>d3be	5e d5								.word	TAB_ASCW		; table for "W"
>d3c0	6d d5								.word	TAB_POWR		; table for "^"
.d3c2									TAB_STAR
>d3c2	b9 00								.byte TK_MUL,$00		; *
.d3c4									TAB_PLUS
>d3c4	b7 00								.byte TK_PLUS,$00		; +
.d3c6									TAB_MNUS
>d3c6	b8 00								.byte TK_MINUS,$00	; -
.d3c8									TAB_SLAS
>d3c8	ba 00								.byte TK_DIV,$00		; /
.d3ca									TAB_LESS
.d3ca									LBB_LSHIFT
>d3ca	3c c0								.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
>d3cc	c3									.byte TK_LT			; <
>d3cd	00									.byte	$00
.d3ce									TAB_EQUL
>d3ce	c2 00								.byte TK_EQUAL,$00	; =
.d3d0									TAB_MORE
.d3d0									LBB_RSHIFT
>d3d0	3e bf								.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
>d3d2	c1									.byte TK_GT			; >
>d3d3	00									.byte	$00
.d3d4									TAB_QEST
>d3d4	9f 00								.byte TK_PRINT,$00	; ?
.d3d6									TAB_ASCA
.d3d6									LBB_ABS
>d3d6	42 53 28 c6							.text	"BS(",TK_ABS	; ABS(
.d3da									LBB_AND
>d3da	4e 44 bc							.text	"ND",TK_AND		; AND
.d3dd									LBB_ASC
>d3dd	53 43 28 d8							.text	"SC(",TK_ASC	; ASC(
.d3e1									LBB_ATN
>d3e1	54 4e 28 d1							.text	"TN(",TK_ATN	; ATN(
>d3e5	00									.byte	$00
.d3e6									TAB_ASCB
.d3e6									LBB_BINS
>d3e6	49 4e 24 28 dd						.text	"IN$(",TK_BINS	; BIN$(
.d3eb									LBB_BITCLR
>d3eb	49 54 43 4c 52 a8					.text	"ITCLR",TK_BITCLR	; BITCLR
.d3f1									LBB_BITSET
>d3f1	49 54 53 45 54 a7					.text	"ITSET",TK_BITSET	; BITSET
.d3f7									LBB_BITTST
>d3f7	49 54 54 53 54 28 de				.text	"ITTST(",TK_BITTST
>d3fe	00									.byte	$00
.d3ff									TAB_ASCC
.d3ff									LBB_CALL
>d3ff	41 4c 4c 9c							.text	"ALL",TK_CALL	; CALL
.d403									LBB_CHRS
>d403	48 52 24 28 db						.text	"HR$(",TK_CHRS	; CHR$(
.d408									LBB_CLEAR
>d408	4c 45 41 52 a2						.text	"LEAR",TK_CLEAR	; CLEAR
.d40d									LBB_CONT
>d40d	4f 4e 54 a0							.text	"ONT",TK_CONT	; CONT
.d411									LBB_COS
>d411	4f 53 28 ce							.text	"OS(",TK_COS	; COS(
>d415	00									.byte	$00
.d416									TAB_ASCD
.d416									LBB_DATA
>d416	41 54 41 83							.text	"ATA",TK_DATA	; DATA
.d41a									LBB_DEC
>d41a	45 43 88							.text	"EC",TK_DEC		; DEC
.d41d									LBB_DEEK
>d41d	45 45 4b 28 d3						.text	"EEK(",TK_DEEK	; DEEK(
.d422									LBB_DEF
>d422	45 46 99							.text	"EF",TK_DEF		; DEF
.d425									LBB_DIM
>d425	49 4d 85							.text	"IM",TK_DIM		; DIM
.d428									LBB_DOKE
>d428	4f 4b 45 9b							.text	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
.d42c									LBB_DO
>d42c	4f 9d								.text	"O",TK_DO		; DO
>d42e	00									.byte	$00
.d42f									TAB_ASCE
.d42f									LBB_ELSE
>d42f	4c 53 45 ad							.text	"LSE",TK_ELSE	; ELSE
.d433									LBB_END
>d433	4e 44 80							.text	"ND",TK_END		; END
.d436									LBB_EOR
>d436	4f 52 bd							.text	"OR",TK_EOR		; EOR
.d439									LBB_EXIT
>d439	58 49 54 ab							.text	"XIT",TK_EXIT	; EXIT
.d43d									LBB_EXP
>d43d	58 50 28 cd							.text	"XP(",TK_EXP	; EXP(
>d441	00									.byte	$00
.d442									TAB_ASCF
.d442									LBB_FN
>d442	4e af								.byte	"N",TK_FN		; FN
.d444									LBB_FOR
>d444	4f 52 81							.text	"OR",TK_FOR		; FOR
.d447									LBB_FRE
>d447	52 45 28 c8							.text	"RE(",TK_FRE	; FRE(
>d44b	00									.byte	$00
.d44c									TAB_ASCG
.d44c									LBB_GET
>d44c	45 54 a5							.text	"ET",TK_GET		; GET
.d44f									LBB_GOSUB
>d44f	4f 53 55 42 8d						.text	"OSUB",TK_GOSUB	; GOSUB
.d454									LBB_GOTO
>d454	4f 54 4f 89							.text	"OTO",TK_GOTO	; GOTO
>d458	00									.byte	$00
.d459									TAB_ASCH
.d459									LBB_HEXS
>d459	45 58 24 28 dc						.text	"EX$(",TK_HEXS	; HEX$(
>d45e	00									.byte	$00
.d45f									TAB_ASCI
.d45f									LBB_IF
>d45f	46 8b								.byte	"F",TK_IF		; IF
.d461									LBB_INC
>d461	4e 43 95							.text	"NC",TK_INC		; INC
.d464									LBB_INPUT
>d464	4e 50 55 54 84						.text	"NPUT",TK_INPUT	; INPUT
.d469									LBB_INT
>d469	4e 54 28 c5							.text	"NT(",TK_INT	; INT(
.d46d									LBB_IRQ
>d46d	52 51 a9							.text	"RQ",TK_IRQ		; IRQ
>d470	00									.byte	$00
.d471									TAB_ASCL
.d471									LBB_LCASES
>d471	43 41 53 45 24 28 da				.text	"CASE$(",TK_LCASES
.d478									LBB_LEFTS
>d478	45 46 54 24 28 e4					.text	"EFT$(",TK_LEFTS	; LEFT$(
.d47e									LBB_LEN
>d47e	45 4e 28 d5							.text	"EN(",TK_LEN	; LEN(
.d482									LBB_LET
>d482	45 54 87							.text	"ET",TK_LET		; LET
.d485									LBB_LIST
>d485	49 53 54 a1							.text	"IST",TK_LIST	; LIST
.d489									LBB_LOAD
>d489	4f 41 44 97							.text	"OAD",TK_LOAD	; LOAD
.d48d									LBB_LOG
>d48d	4f 47 28 cc							.text	"OG(",TK_LOG	; LOG(
.d491									LBB_LOOP
>d491	4f 4f 50 9e							.text	"OOP",TK_LOOP	; LOOP
>d495	00									.byte	$00
.d496									TAB_ASCM
.d496									LBB_MAX
>d496	41 58 28 df							.text	"AX(",TK_MAX	; MAX(
.d49a									LBB_MIDS
>d49a	49 44 24 28 e6						.text	"ID$(",TK_MIDS	; MID$(
.d49f									LBB_MIN
>d49f	49 4e 28 e0							.text	"IN(",TK_MIN	; MIN(
>d4a3	00									.byte	$00
.d4a4									TAB_ASCN
.d4a4									LBB_NEW
>d4a4	45 57 a3							.text	"EW",TK_NEW		; NEW
.d4a7									LBB_NEXT
>d4a7	45 58 54 82							.text	"EXT",TK_NEXT	; NEXT
.d4ab									LBB_NMI
>d4ab	4d 49 aa							.text	"MI",TK_NMI		; NMI
.d4ae									LBB_NOT
>d4ae	4f 54 b2							.text	"OT",TK_NOT		; NOT
.d4b1									LBB_NULL
>d4b1	55 4c 4c 94							.text	"ULL",TK_NULL	; NULL
>d4b5	00									.byte	$00
.d4b6									TAB_ASCO
.d4b6									LBB_OFF
>d4b6	46 46 b6							.text	"FF",TK_OFF		; OFF
.d4b9									LBB_ON
>d4b9	4e 93								.byte	"N",TK_ON		; ON
.d4bb									LBB_OR
>d4bb	52 be								.byte	"R",TK_OR		; OR
>d4bd	00									.byte	$00
.d4be									TAB_ASCP
.d4be									LBB_PEEK
>d4be	45 45 4b 28 d2						.text	"EEK(",TK_PEEK	; PEEK(
.d4c3									LBB_PI
>d4c3	49 e1								.byte	"I",TK_PI		; PI
.d4c5									LBB_POKE
>d4c5	4f 4b 45 9a							.text	"OKE",TK_POKE	; POKE
.d4c9									LBB_POS
>d4c9	4f 53 28 c9							.text	"OS(",TK_POS	; POS(
.d4cd									LBB_PRINT
>d4cd	52 49 4e 54 9f						.text	"RINT",TK_PRINT	; PRINT
>d4d2	00									.byte	$00
.d4d3									TAB_ASCR
.d4d3									LBB_READ
>d4d3	45 41 44 86							.text	"EAD",TK_READ	; READ
.d4d7									LBB_REM
>d4d7	45 4d 91							.text	"EM",TK_REM		; REM
.d4da									LBB_RESTORE
>d4da	45 53 54 4f 52 45 8c				.text	"ESTORE",TK_RESTORE
.d4e1									LBB_RETIRQ
>d4e1	45 54 49 52 51 8e					.text	"ETIRQ",TK_RETIRQ	; RETIRQ
.d4e7									LBB_RETNMI
>d4e7	45 54 4e 4d 49 8f					.text	"ETNMI",TK_RETNMI	; RETNMI
.d4ed									LBB_RETURN
>d4ed	45 54 55 52 4e 90					.text	"ETURN",TK_RETURN	; RETURN
.d4f3									LBB_RIGHTS
>d4f3	49 47 48 54 24 28 e5				.text	"IGHT$(",TK_RIGHTS
.d4fa									LBB_RND
>d4fa	4e 44 28 cb							.text	"ND(",TK_RND	; RND(
.d4fe									LBB_RUN
>d4fe	55 4e 8a							.text	"UN",TK_RUN		; RUN
>d501	00									.byte	$00
.d502									TAB_ASCS
.d502									LBB_SADD
>d502	41 44 44 28 d4						.text	"ADD(",TK_SADD	; SADD(
.d507									LBB_SAVE
>d507	41 56 45 98							.text	"AVE",TK_SAVE	; SAVE
.d50b									LBB_SGN
>d50b	47 4e 28 c4							.text	"GN(",TK_SGN	; SGN(
.d50f									LBB_SIN
>d50f	49 4e 28 cf							.text	"IN(",TK_SIN	; SIN(
.d513									LBB_SPC
>d513	50 43 28 b0							.text	"PC(",TK_SPC	; SPC(
.d517									LBB_SQR
>d517	51 52 28 ca							.text	"QR(",TK_SQR	; SQR(
.d51b									LBB_STEP
>d51b	54 45 50 b3							.text	"TEP",TK_STEP	; STEP
.d51f									LBB_STOP
>d51f	54 4f 50 92							.text	"TOP",TK_STOP	; STOP
.d523									LBB_STRS
>d523	54 52 24 28 d6						.text	"TR$(",TK_STRS	; STR$(
.d528									LBB_SWAP
>d528	57 41 50 a6							.text	"WAP",TK_SWAP	; SWAP
>d52c	00									.byte	$00
.d52d									TAB_ASCT
.d52d									LBB_TAB
>d52d	41 42 28 ac							.text	"AB(",TK_TAB	; TAB(
.d531									LBB_TAN
>d531	41 4e 28 d0							.text	"AN(",TK_TAN	; TAN(
.d535									LBB_THEN
>d535	48 45 4e b1							.text	"HEN",TK_THEN	; THEN
.d539									LBB_TO
>d539	4f ae								.text	"O",TK_TO		; TO
.d53b									LBB_TWOPI
>d53b	57 4f 50 49 e2						.text	"WOPI",TK_TWOPI	; TWOPI
>d540	00									.byte	$00
.d541									TAB_ASCU
.d541									LBB_UCASES
>d541	43 41 53 45 24 28 d9				.text	"CASE$(",TK_UCASES
.d548									LBB_UNTIL
>d548	4e 54 49 4c b4						.text	"NTIL",TK_UNTIL	; UNTIL
.d54d									LBB_USR
>d54d	53 52 28 c7							.text	"SR(",TK_USR	; USR(
>d551	00									.byte	$00
.d552									TAB_ASCV
.d552									LBB_VAL
>d552	41 4c 28 d7							.text	"AL(",TK_VAL	; VAL(
.d556									LBB_VPTR
>d556	41 52 50 54 52 28 e3				.text	"ARPTR(",TK_VPTR	; VARPTR(
>d55d	00									.byte	$00
.d55e									TAB_ASCW
.d55e									LBB_WAIT
>d55e	41 49 54 96							.text	"AIT",TK_WAIT	; WAIT
.d562									LBB_WHILE
>d562	48 49 4c 45 b5						.text	"HILE",TK_WHILE	; WHILE
.d567									LBB_WIDTH
>d567	49 44 54 48 a4						.text	"IDTH",TK_WIDTH	; WIDTH
>d56c	00									.byte	$00
.d56d									TAB_POWR
>d56d	bb 00								.byte	TK_POWER,$00	; ^
.d56f									LAB_KEYT
>d56f	03 45								.byte	3,'E'
>d571	33 d4								.word	LBB_END		; END
>d573	03 46								.byte	3,'F'
>d575	44 d4								.word	LBB_FOR		; FOR
>d577	04 4e								.byte	4,'N'
>d579	a7 d4								.word	LBB_NEXT		; NEXT
>d57b	04 44								.byte	4,'D'
>d57d	16 d4								.word	LBB_DATA		; DATA
>d57f	05 49								.byte	5,'I'
>d581	64 d4								.word	LBB_INPUT		; INPUT
>d583	03 44								.byte	3,'D'
>d585	25 d4								.word	LBB_DIM		; DIM
>d587	04 52								.byte	4,'R'
>d589	d3 d4								.word	LBB_READ		; READ
>d58b	03 4c								.byte	3,'L'
>d58d	82 d4								.word	LBB_LET		; LET
>d58f	03 44								.byte	3,'D'
>d591	1a d4								.word	LBB_DEC		; DEC
>d593	04 47								.byte	4,'G'
>d595	54 d4								.word	LBB_GOTO		; GOTO
>d597	03 52								.byte	3,'R'
>d599	fe d4								.word	LBB_RUN		; RUN
>d59b	02 49								.byte	2,'I'
>d59d	5f d4								.word	LBB_IF		; IF
>d59f	07 52								.byte	7,'R'
>d5a1	da d4								.word	LBB_RESTORE		; RESTORE
>d5a3	05 47								.byte	5,'G'
>d5a5	4f d4								.word	LBB_GOSUB		; GOSUB
>d5a7	06 52								.byte	6,'R'
>d5a9	e1 d4								.word	LBB_RETIRQ		; RETIRQ
>d5ab	06 52								.byte	6,'R'
>d5ad	e7 d4								.word	LBB_RETNMI		; RETNMI
>d5af	06 52								.byte	6,'R'
>d5b1	ed d4								.word	LBB_RETURN		; RETURN
>d5b3	03 52								.byte	3,'R'
>d5b5	d7 d4								.word	LBB_REM		; REM
>d5b7	04 53								.byte	4,'S'
>d5b9	1f d5								.word	LBB_STOP		; STOP
>d5bb	02 4f								.byte	2,'O'
>d5bd	b9 d4								.word	LBB_ON		; ON
>d5bf	04 4e								.byte	4,'N'
>d5c1	b1 d4								.word	LBB_NULL		; NULL
>d5c3	03 49								.byte	3,'I'
>d5c5	61 d4								.word	LBB_INC		; INC
>d5c7	04 57								.byte	4,'W'
>d5c9	5e d5								.word	LBB_WAIT		; WAIT
>d5cb	04 4c								.byte	4,'L'
>d5cd	89 d4								.word	LBB_LOAD		; LOAD
>d5cf	04 53								.byte	4,'S'
>d5d1	07 d5								.word	LBB_SAVE		; SAVE
>d5d3	03 44								.byte	3,'D'
>d5d5	22 d4								.word	LBB_DEF		; DEF
>d5d7	04 50								.byte	4,'P'
>d5d9	c5 d4								.word	LBB_POKE		; POKE
>d5db	04 44								.byte	4,'D'
>d5dd	28 d4								.word	LBB_DOKE		; DOKE
>d5df	04 43								.byte	4,'C'
>d5e1	ff d3								.word	LBB_CALL		; CALL
>d5e3	02 44								.byte	2,'D'
>d5e5	2c d4								.word	LBB_DO		; DO
>d5e7	04 4c								.byte	4,'L'
>d5e9	91 d4								.word	LBB_LOOP		; LOOP
>d5eb	05 50								.byte	5,'P'
>d5ed	cd d4								.word	LBB_PRINT		; PRINT
>d5ef	04 43								.byte	4,'C'
>d5f1	0d d4								.word	LBB_CONT		; CONT
>d5f3	04 4c								.byte	4,'L'
>d5f5	85 d4								.word	LBB_LIST		; LIST
>d5f7	05 43								.byte	5,'C'
>d5f9	08 d4								.word	LBB_CLEAR		; CLEAR
>d5fb	03 4e								.byte	3,'N'
>d5fd	a4 d4								.word	LBB_NEW		; NEW
>d5ff	05 57								.byte	5,'W'
>d601	67 d5								.word	LBB_WIDTH		; WIDTH
>d603	03 47								.byte	3,'G'
>d605	4c d4								.word	LBB_GET		; GET
>d607	04 53								.byte	4,'S'
>d609	28 d5								.word	LBB_SWAP		; SWAP
>d60b	06 42								.byte	6,'B'
>d60d	f1 d3								.word	LBB_BITSET		; BITSET
>d60f	06 42								.byte	6,'B'
>d611	eb d3								.word	LBB_BITCLR		; BITCLR
>d613	03 49								.byte	3,'I'
>d615	6d d4								.word	LBB_IRQ		; IRQ
>d617	03 4e								.byte	3,'N'
>d619	ab d4								.word	LBB_NMI		; NMI
>d61b	04 45								.byte	4,'E'
>d61d	39 d4								.word	LBB_EXIT	; EXIT
>d61f	04 54								.byte	4,'T'
>d621	2d d5								.word	LBB_TAB		; TAB
>d623	04 45								.byte	4,'E'
>d625	2f d4								.word	LBB_ELSE		; ELSE
>d627	02 54								.byte	2,'T'
>d629	39 d5								.word	LBB_TO		; TO
>d62b	02 46								.byte	2,'F'
>d62d	42 d4								.word	LBB_FN		; FN
>d62f	04 53								.byte	4,'S'
>d631	13 d5								.word	LBB_SPC		; SPC
>d633	04 54								.byte	4,'T'
>d635	35 d5								.word	LBB_THEN		; THEN
>d637	03 4e								.byte	3,'N'
>d639	ae d4								.word	LBB_NOT		; NOT
>d63b	04 53								.byte	4,'S'
>d63d	1b d5								.word	LBB_STEP		; STEP
>d63f	05 55								.byte	5,'U'
>d641	48 d5								.word	LBB_UNTIL		; UNTIL
>d643	05 57								.byte	5,'W'
>d645	62 d5								.word	LBB_WHILE		; WHILE
>d647	03 4f								.byte	3,'O'
>d649	b6 d4								.word	LBB_OFF		; OFF
>d64b	01 2b								.byte	1,'+'
>d64d	00 00								.word	$0000			; +
>d64f	01 2d								.byte	1,'-'
>d651	00 00								.word	$0000			; -
>d653	01 2a								.byte	1,'*'
>d655	00 00								.word	$0000			; *
>d657	01 2f								.byte	1,'/'
>d659	00 00								.word	$0000			; /
>d65b	01 5e								.byte	1,'^'
>d65d	00 00								.word	$0000			; ^
>d65f	03 41								.byte	3,'A'
>d661	da d3								.word	LBB_AND		; AND
>d663	03 45								.byte	3,'E'
>d665	36 d4								.word	LBB_EOR		; EOR
>d667	02 4f								.byte	2,'O'
>d669	bb d4								.word	LBB_OR		; OR
>d66b	02 3e								.byte	2,'>'
>d66d	d0 d3								.word	LBB_RSHIFT		; >>
>d66f	02 3c								.byte	2,'<'
>d671	ca d3								.word	LBB_LSHIFT		; <<
>d673	01 3e								.byte	1,'>'
>d675	00 00								.word	$0000			; >
>d677	01 3d								.byte	1,'='
>d679	00 00								.word	$0000			; =
>d67b	01 3c								.byte	1,'<'
>d67d	00 00								.word	$0000			; <
>d67f	04 53								.byte	4,'S'			;
>d681	0b d5								.word	LBB_SGN		; SGN
>d683	04 49								.byte	4,'I'			;
>d685	69 d4								.word	LBB_INT		; INT
>d687	04 41								.byte	4,'A'			;
>d689	d6 d3								.word	LBB_ABS		; ABS
>d68b	04 55								.byte	4,'U'			;
>d68d	4d d5								.word	LBB_USR		; USR
>d68f	04 46								.byte	4,'F'			;
>d691	47 d4								.word	LBB_FRE		; FRE
>d693	04 50								.byte	4,'P'			;
>d695	c9 d4								.word	LBB_POS		; POS
>d697	04 53								.byte	4,'S'			;
>d699	17 d5								.word	LBB_SQR		; SQR
>d69b	04 52								.byte	4,'R'			;
>d69d	fa d4								.word	LBB_RND		; RND
>d69f	04 4c								.byte	4,'L'			;
>d6a1	8d d4								.word	LBB_LOG		; LOG
>d6a3	04 45								.byte	4,'E'			;
>d6a5	3d d4								.word	LBB_EXP		; EXP
>d6a7	04 43								.byte	4,'C'			;
>d6a9	11 d4								.word	LBB_COS		; COS
>d6ab	04 53								.byte	4,'S'			;
>d6ad	0f d5								.word	LBB_SIN		; SIN
>d6af	04 54								.byte	4,'T'			;
>d6b1	31 d5								.word	LBB_TAN		; TAN
>d6b3	04 41								.byte	4,'A'			;
>d6b5	e1 d3								.word	LBB_ATN		; ATN
>d6b7	05 50								.byte	5,'P'			;
>d6b9	be d4								.word	LBB_PEEK		; PEEK
>d6bb	05 44								.byte	5,'D'			;
>d6bd	1d d4								.word	LBB_DEEK		; DEEK
>d6bf	05 53								.byte	5,'S'			;
>d6c1	02 d5								.word	LBB_SADD		; SADD
>d6c3	04 4c								.byte	4,'L'			;
>d6c5	7e d4								.word	LBB_LEN		; LEN
>d6c7	05 53								.byte	5,'S'			;
>d6c9	23 d5								.word	LBB_STRS		; STR$
>d6cb	04 56								.byte	4,'V'			;
>d6cd	52 d5								.word	LBB_VAL		; VAL
>d6cf	04 41								.byte	4,'A'			;
>d6d1	dd d3								.word	LBB_ASC		; ASC
>d6d3	07 55								.byte	7,'U'			;
>d6d5	41 d5								.word	LBB_UCASES		; UCASE$
>d6d7	07 4c								.byte	7,'L'			;
>d6d9	71 d4								.word	LBB_LCASES		; LCASE$
>d6db	05 43								.byte	5,'C'			;
>d6dd	03 d4								.word	LBB_CHRS		; CHR$
>d6df	05 48								.byte	5,'H'			;
>d6e1	59 d4								.word	LBB_HEXS		; HEX$
>d6e3	05 42								.byte	5,'B'			;
>d6e5	e6 d3								.word	LBB_BINS		; BIN$
>d6e7	07 42								.byte	7,'B'			;
>d6e9	f7 d3								.word	LBB_BITTST		; BITTST
>d6eb	04 4d								.byte	4,'M'			;
>d6ed	96 d4								.word	LBB_MAX		; MAX
>d6ef	04 4d								.byte	4,'M'			;
>d6f1	9f d4								.word	LBB_MIN		; MIN
>d6f3	02 50								.byte	2,'P'			;
>d6f5	c3 d4								.word	LBB_PI		; PI
>d6f7	05 54								.byte	5,'T'			;
>d6f9	3b d5								.word	LBB_TWOPI		; TWOPI
>d6fb	07 56								.byte	7,'V'			;
>d6fd	56 d5								.word	LBB_VPTR		; VARPTR
>d6ff	06 4c								.byte	6,'L'			;
>d701	78 d4								.word	LBB_LEFTS		; LEFT$
>d703	07 52								.byte	7,'R'			;
>d705	f3 d4								.word	LBB_RIGHTS		; RIGHT$
>d707	05 4d								.byte	5,'M'			;
>d709	9a d4								.word	LBB_MIDS		; MID$
.d70b									LAB_BAER
>d70b	2f d7								.word	ERR_NF		;$00 NEXT without FOR
>d70d	40 d7								.word	ERR_SN		;$02 syntax
>d70f	47 d7								.word	ERR_RG		;$04 RETURN without GOSUB
>d711	5c d7								.word	ERR_OD		;$06 out of data
>d713	68 d7								.word	ERR_FC		;$08 function call
>d715	76 d7								.word	ERR_OV		;$0A overflow
>d717	7f d7								.word	ERR_OM		;$0C out of memory
>d719	8d d7								.word	ERR_US		;$0E undefined statement
>d71b	a1 d7								.word	ERR_BS		;$10 array bounds
>d71d	ae d7								.word	ERR_DD		;$12 double dimension array
>d71f	bf d7								.word	ERR_D0		;$14 divide by 0
>d721	ce d7								.word	ERR_ID		;$16 illegal direct
>d723	dd d7								.word	ERR_TM		;$18 type mismatch
>d725	eb d7								.word	ERR_LS		;$1A long string
>d727	fb d7								.word	ERR_ST		;$1C string too complex
>d729	0e d8								.word	ERR_CN		;$1E continue error
>d72b	1d d8								.word	ERR_UF		;$20 undefined function
>d72d	30 d8								.word ERR_LD		;$22 LOOP without DO
>d72f	4e 45 58 54 20 77 69 74			ERR_NF	.text	"NEXT without FOR",$00
>d737	68 6f 75 74 20 46 4f 52 00
>d740	53 79 6e 74 61 78 00			ERR_SN	.text	"Syntax",$00
>d747	52 45 54 55 52 4e 20 77			ERR_RG	.text	"RETURN without GOSUB",$00
>d74f	69 74 68 6f 75 74 20 47 4f 53 55 42 00
>d75c	4f 75 74 20 6f 66 20 44			ERR_OD	.text	"Out of DATA",$00
>d764	41 54 41 00
>d768	46 75 6e 63 74 69 6f 6e			ERR_FC	.text	"Function call",$00
>d770	20 63 61 6c 6c 00
>d776	4f 76 65 72 66 6c 6f 77			ERR_OV	.text	"Overflow",$00
>d77e	00
>d77f	4f 75 74 20 6f 66 20 6d			ERR_OM	.text	"Out of memory",$00
>d787	65 6d 6f 72 79 00
>d78d	55 6e 64 65 66 69 6e 65			ERR_US	.text	"Undefined statement",$00
>d795	64 20 73 74 61 74 65 6d 65 6e 74 00
>d7a1	41 72 72 61 79 20 62 6f			ERR_BS	.text	"Array bounds",$00
>d7a9	75 6e 64 73 00
>d7ae	44 6f 75 62 6c 65 20 64			ERR_DD	.text	"Double dimension",$00
>d7b6	69 6d 65 6e 73 69 6f 6e 00
>d7bf	44 69 76 69 64 65 20 62			ERR_D0	.text	"Divide by zero",$00
>d7c7	79 20 7a 65 72 6f 00
>d7ce	49 6c 6c 65 67 61 6c 20			ERR_ID	.text	"Illegal direct",$00
>d7d6	64 69 72 65 63 74 00
>d7dd	54 79 70 65 20 6d 69 73			ERR_TM	.text	"Type mismatch",$00
>d7e5	6d 61 74 63 68 00
>d7eb	53 74 72 69 6e 67 20 74			ERR_LS	.text	"String too long",$00
>d7f3	6f 6f 20 6c 6f 6e 67 00
>d7fb	53 74 72 69 6e 67 20 74			ERR_ST	.text	"String too complex",$00
>d803	6f 6f 20 63 6f 6d 70 6c 65 78 00
>d80e	43 61 6e 27 74 20 63 6f			ERR_CN	.text	"Can't continue",$00
>d816	6e 74 69 6e 75 65 00
>d81d	55 6e 64 65 66 69 6e 65			ERR_UF	.text	"Undefined function",$00
>d825	64 20 66 75 6e 63 74 69 6f 6e 00
>d830	4c 4f 4f 50 20 77 69 74			ERR_LD	.text	"LOOP without DO",$00
>d838	68 6f 75 74 20 44 4f 00
>d840	0a 42 72 65 61 6b 00			LAB_BMSG	.text	$0A,"Break",$00
>d847	20 45 72 72 6f 72 00			LAB_EMSG	.text	" Error",$00
>d84e	20 69 6e 20 6c 69 6e 65			LAB_LMSG	.text	" in line ",$00
>d856	20 00
>d858	0a 52 65 61 64 79 0a 00			LAB_RMSG	.text	$0A,"Ready",$0A,$00
>d860	20 45 78 74 72 61 20 69			LAB_IMSG	.text	" Extra ignored",$0A,$00
>d868	67 6e 6f 72 65 64 0a 00
>d870	20 52 65 64 6f 20 66 72			LAB_REDO	.text	" Redo from start",$0A,$00
>d878	6f 6d 20 73 74 61 72 74 0a 00
.d882									AA_end_basic

;******  Return to file: /Users/davidhunt/Projects/dputer2/src/basic/min_mon.asm


;******  End of listing
